---
title: "INTERNATIONAL ARMS TRADE NETWORKS: DATA CLEANING II (harmonization/matching country IDs, matrices, and node covariates)"
author: "QN Nguyen"
date: "`r Sys.Date()`"
format:
  html:
    theme: cosmo
    highlight-style: tango
    toc: true
    toc-depth: 2
    toc-float: true
editor: 
  markdown: 
    wrap: 72
---

# SETTINGS

```{r}
knitr::opts_chunk$set(
  fig.width = 12,
  fig.height = 10,
  fig.path = "Figs/",
  fig.align = "center",
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  error = FALSE,
  eval = TRUE,
  include = TRUE
)

options(
  xtable.comment = FALSE,
  scipen = 9999,
  tinytex.verbose = TRUE
)
```

```{r}
## install Rtools
# .libPaths()
# library(rtools)
# R.version
# install.packages("rtools")
# Sys.which("make")
# writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
# writeLines('PATH="C:/Rtools;${PATH}"', con = "~/.Renviron")

```

```{r}
# rm(list= ls()) # Clean up environment

## Basic tools
pacman::p_load(devtools, ggplot2, dplyr, tidyr, haven, purrr, sjmisc, countrycode, stringr, kableExtra, stats, sjmisc) # , vtable, foreign, summarytools, ggcorrplot, qgraph, psych, utils, scales, graphics, magrittr, Hmisc, 

### SNA TOOLS
# pacman::p_load(network, igraph, statnet, intergraph, sna, networkDynamic) # qgraph, tidygraph, ergm, btergm, tsna, ndtv, htmlwidgets

# quick overview
tspells <- c("1993-97","1998-02","2003-07","2008-12","2013-17","2018-23")
# save(tspells, file = "tspells.RData")
# load("tspells.RData")
```



# I) DYADIC DATA: IMPORT & CLEANING

## I.1) International arms transfer (SIPRI)

The SIPRI Arms Transfers Database contains information on all transfers of major conventional arms from 1950 to the most recent full calendar year. It is a unique resource for researchers, policymakers and analysts, the media and civil society interested in monitoring and measuring the international flow of major conventional arms.

The SIPRI Arms Transfers Database was updated on 11 March 2024. The database includes updated data on transfers of major arms for 1950–2023, which replaces all previous data on arms transfers published by SIPRI.

https://www.sipri.org/databases/armstransfers
https://doi.org/10.55163/SAFC1241



### import

```{r}
## import these in case they're needed for descriptive purposes 
# load("sipri2.RData") # complete dataset inc. dyadic deal-level & year-level arms transfer data
# load("sipri3.RData") # dyadic deal-level arms transfer data

## import this for the network modelling
# load("sipri4.RData") # dyadic country-year arms transfer data
```


### subset dataset & simplify variable names
```{r}
# names(sipri4)
iat <- sipri4 %>% # rename & simplify vbl names
  dplyr::rename(year = year_delivery,
         tiv = year_tiv_total,
         tiv_mean = year_tiv_mean,
         count = year_delivery_count,
         categories = year_weapon_categories,
         description = year_weapon_descriptions,
         designation = year_weapon_designation,
         order_ids = year_order_ids,
         order_years = year_order_years,
         units_delivered = year_units_delivered,
         tiv_units = year_tiv_units,
         tiv_orders = year_tiv_orders,
         tiv_deliveries = year_tiv_deliveries)
```

### save 1
```{r}
# Save working file
# save(iat, file = "iat.RData") # as R data file
# load("iat.RData")
```


### subset 1993-2023

Subset post Cold War (1993-2023) data and add time spells
--> dissolution of USSR on 26.12.1991, and subsequent changes & independence declarations during 1992, so observation period starts with 1993
```{r}
# names(iat)
# library(dplyr)
iat.pcw <- iat %>% 
  # subset post Cold War period 
  # dplyr::filter(geopol_del != "Cold War") %>%
  dplyr::filter(year >= 1993 & year <= 2023) %>%
  # create a variable t to assign time spell identifier
  dplyr::mutate(t = ifelse(year <= 1997, "t1",
                      ifelse(year <= 2002, "t2",
                           ifelse(year <= 2007, "t3",
                                  ifelse(year <= 2012, "t4",
                                         ifelse(year <= 2017, "t5",
                                                ifelse(year <= 2023, "t6"
                                                ))))))) %>% 

  # select dyadic attributes to keep in network
  dplyr::select(supplier, recipient, t, year, tiv, everything()) %>% 
  # order rows
  dplyr::arrange(year, supplier, recipient)

# range(iat.pcw$year) # 1993-2023
```

@nga: reduced from n=22328 to n=11567 (1993-2023)


Label time spells
```{r}
# library(dplyr)
# library(haven)
iat.pcw <- iat.pcw %>%
  dplyr::mutate(
    t = haven::labelled(t, 
                        c("1993-1997" = "t1", 
                          "1998-2002" = "t2",
                          "2003-2007" = "t3",
                          "2008-2012" = "t4",
                          "2013-2017" = "t5",
                          "2018-2023" = "t6"),
                        label = "time spell"))
## check
# head(iat.pcw$t)
# head(iat.pcw)
# tail(iat.pcw)
```

```{r}
# iat.pcw2 <- iat.pcw
# iat.pcw <- iat.pcw2
```



### country code harmonization 

#### analysis: best fitting country codes system
```{r}
library(countrycode)
## countrycodes
ccodes <- countrycode::codelist # data frame listing popular country codes
# names(ccodes)
?codelist # country codes designations
```


If given a database of country codes and not sure what code format they are in, using guess_field() function shows what percentage of values match which which coding system.

```{r}
# countries in the iat dataset since 1993

a <- union(iat.pcw$supplier, iat.pcw$recipient) # unique countries among recipients and suppliers
countrycode::guess_field(a, min_similarity=90) # which ccode most likely was applied in sipri dataset? --> best match = english country.name
rm(a)

```

```{r}
## OLD CODE
# aa <- intersect(iat.pcw$supplier, iat.pcw$recipient) # countries that are both recipients and suppliers
# aaa <- setdiff(iat.pcw$supplier, iat.pcw$recipient) # those suppliers that don't buy (only weird guy here = Aruba)
# aaa2 <- setdiff(iat.pcw$recipient, iat.pcw$supplier) # those recipients that don't sell
# 
# a_df <- as.data.frame(a) # = 185 countries
# a_df <- sort(a_df)

```



##### a) try out prevalent ccodes

###### correlates of war (cow)

https://www.jkarreth.net/countrycodes.html
```{r}
## import list of cow countries, to get an overview

# cow_ccode <- read.csv("data/Gleditsch geographic distance/COW-country-codes.csv", sep=",", header = T, check.names = F)

cow_list <- read.csv("data/System_members/COW_states2016.csv", sep=",", header = T, check.names = F)

cow_list <- cow_list %>% 
  dplyr::rename(cowc = stateabb, cown = ccode, cowen = statenme, year_member = styear) %>% 
  dplyr::select(cowc,cown,cowen,year_member) %>% 
  dplyr::arrange(cowen)

cow_list <- cow_list[!duplicated(cow_list), ] # delete dups

names(cow_list)
# View(cow_list)
# head(cow_list)
```

```{r}
## additional ccodes 

# reassign & harmonize cow codes
cow_list$cowen <- countrycode(cow_list$cown, origin = 'cown', destination = 'cow.name')
cow_list$cowc <- countrycode(cow_list$cown, origin = 'cown', destination = 'cowc')

# english names
cow_list$state <- countrycode(cow_list$cown, origin = 'cown', destination = 'country.name') # GFR, KOR i.e. 260, 730 not matched

# iso 3
cow_list$iso <- countrycode(cow_list$state, origin = 'country.name', destination = 'iso3c') 
# not matched: Austria-Hungary, Baden, Bavaria, Czechoslovakia, German Democratic Republic, Hanover, Hesse Electoral, Hesse Grand Ducal, Kosovo, Mecklenburg Schwerin, Modena, Parma, Republic of Vietnam, Saxony, Tuscany, Two Sicilies, Wuerttemburg, Yemen Arab Republic, Yemen People's Republic, Yugoslavia, Zanzibar

# un m49
cow_list$un <- countrycode(cow_list$state, origin = 'country.name', destination = 'un')
# not matched: Austria-Hungary, Baden, Bavaria, Czechoslovakia, German Democratic Republic, Hanover, Hesse Electoral, Hesse Grand Ducal, Kosovo, Mecklenburg Schwerin, Modena, Parma, Republic of Vietnam, Saxony, Taiwan, Tuscany, Two Sicilies, Wuerttemburg, Yemen Arab Republic, Yemen People's Republic, Yugoslavia, Zanzibar

# reassign & harmonize english names
cow_list$state <- countrycode(cow_list$iso, origin = 'iso3c', destination = 'country.name')
```

```{r}
# save(cow_list, file = "cow_list.RData") # as R data file
# load("cow_list.RData") 
```


Convert country names to cow ccodes
```{r}
# cow english name (en)
iat.pcw$cowen1 <- countrycode(iat.pcw$supplier, origin = 'country.name', destination = 'cow.name') # not matched: Aruba, Serbia
iat.pcw$cowen2 <- countrycode(iat.pcw$recipient, origin = 'country.name', destination = 'cow.name') # not matched: Micronesia, Palestine, Serbia, Western Sahara
```

**5 entities in iat that were not recognized in cow**: 
-   Aruba: constituent country within Netherlands, not a sovereign state
-   Palestine: contested territory & sovereignty
-   Western Sahara: contested territory & sovereignty
--> these 3 entities do not exist in the cow system of independent states. can be dropped
-   Micronesia: naming convention is chaotic (Micronesia (Federated States of); Federated States of Micronesia; Micronesia
-   Serbia: a bit of a messy history. 
    - before 1992: Together with 8 other federations, Serbia was part of Yugoslavia from 1918 to 1992. Within Serbia, there were also 2 autonomomus entities Kosovo and Vojvodina. 
    - Yugoslavia lost most entities in 1992, only Serbia and Montenegro remained. 
    - In 2003, Yugoslavia transformed from federal republic to a political union between Serbia and Montenegro. 
    - Final breakup of Serbia & Montenegro into independent countries in 2006.
    - Yugoslavia only exists in the cow & g&w system, but not in the iso or un49 sysem. So it'd make sense to change the COW code for Yugoslavia to Serbia


###### iso 3
```{r}
# iso 3
iat.pcw$iso1 <- countrycode(iat.pcw$supplier, origin = 'country.name', destination = 'iso3c')
iat.pcw$iso2 <- countrycode(iat.pcw$recipient, origin = 'country.name', destination = 'iso3c') # not matched: Kosovo, Micronesia
```

**2 entities in iat that were not recognized in iso3**: 
-   Kosovo: contested status, sovereignty recognized by 104/193 UN members, claimed by Serbia as an autonomous province
-   Micronesia: naming problem, same as earlier


###### un m49
```{r}
# un m49
iat.pcw$un1 <- countrycode(iat.pcw$supplier, origin = 'country.name', destination = 'un')
iat.pcw$un2 <- countrycode(iat.pcw$recipient, origin = 'country.name', destination = 'un') # not matched: Kosovo, Micronesia, Taiwan
```
**3 entities in iat that were not recognized in cow**: 
-   Taiwan: contested status, claimed by China. No UN official membership nor observer status
-   Kosovo
-   Micronesia


###### gleditsch & ward (gw)
```{r}
# gwn
iat.pcw$gwc1 <- countrycode(iat.pcw$supplier, origin = 'country.name', destination = 'gwc') # nm: Aruba, Seychelles
iat.pcw$gwc2 <- countrycode(iat.pcw$recipient, origin = 'country.name', destination = 'gwc') # nm: Antigua and Barbuda, Kiribati, Micronesia, Palau, Palestine, Samoa, Seychelles, Tonga, Tuvalu, Vanuatu, Western Sahara, Yemen
```

**12 entities in iat that were not recognized in gw**: 
-   mostly microstates that are excluded from gw list: Aruba, Kiribati, Micronesia, Palau, Palestine, Samoa, Seychelles, Tonga, Tuvalu, Vanuatu, Western Sahara, Yemen
-   Yemen used to be divided into North and South Yemen. United in 1990. In the G&W system, however, Yemen is still divided into 2 entities.



##### b) summary

Countries in the IAT dataset that are missing in respective country code systems. **Missings in...**

**...ISO**
-   Kosovo: contested status, sovereignty recognized by 104/193 UN members, claimed by Serbia as an autonomous province
-   Micronesia: naming convention problem, i.e. it has several names, including Micronesia (Federated States of); Federated States of Micronesia, FSM (987). In the ISO system, it's called Micronesia (Federated States of).
--> This pb has to be corrected by hand
    
**...UN**
-   Taiwan: contested status, claimed by China. No UN official membership nor observer status
-   Kosovo
-   Micronesia: naming convention pb, in UN system called Micronesia (Federated States of)

**...COW**
-   Aruba: NA
-   Palestine: NA
-   Western Sahara: NA
-   Micronesia: naming convention pb, in COW system called Federated States of Micronesia
-   Serbia
    - English names
      - Serbia, Serbia and Montenegro, Yugoslavia
    - In COW system 
      - MNG (341) 
      - YUG (345) --> Serbia considered same as YUG
    - In G&W 
      - MNG (341), 
      - SER (340), 
      - YUG (345)
    - In ISO-3 
      - MNE (499)
      - SRB (688)
    - In UN49 
      - Montenegro (499) 
      - Serbia (688)
        
**...GW**
- Aruba
  - cow: NA
  - iso: ABW (533)
  - un: 533
- Palau (microstate)
  - cow: PAL (986)
  - iso: PLW (585)
  - un: 585
- Samoa (microstate)
  - cow: WSM (990)  
  - iso: WSM (882)
  - un: 882
- Seychelles (microstate)
  - cow: SEY (591)
  - iso: SYC (690)
  - un: 690
- Micronesia (microstate)
  - cow: FSM (987)
  - iso: FSM (583)
  - un: 583
- Kiribati (microstate)
  - cow: KIR, 946
  - gw: NA 
  - un: 296
  - iso: KIR, 296
- Tonga (microstate)
  - cow: TON (955)
  - gw: NA
  - iso: TON (776)
  - un: 776
- Vanuatu (microstate)
  - no gw
- South Sudan, 626, SSD (seit 2011)
  - un: 728
  - iso: SSD (728)
  - gw: SSD (626)
  - cow: SSD (626)
- Yemen (in G&W system divided into North and South Yemen, but united in 1990)
  - un & iso: yes
  - cow: YEM (679)
  - iso: YEM (887)
- Western Sahara
  - no cow code


##### c) advantages & disadvantages of ccode systems

**COW**: Using the COW and UN M49 country code system to harmonize system members yields the best results with regards to the exclusion of non-sovereign entities in the international system. The COW ccode is also very prevalent in the study of peace/war and international relations. Since the topic of this research is within this domain, it makes sense to use the COW ccode as the "master" system to harmonize country codes across data sets. The only problem with the COW system is that it uses the designation "Yugoslavia" to refer to Serbia even after 2006, despite Yugoslavia ceasing to exist for good.

**UN/ISO**: The UN M49/ISO codes, on the other hand, also take into consideration the status of contested territories in terms of unanimous recognition by UN members. The ISO system is largely based on the UN M49 system, so I'll consider them the same (despite minor differences).

**GW**: Using this system excludes too many countries that feature in the IAT dataset, mainly because they are microstates. Since I want to test the hypothesis of population being a driver of weapons trade decisions, I do not want to exclude these microstates as other authors have done previously. 


##### d) problems

--> Moving forward, the **COW and UN country codes will be used to exclude/filter countries**. However, the Micronesia and Serbia country code assignments will have to be corrected by hand:

1) Micronesia exists in all ccode systems except gwn. So it's not recognized probably because of the way it's spelled, i.e. Micronesia instead of Federated States of Micronesia or Micronesia (Federated States of).
2) The problem with Yugoslavia/Serbia, however, is more complex. This is due to how this entity is considered in the different ccode systems.

E.g. COW and GW systems closely resemble one another, but they have a slightly different interpretation with regards to the secession or unification of entities into one state entity. As explained by Steven Miller 2023: 

"[C]ollisions between the G-W state system data and CoW state system data are unavoidable at the higher levels of temporal aggregation (e.g. state-years). If the user is trying to merge G-W codes into CoW state-year data, they will create duplicate G-W state codes in 1990 for **Yemen Arab Republic/Yemen** (and **Germany/West Germany**). This is because CoW sees two states merging into one new (Yemen) or previous (Germany) state while G-W see one folding into the other. 
A similar situation will happen trying to merge CoW codes into G-W state-year data regarding the final disintegration of **Yugoslavia** in 2006. CoW sees Serbia as preceding, dominating, and succeeding Yugoslavia where G-W see Yugoslavia as an entity entirely distinct from **Serbia**. 
Consider the implication here: a user may have Gleditsch-Ward state-year data for a civil conflict analysis and want to merge in CoW’s national material capabilities data into it. Matching CoW codes to G-W state codes beforehand will invariably create duplicate entries Serbia-2006 and Yugoslavia-2006. The user cannot avoid this. This will happen where the two state systems collide with each other."
(https://svmiller.com/peacesciencer/articles/state-systems.html)



##### e) solution

Since only data for the 1993-2023 was subsetted, the following operations will be applied in successive order:

-   Step 1) in the original data set (whatever its ccode system), these operations will be applied before adding new ccodes:
    - If one of these designations for Micronesia are not used: Micronesia (Federated States of); Federated States of Micronesia, FSM, 987 - then the designation "Micronesia (Federated States of)" will be added for Micronesia
    - Any entry of North Yemen; South Yemen; Yemen Arab Republic; Yemen People's Republic" will be changed to Yemen (unified in 1990) across all ccodes (cow, un, iso codes).
    - Any entry for Czechoslovakia will be excluded (since it has been dissolved into Czech Republic and Slovakia on 1.1.1993).

-   Step 2a) where a data set does not use the cow system, I'll first add the cow ccodes. In this cow code column, any "Serbia" entry in the original data will generate an NA entry, since "Serbia" does not exist in the cow system. This NA entry in the cow column will be converted to "Yugoslavia" (YUG, 345), which is the designation for Serbia in the cow system. Finally, I'll add the m49 and iso3 ccodes to the data set, based on the original "Serbia" entry.

-   Step 2b) where a data set already uses the cow system, I'll first add the un m49 and iso3 ccodes based on the cow ccode. Any entry for "Yugoslavia" in the cow original data set will generate an NA entry in the un m49 and iso3 columns. These NA entries in the iso & m49 columns will be converted to "Serbia" (SRB, 688).

This operation will henceforth be applied in all the remaining data sets


This solution is not perfect, since Yugoslavia include both Montenegro and Serbia between 1992-2003. But this is the best we can do to harmonize the country code system across all data sets in this investigation.



#### country code harmonisation

##### Micronesia, Yemen, Czechoslovakia

iat data, the original country designation is coded in english names, in vbl supplier & recipient
```{r}
# iat.pcw <- iat.pcw2
## micronesia
iat.pcw <- iat.pcw %>% 
  dplyr::mutate(supplier = ifelse(supplier == "Micronesia", "Micronesia (Federated States of)", supplier),
         recipient = ifelse(recipient == "Micronesia", "Micronesia (Federated States of)", recipient))

## no pb with Yemen
## no pb with Czechoslovakia
```

Reassign country codes after having taken care of Micronesia, Yemen, and Czechoslovakia
```{r}
# cowen
iat.pcw$cowen1 <- countrycode(iat.pcw$supplier, origin = 'country.name', destination = 'cow.name') # nm: Aruba, Serbia
iat.pcw$cowen2 <- countrycode(iat.pcw$recipient, origin = 'country.name', destination = 'cow.name') # nm: Palestine, Serbia, Western Sahara
```



##### recode Serbia/Yugoslavia in COW system

Take care of Serbia/Yugoslavia pb in COW ccode
```{r}
## Serbia/Yugoslavia
iat.pcw <- iat.pcw %>%
  dplyr::mutate(cowen1 = if_else(supplier == "Serbia", "Yugoslavia", cowen1),
         cowen2 = if_else(recipient == "Serbia", "Yugoslavia", cowen2))

```

Add COW numeric and character codes
```{r}
# cown
iat.pcw$cown1 <- countrycode(iat.pcw$cowen1, origin = 'country.name', destination = 'cown')
iat.pcw$cown2 <- countrycode(iat.pcw$cowen2, origin = 'country.name', destination = 'cown')
 
# cowc
iat.pcw$cowc1 <- countrycode(iat.pcw$cowen1, origin = 'country.name', destination = 'cowc')
iat.pcw$cowc2 <- countrycode(iat.pcw$cowen2, origin = 'country.name', destination = 'cowc')
```


##### add other codes
```{r}
# iso 3
iat.pcw$iso1 <- countrycode(iat.pcw$supplier, origin = 'country.name', destination = 'iso3c') 
iat.pcw$iso2 <- countrycode(iat.pcw$recipient, origin = 'country.name', destination = 'iso3c') # nm: Kosovo
```

```{r}
# un m49
iat.pcw$un1 <- countrycode(iat.pcw$supplier, origin = 'country.name', destination = 'un') # nm: Taiwan
iat.pcw$un2 <- countrycode(iat.pcw$recipient, origin = 'country.name', destination = 'un') # nm: Kosovo, Taiwan
```

--> no more problems with Micronesia. Taiwan and Kosovo remains unrecognized in UN/ISO system, as they are not one of the 193 UN members.


##### add own country designation system (based on un m49 codes)
```{r}
iat.pcw$state1h <- countrycode(iat.pcw$un1, origin = 'un', destination = 'country.name') 
iat.pcw$state2h <- countrycode(iat.pcw$un2, origin = 'un', destination = 'country.name') 

# add my own dyad code system
iat.pcw <- iat.pcw %>%     # create an ID variable for each dyad combination
  dplyr::mutate(dyad_name = paste(state1h, state2h, sep = "_"))
```



#### exclude states with NA in countrycodes

We'll delete observations with NAs in the cow and in the iso alpha 3/m49 columns. NAs in either of these ccode systems mean the entity is not a formal member of the international system starting 1993, either because they no longer exist, are politically contested territories, united with another entity to form a new state, or are not recognized as an independent state for some other reason.

These are usually e.g. 
Palestine (PSE), Hong Kong (HKG), Taiwan (TWN), Kosovo (KOS), Macau (MAC), Aruba (ABW), and West Sahara (ESH). Palestine, Hongkong, and Macao exist in the un m49 system because of observer or associated member status, but they are not in the cow system because of contested status as a sovereign state/territory. Taiwan, on the other hand, is not part of the UN m49 because it lost its seat in 1971, but remains in the cow ccode system.


```{r}
colSums(is.na(iat.pcw))
```

```{r}
iat.pcw %>% 
  dplyr::filter(is.na(un1))
iat.pcw %>% 
  dplyr::filter(is.na(un2))
# Taiwan and Kosovo not recognized in UN system
```

```{r}
iat.pcw %>% 
  dplyr::filter(is.na(cowen1))
iat.pcw %>% 
  dplyr::filter(is.na(cowen2))
# Aruba, Palestine, Western Sahara
```

```{r}
iat.pcw %>% 
  dplyr::filter(is.na(state1h))
iat.pcw %>% 
  dplyr::filter(is.na(state2h))
# Kosovo
```

DELETE CASES
```{r}
iat.pcw <- iat.pcw %>% 
  # delete iso alpha 3 & un m49 NA cases 
  dplyr::filter(!is.na(cown1) & !is.na(un1)) %>% 
  dplyr::filter(!is.na(cown2) & !is.na(un2)) 
  # %>% 
  # delete info for contested territories
  # dplyr::filter(iso1 != "HKG" & iso1 != "PSE" & iso1 != "TWN" & iso1 != "ESH" & iso1 != "MAC") %>%
  # dplyr::filter(iso2 != "HKG" & iso2 != "PSE" & iso2 != "TWN" & iso2 != "ESH" & iso2 != "MAC")

# check for duplicates
iat.pcw[duplicated(iat.pcw),] 
# iat[duplicated(iat) | duplicated(iat, fromLast = TRUE),]
colSums(is.na(iat.pcw))
```

@nga: N reduced from ca. 11110 to ca. 11030 (ca. 80 cases)


### labels
```{r}
# add vbl labels
# library(Hmisc)
label(iat.pcw$state1h) <- "state 1 name based on un m49"
label(iat.pcw$state2h) <- "state 2 name based on un m49"
label(iat.pcw$iso1) <- "exporter iso alpha 3"
label(iat.pcw$iso2) <- "importer iso alpha 3"
label(iat.pcw$un1) <- "exporter un m49 number"
label(iat.pcw$un2) <- "importer un m49 number"

label(iat.pcw$cowen1) <- "exporter COW name"
label(iat.pcw$cowen2) <- "importer COW name"
label(iat.pcw$cown1) <- "exporter COW number"
label(iat.pcw$cown2) <- "importer COW number"
label(iat.pcw$cowc1) <- "exporter COW character"
label(iat.pcw$cowc2) <- "importer COW character"

label(iat.pcw$dyad_name) <- "my own ID system of arms transfering dyad"
```

### factorize
```{r}
# factorise
# colnames(iat.pcw)
# iat.pcw$supplier <- as.factor(iat.pcw$supplier)
# iat.pcw$recipient <- as.factor(iat.pcw$recipient) 
# iat.pcw$state1h <- as.factor(iat.pcw$state1h)
# iat.pcw$state2h <- as.factor(iat.pcw$state2h)
# iat.pcw$geopol_ord <- as.factor(iat.pcw$geopol_ord) 
# iat.pcw$decade_ord <- as.factor(iat.pcw$decade_ord) 
# iat.pcw$geopol_del <- as.factor(iat.pcw$geopol_del) 
# iat.pcw$decade_del <- as.factor(iat.pcw$decade_del) 
# iat.pcw$geopol_del1 <- as.factor(iat.pcw$geopol_del1) 
# iat.pcw$decade_del1 <- as.factor(iat.pcw$decade_del1) 
```

```{r}
# organize
iat.pcw <- iat.pcw %>% 
  dplyr::select(-c(supplier,recipient)) %>%
  dplyr::select(state1h, state2h, tiv, year, everything()) %>% 
  dplyr::arrange(year, state1h, state2h)

# check
head(iat.pcw) %>% 
  kbl() %>% 
  kable_classic()
```



### descriptive stats

@nga: descriptive

```{r}
# How many arms transfers do each unique dyad have in total between 1993-2023?
iat.pcw %>%  
  group_by(dyad_name) %>% 
  dplyr::summarise(n = n())
```
@nga: 2081 dyads traded arms between 1993-2023. The dyad names here are directed, from supplier to recipient (exporter-importer), so there would be many more dyads if the data was undirected

```{r}
# library(kableExtra)
# How many arm transfers do each unique dyad have, broken down by t spell?
iat.pcw %>% 
  group_by(t, dyad_name) %>% 
  dplyr::summarise(n = n()) %>% 
  kbl() %>% 
  kable_classic()
```
@nga: the dyad names here are directed, from supplier to recipient (exporter-importer), so there are way many more dyads than in the alliance or conflict dyadic data (undirected relations)


```{r}
# How many arm transfers do each unique dyad have during the period 2017-2023 (t6)?
iat.pcw %>% 
  dplyr::filter(t == "t6") %>% 
  group_by(dyad_name) %>% 
  dplyr::summarise(n = n())
```

```{r}
# How many UN members in the arms transfer system between 1993-2023?
length(union(iat.pcw$state1h, iat.pcw$state2h)) # 179 in total
# unique(c(iat.pcw$state1h,iat.pcw$state2h))
```

```{r}
# check nas
colSums(is.na(iat.pcw))
```


### save 2
```{r}
# Save working file
# save(iat.pcw, file = "iat.pcw.RData") # as R data file
load("iat.pcw.RData")
```


<br>
<br>

## I.2) Direct alliance (ATOP)



Cite: Leeds, Brett Ashley, Jeffrey M. Ritter, Sara McLaughlin Mitchell, and Andrew G. Long. 2002. Alliance Treaty Obligations and Provisions, 1815-1944. International Interactions 28: 237-260.

ATOP data are available in six basic formats with six different units of analysis: the alliance, the alliance phase, the alliance member, the state-year, the dyad-year, and the directed dyad-year. All six formats and the variables included in each file are explained in detail in the ATOP codebook. In addition, we provide data for the same six units of analysis excluding nonaggression pacts (see page 14 of the ATOP codebook).

ATOP data set version 5.1,records alliances during 1815-2018, 
dyad-year data inc. non-agression pacts:
http://www.atopdata.org/
ATOP data only records existing alliances as entries, non-allied dyads are not recorded.



### import 

```{r}
# dyad-year data: alliances inc.non-agression pacts
atop <- read.csv("data/ATOP-alliance-foreign policy/ATOP 5.1/atop5_1dy.csv", sep=",", header = T, check.names = F)
```

### subset & rename
```{r}
atop <- atop %>%
  dplyr::rename(cown1 = mem1, cown2 = mem2, dyad_atop = dyad) %>% 
  dplyr::select(cown1, cown2, year, number, dyad_atop) %>%
  dplyr::arrange(year, cown1, cown2)
```


### subset 1993-2023

Subset post Cold War (1993-2023) data and add time spells
--> dissolution of USSR on 26.12.1991, and subsequent changes & independence declarations during 1992, so observation period starts with 1993
```{r}
# library(dplyr)
ally.pcw <- atop %>% 
  # subset post Cold War period 
  dplyr::filter(year >= 1993 & year <= 2023) %>%
  # create a variable t to assign time spell identifier
  dplyr::mutate(t = ifelse(year <= 1997, "t1",
                      ifelse(year <= 2002, "t2",
                           ifelse(year <= 2007, "t3",
                                  ifelse(year <= 2012, "t4",
                                         ifelse(year <= 2017, "t5",
                                                ifelse(year <= 2023, "t6"
                                                ))))))) %>%   
  # order rows
  dplyr::arrange(year, cown1, cown2)

# inspect
# range(ally.pcw$year) # ATOP 1993-2018, looks good
# head(ally.pcw)
# tail(ally.pcw)
```
@nga: 90206 alliances recorded between 1993-2023

```{r}
# check nas
colSums(is.na(ally.pcw))
```


### country codes harmonization

alliance data, the original country designation is coded in cow numeric, in vbl cown1 and cown2
```{r}
# countries in the atop dataset since 1993
c <- union(ally.pcw$cown1, ally.pcw$cown2) 
countrycode::guess_field(c, min_similarity=90) # which ccode most likely was applied in sipri dataset? --> best match = cown
rm(c)
```

```{r}
cow_list %>% dplyr::arrange(cown) %>% View() # overview COW codes
```

```{r}
# library(countrycode)
# ?codelist # country codes designations

# add harmonized country names by matching with existing cow country codes
ally.pcw$state1h <- countrycode(ally.pcw$cown1, origin = 'cown', destination = 'country.name')
ally.pcw$state2h <- countrycode(ally.pcw$cown2, origin = 'cown', destination = 'country.name')
```


#### check for usual obsolete polities (Czechoslovakia, Yugoslavia etc)
```{r}
ally.pcw %>%
  dplyr::filter(state1h == "Czechoslovakia" | state2h == "Czechoslovakia") # pb with Czecho
# ally.pcw %>% dplyr::filter(cown1 == "315" | cown2 == "315")

ally.pcw %>%
  dplyr::filter(state1h == "Yugoslavia" | state2h == "Yugoslavia") # pb with YUG
# ally.pcw %>% dplyr::filter(cown1 == "345" | cown2 == "345")

ally.pcw %>%
  dplyr::filter(state1h == "Yemen" | state2h == "Yemen") # no pb with Yemen, i.e. no North or South Yemen registered
```

#### remove Czecho
```{r}
## remove Czecho
ally.pcw <- ally.pcw %>%
  dplyr::filter(!(state1h == "Czechoslovakia" | state2h == "Czechoslovakia"))
```


#### recode Serbia/Yugoslavia in COW system

Take care of Serbia/Yugoslavia pb in COW ccode
```{r}
## change Serbia/Yugoslavia
ally.pcw <- ally.pcw %>%
  dplyr::mutate(state1h = if_else(state1h == "Yugoslavia", "Serbia", state1h),
         state2h = if_else(state2h == "Yugoslavia", "Serbia", state2h))

```


#### add other ccodes
```{r}
# cowc
ally.pcw$cowc1 <- countrycode(ally.pcw$cown1, origin = 'cown', destination = 'cowc')
ally.pcw$cowc2 <- countrycode(ally.pcw$cown2, origin = 'cown', destination = 'cowc')
```

```{r}
# cowen
ally.pcw$cowen1 <- countrycode(ally.pcw$cown1, origin = 'cown', destination = 'cow.name')
ally.pcw$cowen2 <- countrycode(ally.pcw$cown2, origin = 'cown', destination = 'cow.name')
```

```{r}
# iso 3
ally.pcw$iso1 <- countrycode(ally.pcw$state1h, origin = 'country.name', destination = 'iso3c') 
ally.pcw$iso2 <- countrycode(ally.pcw$state2h, origin = 'country.name', destination = 'iso3c')
```

```{r}
# un m49
ally.pcw$un1 <- countrycode(ally.pcw$state1h, origin = 'country.name', destination = 'un')
ally.pcw$un2 <- countrycode(ally.pcw$state2h, origin = 'country.name', destination = 'un')
```


#### add own country designation system

```{r}
ally.pcw$state1h <- countrycode(ally.pcw$un1, origin = 'un', destination = 'country.name')

ally.pcw$state2h <- countrycode(ally.pcw$un2, origin = 'un', destination = 'country.name') 

# add my own dyad code system
ally.pcw <- ally.pcw %>%     # create an ID variable for each dyad combination
  dplyr::mutate(dyad_name = paste(state1h, state2h, sep = "_"))
```



### exclude states with NA in countrycodes

We'll delete observations with NAs in the cow and in the iso alpha 3/m49 columns. NAs in either of these ccode systems mean the entity is not a formal member of the international system starting 1993, either because they no longer exist, are politically contested territories, united with another entity to form a new state, or are not recognized as an independent state for some other reason.

These are usually e.g. 
Palestine (PSE), Hong Kong (HKG), Taiwan (TWN), Kosovo (KOS), Macau (MAC), Aruba (ABW), and West Sahara (ESH). Palestine, Hongkong, and Macao exist in the un m49 system because of observer or associated member status, but they are not in the cow system because of contested status as a sovereign state/territory. Taiwan, on the other hand, is not part of the UN m49 because it lost its seat in 1971, but remains in the cow ccode system.

```{r}
colSums(is.na(ally.pcw))
```

```{r}
ally.pcw <- ally.pcw %>% 
  # delete iso alpha 3 & un m49 NA cases 
  dplyr::filter(!is.na(cown1) & !is.na(un1)) %>% 
  dplyr::filter(!is.na(cown2) & !is.na(un2)) 
# %>% 
# delete info for contested territories
# dplyr::filter(iso1 != "HKG" & iso1 != "PSE" & iso1 != "TWN" & iso1 != "ESH" & iso1 != "MAC") %>%
# dplyr::filter(iso2 != "HKG" & iso2 != "PSE" & iso2 != "TWN" & iso2 != "ESH" & iso2 != "MAC")

# check for duplicates
ally.pcw[duplicated(ally.pcw),] 
# ally[duplicated(ally) | duplicated(ally, fromLast = TRUE),]
# colSums(is.na(ally.pcw))
```


### labels
```{r}
# add vbl labels
# library(Hmisc)
label(ally.pcw$state1h) <- "state 1 name based on un m49"
label(ally.pcw$state2h) <- "state 2 name based on un m49"
label(ally.pcw$iso1) <- "exporter iso alpha 3"
label(ally.pcw$iso2) <- "importer iso alpha 3"
label(ally.pcw$un1) <- "exporter un m49 number"
label(ally.pcw$un2) <- "importer un m49 number"

label(ally.pcw$cowen1) <- "exporter COW name"
label(ally.pcw$cowen2) <- "importer COW name"
label(ally.pcw$cown1) <- "exporter COW number"
label(ally.pcw$cown2) <- "importer COW number"
label(ally.pcw$cowc1) <- "exporter COW character"
label(ally.pcw$cowc2) <- "importer COW character"

label(ally.pcw$dyad_name) <- "my own ID system of arms transfering dyad"

label(ally.pcw$number) <- "number of alliances (bilat & multilat) in effect"

# Hmisc::label(ally.pcw) # check result
```




### descriptive stats
```{r}
# How many alliance agreements do each unique dyad have in total between 1993-2023?
ally.pcw %>% 
  group_by(dyad_name) %>%
  dplyr::summarise(n = n())
```



```{r}
# How many alliance agreements do each unique dyad have, broken down by t spell?
ally.pcw %>% 
  group_by(t, dyad_name) %>% 
  dplyr::summarise(n = n())

# How many alliance agreements do each unique dyad have in t=5 (i.e. 2012-2016)
ally.pcw %>% 
  dplyr::filter(t == "t5") %>% 
  group_by(dyad_name) %>% 
  dplyr::summarise(n = n())

# How many countries in the alliance system between 1993-2023?
length(union(ally.pcw$state1h, ally.pcw$state2h)) # 186 in total
# unique(c(ally.pcw$state1h,ally.pcw$state2h))

# check nas
colSums(is.na(ally.pcw))
```
Note: the dyad names are directed, even though the network will be undirected later, i.e. it could well be that there are 4 German-France dyads and 5 France-German dyads, so there is a total of 9 alliance connections between these two countries. However, this does not matter, as dyads in either direction will be equal once transformed to a undirected network object.

### save
```{r}
# Save working file
# save(ally.pcw, file = "ally.pcw.RData") # as R data file
load("ally.pcw.RData")
```

```{r}
library(sjmisc)
ally.pcw %>% pull(number) %>% frq()
```


<br>
<br>










## I.3) Armed conflict (UCDP state dyad level)


UCDP/PRIO Armed Conflict Dataset 1946-2023, version 24.1

-   Harbom, Lotta, Erik Melander & Peter Wallensteen (2008) Dyadic Dimensions of Armed Conflict, 1946-2007. Journal of Peace Research 45(5): 697-710,
-   Davies, Shawn, Garoun Engström, Therese Pettersson & Magnus Öberg (2024). Organized violence 1989-2023, and the prevalence of organized crime groups. Journal of Peace Research 61(4).

-   Pettersson, Therese (2023) UCDP Dyadic Dataset Codebook v 23.1 (https://ucdp.uu.se/downloads/).


--> Unit of analysis: state-dyad-incidence 

### import

```{r}
# import dyadic conflict-year dataset
ucdp <- read.csv("data/UCDP Prio conflict engagement/conflict/dyadic/Dyadic_v24_1.csv", sep=",", header = T, check.names = F)
# names(ucdp)
```

```{r}
names(ucdp)
ucdp %>% dplyr::filter(year == 2023)
```


#### descriptive exploration
```{r}
## descriptive exploration
# Iran vs Israel
names(ucdp)
ucdp %>% 
  dplyr::filter(conflict_id == 14609) %>% 
  View()
  # pull(side_a_2nd)
```

```{r}
## count how many secondary parties were involved in the conflict
# ucdp %>%
#   dplyr::filter(conflict_id == 14609) %>%
#   pull(side_b_2nd) %>%
#   strsplit(",") %>% 
#   unlist() %>%
#   trimws() %>%
#   table() %>%
#   as.data.frame()
```

```{r}
# How many conflicts did the dyads have with one another since start of first conflict?
ucdp %>% 
  dplyr::filter(type_of_conflict == 2) %>% 
  group_by(dyad_id, side_a, side_b) %>%
  dplyr::summarise(year = first(year), 
            n_conflicts = n()) %>% 
  View()
# --> e.g. India & Pakistan had 27 conflicts since start of hostilities in 1948, Israel & Iran had 5 violent episodes sinc 2018
```



#### subset
```{r}
# subset only conflicts involving at least one state on each opposing side
ucdp_2states <- ucdp %>%
  
  # for character vbls: Replace blanks with NA
  mutate_if(is.character, list(~na_if(., ""))) %>%
  
  # subset for type_of_conflict == 2 (interstate conflicts) AND type_of_conflict == 4 (internationalized intrastate conflicts). 
  dplyr::filter(type_of_conflict == 2 | type_of_conflict == 4) %>%
  
  # Out of the internationalized intrastate conflicts (type 4), only retain those that have at least one side_b_2nd actor coded (i.e. at least one foreign state actor backing side_b rebels against side_a state government) 
  dplyr::filter(!(type_of_conflict == 4 & is.na(side_b_2nd))) %>% 
  
  # for all observations where type_of_conflict == 4 (intern. intrastate conflicts), replace the values of side_b with NA (since those are rebels). For  type_of_conflict == 2 (interstate conflicts) observations, retain their original side_b values since those are states). Retain all side_a, side_a_2nd, side_b_2nd values for all types of conflicts, since they always record states actors.
  dplyr::mutate(side_b = ifelse(type_of_conflict == 4, NA, side_b))
  
## retain relevant variables
# names(ucdp_2states)
ucdp_2states <- ucdp_2states %>% 
  dplyr::select(1:4,6:7,9:14) 
```

```{r}
## aggregate to dyad-year level
# View(ucdp_2states)
ucdp_2states %>% 
  dplyr::filter(location == "Ukraine") %>% 
  dplyr::arrange(year) %>% 
  View()
```



check
```{r}
## interstate conflicts 
# example: conflict_id 293 (Vietnam war) in 1970
ucdp_2states %>% 
  dplyr::filter(conflict_id == 293 & year == 1970) %>% 
  View()

# all interstate conflicts
ucdp_2states %>% 
  dplyr::filter(type_of_conflict == 2) %>%
  View() # Total of 141 interstate conflicts
```

```{r}
## internationalized interstate conflicts
# example: conflict_id 300 (Cambodian-Vietnamese war) in 1970
ucdp_2states %>% 
  dplyr::filter(conflict_id == 300 & year == 1970) %>% 
  View() # --> we see the side_b value, initally "KR" (for Khmer Rouge), has been replaced by NA

# all intras. confl.
ucdp_2states %>% 
  dplyr::filter(type_of_conflict == 4) %>% 
  View() # Total of 126 internationalized intrastate conflicts (side_b values (rebels) were replaced with NA. Side_a, side_a_2nd and side_b_2nd are always states' governments involved in the conflict.)
```


```{r}
ucdp_2states %>% dplyr::filter(year == 2023)
```


##### save 1
```{r}
# Save working file
# save(ucdp_2states, file = "ucdp_2states.RData") # as R data file
# load("ucdp_2states.RData") 
# names(ucdp_2states)
```





#### wide format

Split comma-separated main (side_a & side_b) and 2nd-parties (side_a_2nd & side_b_2nd) into separate columns.

Usually the main conflict parties (variables side_a and side_b) only consist of one actor while the variables side_a_2nd and side_b_2nd record the remaining allies on either side. However, there are 3 exceptions where more than one state were recorded as being a main conflict party:
-   Conflict ID 228: 1948-1949 Palestine War involving several countries of Arab League coalition vs Israel
-   Conflict ID 420: 2003 Iraq war involving UK+US+Australia coalition vs Iraq

```{r}
ucdp %>% 
  dplyr::filter(conflict_id == 228 | conflict_id == 420) %>% 
  View() 
```


Because of these two cases, we need to specify a function that splits not only comma-separated values in the side_a_2nd & side_b_2nd columns, but also in the side_a and side_b columns.

--> wide data frame:
This function takes as input a data frame containing the UCDP dyadic armed conflict dataset and splits the comma-separated string values in side_a, side_b, side_a_2nd and side_b_2nd into separate columns and renaming them to add a numeric identifier. 
```{r}
# save(spl_data, file = "spl_data.RData") # as R data file
load("spl_data.RData") 
```

```{r}
# Function to split comma-separated string values for main and secondary parties involved in side_a or side_b

# spl_data <- function(data, a = "", b = "", a2 = "", b2 = "") {
#   # load packages
#   library(tidyr)
#   library(stringr)
# 
#   # Split the side_a and side_b columns into separate columns
#   data <- data %>%
#     # create new columns to store splitted parties
#     dplyr::mutate(
#       !!a := str_split(!!sym(a), ","),
#       !!b := str_split(!!sym(b), ","),
#       !!a2 := str_split(!!sym(a2), ","),
#       !!b2 := str_split(!!sym(b2), ",")
#    ) %>%
#     # turn each element of a list-column into a column
#     unnest_wider(!!sym(a), names_sep = "") %>%
#     unnest_wider(!!sym(b), names_sep = "") %>%
#     unnest_wider(!!sym(a2), names_sep = "") %>%
#     unnest_wider(!!sym(b2), names_sep = "") %>%
#     # column names for parties on side a and b to start with "a" & "b"
#     rename_with(
#       .fn = ~ str_replace(.x, a, "side_a"),
#       .cols = starts_with(a)
#    ) %>%
#     rename_with(
#       .fn = ~ str_replace(.x, b, "side_b"),
#       .cols = starts_with(b)
#    )
# 
#   return(data)
# }
```




```{r}
# apply function 2 to conflict dataset
ucdp_2states.wide <- spl_data(ucdp_2states, a = "side_a", b= "side_b", a2 = "side_a_2nd", b2 = "side_b_2nd")
```

```{r}
# names(ucdp_2states.wide) 
# it seems there were some larger conflicts with up to 11 secondary parties involved on side a and 30 secondary parties involved on side b (e.g. variable side_b_2nd30 records side_b's 30th secondary party)

# Check, whether the split-to-wide function worked correctly, using examples of conflict_id 293 (Vietnam war) and conflict_id 300 (Cambodian-Vietnamese war)

# Compare before...
ucdp_2states %>% 
  dplyr::filter(conflict_id == 293 | conflict_id == 300) %>%
  dplyr::filter(year == 1970) %>% 
  View()
# ...and after
ucdp_2states.wide %>%
  dplyr::filter(conflict_id == 293 | conflict_id == 300) %>%
  dplyr::filter(year == 1970) %>% 
  View()
```


```{r}
ucdp_2states.wide %>% 
  dplyr::filter(type_of_conflict == 4) %>% # | type_of_conflict == 4) %>%
  View()
```

```{r}
ucdp_2states %>% sjmisc::frq(incompatibility) # 1 = territory = 60%, 2 = political = 33%, 3 = both = 7%
```

```{r}
names(ucdp_2states.wide)
ucdp_2states.wide %>% frq(year)
hist(ucdp_2states.wide$year, 80)
```



##### save 2
```{r}
# Save working file
# save(ucdp_2states.wide, file = "ucdp_2states.wide.RData") # as R data file
# load("ucdp_2states.wide.RData")

```


#### long format

Pivot from wide to long based on unique conflict-dyad combinations 

--> long data frame:
This function takes as input a data frame in wide format and two additional arguments specifying the names of the columns in the wider data frame that correspond to the primary conflict parties. The function applies the transformation described in your previous message by gathering all columns starting with a and b into two separate columns named side a and side b, respectively. The resulting data frame is then filtered to remove rows with missing values in these two columns. A new column named main is created to store the value 1 if both of the two conflict parties of an observation are the primary conflict parties specified by the main_side_a_col and main_side_b_col arguments, and 0 otherwise. The transformed data frame is then returned as the output of the function.
```{r}
# save(piv_data, file = "piv_data.RData") # as R data file
load("piv_data.RData") 
```

```{r}
# Function to turn all unique dyad combinations of side_a and side_b involved in the same conflict into separate state-dyad-year observations

# piv_data <- function(data) {
#     # load packages
#     library(tidyr)
#     library(dplyr)
# 
#     # Gather all columns starting with "side_a" and "side_b" into two separate columns
#     data <- data %>%
#       pivot_longer(
#         cols = starts_with("side_a"),
#         names_to = "a_key",
#         values_to = "side_a"
#      ) %>%
#       pivot_longer(
#         cols = starts_with("side_b"),
#         names_to = "b_key",
#         values_to = "side_b"
#      ) %>%
#       # Filter out rows with missing values in side_a or side_b
#       dplyr::select(-a_key, -b_key) %>%
#       dplyr::filter(!is.na(side_a) & !is.na(side_b))
# 
#     return(data)
#   }
```



```{r}
# apply function to wide conflict df
ucdp_2states.long <- piv_data(ucdp_2states.wide)

# check
nrow(ucdp_2states.long)
nrow(ucdp_2states.wide)

ncol(ucdp_2states.long)
ncol(ucdp_2states.wide)
```

Check
```{r}
# Check, whether the pivot to lonf function worked correctly, using examples of conflict_id 293 (Vietnam war) and conflict_id 300 (Cambodian-Vietnamese war)

# Compare before...
ucdp_2states.wide %>% 
  dplyr::filter(conflict_id == 293 | conflict_id == 300) %>%
  dplyr::filter(year == 1970) %>% 
  View()
# ...and after
ucdp_2states.long %>%
  dplyr::filter(conflict_id == 293 | conflict_id == 300) %>%
  dplyr::filter(year == 1970) %>% 
  View()
```

```{r}
ucdp_2states.long %>% sjmisc::frq(incompatibility) # 1 = territory = 63%, 2 = political = 34%, 3 = both = 3%
range(ucdp_2states.long$year) # 1946-2023

```


##### save 3
```{r}
# Save working file
# save(ucdp_2states.long, file = "ucdp_2states.long.RData") # as R data file
# load("ucdp_2states.long.RData") 
# names(ucdp_2states.long)
```




#### string cleaning

Some more cleaning
```{r}
conflict_dyad <- ucdp_2states.long # make a copy

# get rid of the "Government of" part in strings of states' names
conflict_dyad[c("side_a", "side_b")] <- lapply(
  conflict_dyad[c("side_a", "side_b")], 
  function(x) 
    gsub(" Government of |Government of ", "", x))

# remove old versions from environment
rm(ucdp_2states)
rm(ucdp_2states.wide)
rm(ucdp_2states.long)
```

```{r}
# compare before...
head(ucdp_2states.long[,c(8:9,4,2)], 10) %>% 
  kbl() %>%
  kable_classic()
# ...and after
head(conflict_dyad[,c(8:9,4,2)], 10) %>% 
  kbl() %>%
  kable_classic()
```

```{r}
conflict_dyad %>% sjmisc::frq(incompatibility) # 1 = territory = 63%, 2 = political = 34%, 3 = both = 3%
```

##### save 4
```{r}
# save(conflict_dyad, file = "conflict_dyad.RData") # as R data file
# load("conflict_dyad.RData") 
# names(conflict_dyad)
```


### subset 1993-2023

Subset post Cold War (1993-2023) data and add time spells
--> dissolution of USSR on 26.12.1991, and subsequent changes & independence declarations during 1992, so observation period starts with 1993
```{r}
# names(conflict_dyad)
# library(dplyr)
conflict_dyad.pcw <- conflict_dyad %>% 
  # subset post Cold War period 
  dplyr::filter(year >= 1993 & year <= 2023) %>%
  # create a variable t to assign time spell identifier
  dplyr::mutate(t = ifelse(year <= 1997, "t1",
                      ifelse(year <= 2002, "t2",
                           ifelse(year <= 2007, "t3",
                                  ifelse(year <= 2012, "t4",
                                         ifelse(year <= 2017, "t5",
                                                ifelse(year <= 2023, "t6"
                                                ))))))) %>% 
  # select dyadic attributes to keep in network
  dplyr::select(side_a, side_b, year, t, everything()) %>%
  # order rows
  dplyr::arrange(year, side_a, side_b)
```




### country codes harmonization


conflict data, the original country designation is coded in cow name, in vbl side_a and side_b. However, cow name is not available as the origin ccode in the countrycode package. So we'll use country.name code instead as origin.
```{r}
# names(conflict_dyad.pcw)
d <- union(conflict_dyad.pcw$side_a, conflict_dyad.pcw$side_b)
countrycode::guess_field(d, min_similarity=85) # which ccode most likely was applied in sipri dataset? --> best match = cow.name. but the origin argument in countrycode() function does not accept cown.name, so we use eng country name
rm(d)
```


#### check for usual obsolete polities (Czechoslovakia, Yugoslavia etc)
```{r}
# View(conflict_dyad.pcw)
# use search to look for Czechoslovakia, Yemen, and Yugoslavia
```
-> no pb with Czecho, but with Yemen called North Yemen, and with Serbia/Yugoslavia.
North Yemen = united with South Yemen to form Yemen in 1990.

Other problematic designations:
-   Russia (Soviet Union)
-   DR Congo (Zaire)
-   Yemen (North Yemen)
-   Serbia (Yugoslavia)
-   Zimbabwe (Rhodesia)
-   Cambodia (Kampuchea)



#### recode problematic/obsolete state designations

Yemen (North Yemen)
```{r}
conflict_dyad.pcw <- conflict_dyad.pcw %>% 
  dplyr::mutate(side_a = if_else(side_a == "Yemen (North Yemen)", "Yemen", side_a),
         side_b = if_else(side_b == "Yemen (North Yemen)", "Yemen", side_b))

conflict_dyad.pcw <- conflict_dyad.pcw %>% 
  dplyr::mutate(location = if_else(location == "Yemen (North Yemen)", "Yemen", location))
```

Russia (Soviet Union)
```{r}
conflict_dyad.pcw <- conflict_dyad.pcw %>% 
  dplyr::mutate(side_a = if_else(side_a == "Russia (Soviet Union)", "Russia", side_a),
         side_b = if_else(side_b == "Russia (Soviet Union)", "Russia", side_b))

conflict_dyad.pcw <- conflict_dyad.pcw %>% 
  dplyr::mutate(location = if_else(location == "Russia (Soviet Union)", "Russia", location))
```

DR Congo (Zaire)
```{r}
conflict_dyad.pcw <- conflict_dyad.pcw %>% 
  dplyr::mutate(side_a = if_else(side_a == "DR Congo (Zaire)", "Congo-Kinshasa", side_a),
         side_b = if_else(side_b == "DR Congo (Zaire)", "Congo-Kinshasa", side_b))

conflict_dyad.pcw <- conflict_dyad.pcw %>% 
  dplyr::mutate(location = if_else(location == "DR Congo (Zaire)", "Congo-Kinshasa", location))
```

Zimbabwe (Rhodesia)
```{r}
conflict_dyad.pcw <- conflict_dyad.pcw %>% 
  dplyr::mutate(side_a = if_else(side_a == "Zimbabwe (Rhodesia)", "Zimbabwe", side_a),
         side_b = if_else(side_b == "Zimbabwe (Rhodesia)", "Zimbabwe", side_b))

conflict_dyad.pcw <- conflict_dyad.pcw %>% 
  dplyr::mutate(location = if_else(location == "Zimbabwe (Rhodesia)", "Zimbabwe", location))
```

Cambodia (Kampuchea)
```{r}
conflict_dyad.pcw <- conflict_dyad.pcw %>% 
  dplyr::mutate(side_a = if_else(side_a == "Cambodia (Kampuchea)", "Cambodia", side_a),
         side_b = if_else(side_b == "Cambodia (Kampuchea)", "Cambodia", side_b))

conflict_dyad.pcw <- conflict_dyad.pcw %>% 
  dplyr::mutate(location = if_else(location == "Cambodia (Kampuchea)", "Cambodia", location))
```

Serbia/Yugoslavia
```{r}
## change Serbia/Yugoslavia name
conflict_dyad.pcw <- conflict_dyad.pcw %>% 
  dplyr::mutate(side_a = if_else(side_a == "Serbia (Yugoslavia)", "Serbia", side_a),
         side_b = if_else(side_b == "Serbia (Yugoslavia)", "Serbia", side_b))

conflict_dyad.pcw <- conflict_dyad.pcw %>% 
  dplyr::mutate(location = if_else(location == "Serbia (Yugoslavia)", "Serbia", location))
```


#### add ccodes

##### cow.name code
```{r}
# cowen
conflict_dyad.pcw$cowen1 <- countrycode(conflict_dyad.pcw$side_a, origin = 'country.name', destination = 'cow.name')
conflict_dyad.pcw$cowen2 <- countrycode(conflict_dyad.pcw$side_b, origin = 'country.name', destination = 'cow.name')
```

```{r}
## change Serbia/Yugoslavia in COW
conflict_dyad.pcw <- conflict_dyad.pcw %>% 
  dplyr::mutate(cowen1 = if_else(side_a == "Serbia", "Yugoslavia", cowen1),
         cowen2 = if_else(side_b == "Serbia", "Yugoslavia", cowen2))
```


##### other ccodes
```{r}
# library(countrycode)
# ?codelist # country codes designations

# cow number
conflict_dyad.pcw$cown1 <- countrycode(conflict_dyad.pcw$cowen1, origin = 'country.name', destination = 'cown')
conflict_dyad.pcw$cown2 <- countrycode(conflict_dyad.pcw$cowen2, origin = 'country.name', destination = 'cown')

# cow character
conflict_dyad.pcw$cowc1 <- countrycode(conflict_dyad.pcw$cowen1, origin = 'country.name', destination = 'cowc')
conflict_dyad.pcw$cowc2 <- countrycode(conflict_dyad.pcw$cowen2, origin = 'country.name', destination = 'cowc')

# iso 3
conflict_dyad.pcw$iso1 <- countrycode(conflict_dyad.pcw$side_a, origin = 'country.name', destination = 'iso3c')
conflict_dyad.pcw$iso2 <- countrycode(conflict_dyad.pcw$side_b, origin = 'country.name', destination = 'iso3c')

# un m49
conflict_dyad.pcw$un1 <- countrycode(conflict_dyad.pcw$side_a, origin = 'country.name', destination = 'un')
conflict_dyad.pcw$un2 <- countrycode(conflict_dyad.pcw$side_b, origin = 'country.name', destination = 'un')

```


#### add own country designation system

```{r}
conflict_dyad.pcw$state1h <- countrycode(conflict_dyad.pcw$un1, origin = 'un', destination = 'country.name')

conflict_dyad.pcw$state2h <- countrycode(conflict_dyad.pcw$un2, origin = 'un', destination = 'country.name') 

# add my own dyad code system
conflict_dyad.pcw <- conflict_dyad.pcw %>%     # create an ID variable for each dyad combination
  dplyr::mutate(dyad_name = paste(state1h, state2h, sep = "_"))
```

```{r}
# delete original vbls
conflict_dyad.pcw <- conflict_dyad.pcw %>% 
  # dplyr::mutate(state1 = side_a, 
  #        state2 = side_b) %>% 
  dplyr::select(-c(side_a,side_b)) %>%
  dplyr::select(state1h, state2h, year, t, everything())
```



#### reorder countries' order in dyad alphabetically (only for undirected ties)

```{r}
# before ordering, there are cases where Ukraine is state 1 and Russia is state 2. We'll change that.
conflict_dyad.pcw %>% 
  dplyr::filter(state1h == "Russia") %>%  View()
```

```{r}
# Create a new variable dyad_name that combines state1h and state2h in alphabetical order
conflict_dyad.pcw$dyad_name <- apply(conflict_dyad.pcw[,c("state1h", "state2h")], 1, function(x) paste(sort(x), collapse = "_"))

# Find the rows where state1h is not alphabetically prior to state2h
rows_to_switch <- conflict_dyad.pcw$state1h > conflict_dyad.pcw$state2h

# Switch the values in those rows
conflict_dyad.pcw$state1h <- unclass(conflict_dyad.pcw$state1h)
conflict_dyad.pcw$state2h <- unclass(conflict_dyad.pcw$state2h)
conflict_dyad.pcw[rows_to_switch, c("state1h", "state2h")] <- conflict_dyad.pcw[rows_to_switch, c("state2h", "state1h")]
rm(rows_to_switch)
```

```{r}
# After reordering, Russia is state 1 in all it's conflicts with Ukraine, since it comes before Ukraine in the alphabet
conflict_dyad.pcw %>% 
  dplyr::filter(state1h == "Russia") %>%  View()
```

@nga: ratio of territorial conflicts and political conflicts have switched between Cold-War and post-Cold War period. During the CW, ca 77% of all conflicts were due to territorial issues, and the rest are mostly political conflicts. In the pCW period, however, territorial conflicts only make up 34% of the sample, while political conflict are 65%.
```{r}
# total period: 1946-2023
conflict_dyad %>% sjmisc::frq(incompatibility) # 1 = territory = 64.5%, 2 = political = 34%, 3 = both = 2.5%

# CW
conflict_dyad %>% 
  dplyr::filter(year >= 1946 & year <= 1992) %>% 
  sjmisc::frq(incompatibility) # 1 = territory = 77%, 2 = political = 20%, 3 = both = 3%

# pCW
conflict_dyad %>% 
  dplyr::filter(year >= 1993) %>% 
  sjmisc::frq(incompatibility) # 1 = territory = 34%, 2 = political = 65%, 3 = both = 1%
```


### exclude states with NA in countrycodes cow + iso/un

We'll delete observations with NAs in the cow and in the iso alpha 3/m49 columns. NAs in either of these ccode systems mean the entity is not a formal member of the international system starting 1993, either because they no longer exist, are politically contested territories, united with another entity to form a new state, or are not recognized as an independent state for some other reason.

These are usually e.g. 
Palestine (PSE), Hong Kong (HKG), Taiwan (TWN), Kosovo (KOS), Macau (MAC), Aruba (ABW), and West Sahara (ESH). Palestine, Hongkong, and Macao exist in the un m49 system because of observer or associated member status, but they are not in the cow system because of contested status as a sovereign state/territory. Taiwan, on the other hand, is not part of the UN m49 because it lost its seat in 1971, but remains in the cow ccode system.

```{r}
colSums(is.na(conflict_dyad.pcw))
```

```{r}
conflict_dyad.pcw <- conflict_dyad.pcw %>% 
  # delete iso alpha 3 & un m49 NA cases 
  dplyr::filter(!is.na(cown1) & !is.na(un1)) %>% 
  dplyr::filter(!is.na(cown2) & !is.na(un2)) 
# %>% 
# delete info for contested territories
# dplyr::filter(iso1 != "HKG" & iso1 != "PSE" & iso1 != "TWN" & iso1 != "ESH" & iso1 != "MAC") %>%
# dplyr::filter(iso2 != "HKG" & iso2 != "PSE" & iso2 != "TWN" & iso2 != "ESH" & iso2 != "MAC")

# check for duplicates
conflict_dyad.pcw[duplicated(conflict_dyad.pcw),] 
# conflict_dyad[duplicated(conflict_dyad) | duplicated(conflict_dyad, fromLast = TRUE),]
# colSums(is.na(conflict_dyad.pcw))
```


### recode

```{r}
# decriptives
# library(sjmisc)
# frq(conflict_dyad.pcw$intensity_level) # recode dummy
# frq(conflict_dyad.pcw$type_of_conflict) # recode dummy
# frq(conflict_dyad.pcw$incompatibility) # recode dummy
```


```{r}
# library(dplyr)
conflict_dyad.pcw <- conflict_dyad.pcw %>% 
  dplyr::mutate(intensity = ifelse(intensity_level == 1,0,1)) %>% 
  dplyr::mutate(intensity = haven::labelled(intensity, 
                                     c("war" = 1,
                                       "minor" = 0),
                                     label = "minor conflict or war (>1000 deaths)? war = 1, minor = 0")) %>% 
  dplyr::mutate(type_of_conflict = ifelse(type_of_conflict == 2,1,0)) %>% 
  dplyr::mutate(type_of_conflict = haven::labelled(type_of_conflict, 
                                            c("interstate conflict" = 1,
                                              "intrastate conflict with foreign intervention" = 0),
                                            label = "interstate conflict or intrastate conflict with foreign intervention? inter = 1, intra = 0")) %>% 
  dplyr::mutate(incompatibility = ifelse(incompatibility == 1,1,0)) %>% 
  dplyr::mutate(incompatibility = haven::labelled(incompatibility, 
                                           c("territory conflict" = 1,
                                             "political conflict (inc. mixed with territorial issues)" = 0),
                                           label = "conflict due to? territory = 1, political (inc. pol + ter) = 0")) %>% 
  dplyr::select(-intensity_level) %>% 
  dplyr::select(state1h, state2h, year, everything())%>% 
  dplyr::arrange(year, state1h, state2h)
```




### labels

```{r}
# add vbl labels
# library(Hmisc)

label(conflict_dyad.pcw$dyad_id) <- "UCDP ID for main conflict dyad"
label(conflict_dyad.pcw$conflict_id) <- "UCDP ID for specific conflict"
label(conflict_dyad.pcw$location) <- "location of primary claim to the incompatibility"
label(conflict_dyad.pcw$dyad_name) <- "my own ID system for conflict dyad"


label(conflict_dyad.pcw$state1h) <- "state1 name based on un m49"
label(conflict_dyad.pcw$state2h) <- "state2 name based on un m49"
label(conflict_dyad.pcw$iso1) <- "state1 iso alpha 3"
label(conflict_dyad.pcw$iso2) <- "state2 iso alpha 3"
label(conflict_dyad.pcw$un1) <- "state1 un m49 number"
label(conflict_dyad.pcw$un2) <- "state2 un m49 number"

label(conflict_dyad.pcw$cowen1) <- "state1 COW name"
label(conflict_dyad.pcw$cowen2) <- "state2 COW name"
label(conflict_dyad.pcw$cown1) <- "state1 COW number"
label(conflict_dyad.pcw$cown2) <- "state2 COW number"
label(conflict_dyad.pcw$cowc1) <- "state1 COW character"
label(conflict_dyad.pcw$cowc2) <- "state2 COW character"


# check
# head(conflict_dyad.pcw) %>% 
#   kbl() %>% 
#   kable_classic()
```

### save 5
```{r}
# Save working file
# save(conflict_dyad.pcw, file = "conflict_dyad.pcw.RData") # as R data file
# load("conflict_dyad.pcw.RData") 
# names(conflict_dyad.pcw)
```



### descriptive stats

```{r}
# inspect
range(conflict_dyad.pcw$year) # looks good
# head(conflict_dyad.pcw)
# tail(conflict_dyad.pcw)
```

```{r}
# How many conflicts do each unique dyad have with each other, grouped by t spell?
# library(kableExtra)
conflict_dyad.pcw %>% 
  group_by(t, dyad_name) %>% 
  dplyr::summarise(n = n()) %>% 
  kbl() %>% 
  kable_classic()

# How many countries in the conflict system between 1993-2023?
length(union(conflict_dyad.pcw$state1h, conflict_dyad.pcw$state2h)) # 78 in total
```



### Problem: duplicate entries for some conflict dyads


#### Russia-Ukraine

##### analysis

After aggregating the data to time spell level, I notice an anomaly which will become a problem later. The variable n_years sums up the number of years a dyad spends fighting by time spell (i.e. t1-t6). Since one time spell only contains 5 years, any consecutive fighting period above 5 years does not make sense.
 
FOr instance, dyad Ukraine-Russia has 10 conflict years in t5 and 9 conflict years in t6. This should not be possible. These numbers means that these dyads have duplicate conflict entries for specific years.

```{r}
## aggregated
conflict_dyad.pcw %>%
  group_by(iso1, iso2, un1, un2, state1h, state2h, dyad_name, t) %>%
  dplyr::summarise(n_years = n()) %>% 
  dplyr::arrange(state1h, state2h, t) %>% 
  ungroup() %>% 
  dplyr::select(state1h, state2h, t, n_years) %>% 
  View()
```

The ucdp data should record conflicts on dyad-year level. However, in the case of Ukraine and Russia, we have 2-3 conflict observations for most years. For Congo-Kinshasa and Uganda in t2, we have the same problem of having 6 conflict years despite the fact that the t2 time spell only has 5 years.  
Russia-Ukraine have several dyad IDs and conflict IDs for a given year. (dyad IDs 14124, 14184, 14210, 15100, 15101 & conflict IDs 13246, 13247, 13247). This is contrary to the description in the UCDP codebook, which states that dyad IDs and conflict IDs are unique.

```{r}
# names(conflict_dyad.pcw)
conflict_dyad.pcw %>% 
  dplyr::filter(state1h == "Russia" & state2h == "Ukraine") %>% 
    # OLD CODE: dplyr::filter((state1h == "Ukraine" & state2h == "Russia") | state1h == "Russia" & state2h == "Ukraine") %>%
    # SINCE DYAD ORDER HAVE BEEN SORTED BY ALPHABETICAL ORDER; NO NEED TO CHECK FOR A COUNTRY AMONG BOTH STATE1H AND STATE2H. JUST MAKE SURE THE COUNTRY PRIOR IN THE ALPHABET IS NAMED IN STATE1H
  dplyr::select(state1h, state2h, year, t, dyad_id, conflict_id, intensity) %>% 
  View()
```
17 out of the 20 conflicts between Russia and Ukraine have the same conflict id = 13306, indicating that the duplicate entries for this dyad must be a mistake. I will therefore group and harmonize these conflict entries by year for this dyad. Out of the 5 dyad IDs, i.e. 14124, 14184, 14210, 15100, 15101, the number 15101 was used very consistently except for the year 2014 and 2023. So we use this dyad number to filter the Ukraine-Russia cases for 2015-2021. For year 2014 we use dyad number 14210 and for year 2023 we use dyad number will be used to retain one observation.

Note: the problem with dyad numbers also have to do with who is recorded as state 1 and as state 2. For 2023, we have dyad number 14117 (Russia-Ukraine) and 15100 (Ukraine-Russia). It is the same conflict, but conflict intensity is recorded differently for both cases, in the first one it's coded as a war and in the second one as a minor conflict. We'll need to harmonize this too. I assume this to be a war according to scholarly definition (deaths >1000)


##### delete duplicates

```{r}
# make a copy before applying changes to data by hand (in case needed later)
conflict_dyad.pcw2 <- conflict_dyad.pcw
```

```{r}
# library(dplyr)

# applying changes regarding Ukraine-Russia
conflict_dyad.pcw2 <- conflict_dyad.pcw2 %>%
  dplyr::filter(
    !(
      ((state1h == "Ukraine" & state2h == "Russia") | (state1h == "Russia" & state2h == "Ukraine")) &
      year %in% 2016:2021 &
      dyad_id != 15101
    )
  )

conflict_dyad.pcw2 <- conflict_dyad.pcw2 %>%
  dplyr::filter(
    !(
      ((state1h == "Ukraine" & state2h == "Russia") | (state1h == "Russia" & state2h == "Ukraine")) &
      year %in% 2014:2015 &
      dyad_id != 14210
    )
  )

conflict_dyad.pcw2 <- conflict_dyad.pcw2 %>%
  dplyr::filter(
    !(
      ((state1h == "Ukraine" & state2h == "Russia") | (state1h == "Russia" & state2h == "Ukraine")) &
      year %in% 2023 &
      dyad_id != 14117
    )
  )
```

```{r}
## check
conflict_dyad.pcw2 %>% 
  dplyr::filter((state1h == "Ukraine" & state2h == "Russia") | (state1h == "Russia" & state2h == "Ukraine")) %>% 
  dplyr::select(state1h, state2h, year, t, dyad_id, conflict_id, intensity) %>%
  View()
```





#### Other dyads with duplicate entries

##### analysis

Apart from Russia-Ukrain, I will manually check some dyads for duplicate country-year conflict entries. These are dyads that have 4 or more observed conflict entries within a time spell

```{r}
conflict_dyad.pcw2 %>% 
  dplyr::filter(state1h == "Congo - Kinshasa" & state2h == "Uganda") %>% 
  dplyr::select(state1h, state2h, year, t, dyad_id, conflict_id, intensity) %>% 
  View()
```
--> 1998 & 1999 duplicates = *585*

```{r}
conflict_dyad.pcw2 %>% 
  dplyr::filter(state1h == "Congo - Kinshasa" & state2h == "Rwanda") %>%
  dplyr::select(state1h, state2h, year, t, dyad_id, conflict_id, intensity) %>% 
  View()
```
--> ok

```{r}
conflict_dyad.pcw2 %>% 
  dplyr::filter(state1h == "Angola" & state2h == "Rwanda") %>%
  dplyr::select(state1h, state2h, year, t, dyad_id, conflict_id, intensity) %>% 
  View()
```
--> ok

```{r}
conflict_dyad.pcw2 %>% 
  dplyr::filter(state1h == "Angola" & state2h == "Uganda") %>%
  dplyr::select(state1h, state2h, year, t, dyad_id, conflict_id, intensity) %>% 
  View()
```
--> 1998 & 1999, duplicates = *585*


```{r}
conflict_dyad.pcw2 %>% 
  dplyr::filter(state1h == "Armenia" & state2h == "Azerbaijan") %>%
  dplyr::select(state1h, state2h, year, t, dyad_id, conflict_id, intensity) %>% 
  View()
```
--> ok

```{r}
conflict_dyad.pcw2 %>% 
  dplyr::filter(state1h == "Chad" & state2h == "Uganda") %>%
  dplyr::select(state1h, state2h, year, t, dyad_id, conflict_id, intensity) %>% 
  View()
```
--> 1998 & 1999 duplicates = *585*

```{r}
conflict_dyad.pcw2 %>% 
  dplyr::filter(state1h == "India" & state2h == "Pakistan") %>%
  dplyr::select(state1h, state2h, year, t, dyad_id, conflict_id, intensity) %>% 
  View()
```
--> ok

```{r}
conflict_dyad.pcw2 %>% 
  dplyr::filter(state1h == "Iran" & state2h == "Israel") %>%
  dplyr::select(state1h, state2h, year, t, dyad_id, conflict_id, intensity) %>% 
  View()
```
--> ok

```{r}
conflict_dyad.pcw2 %>% 
  dplyr::filter(state1h == "Namibia" & state2h == "Rwanda") %>%
  dplyr::select(state1h, state2h, year, t, dyad_id, conflict_id, intensity) %>% 
  View()
```
--> ok

```{r}
conflict_dyad.pcw2 %>% 
  dplyr::filter(state1h == "Namibia" & state2h == "Uganda") %>%
  dplyr::select(state1h, state2h, year, t, dyad_id, conflict_id, intensity) %>% 
  View()
```
--> 1998 & 1999 duplicates = *585*

```{r}
conflict_dyad.pcw2 %>% 
  dplyr::filter(state1h == "Rwanda" & state2h == "Zimbabwe") %>%
  dplyr::select(state1h, state2h, year, t, dyad_id, conflict_id, intensity) %>% 
  View()
```
--> ok

```{r}
conflict_dyad.pcw2 %>% 
  dplyr::filter(state1h == "Uganda" & state2h == "Zimbabwe") %>%
  dplyr::select(state1h, state2h, year, t, dyad_id, conflict_id, intensity) %>% 
  View()
```
--> 1998 & 1999 duplicates = *585*

```{r}
conflict_dyad.pcw2 %>% 
  dplyr::filter(state1h == "Bahrain" & state2h == "Yemen") %>%
  dplyr::select(state1h, state2h, year, t, dyad_id, conflict_id, intensity) %>% 
  View()
```
--> ok

```{r}
conflict_dyad.pcw2 %>% 
  dplyr::filter(state1h == "Iran" & state2h == "Turkey") %>%
  dplyr::select(state1h, state2h, year, t, dyad_id, conflict_id, intensity) %>% 
  View()
```
--> ok

```{r}
conflict_dyad.pcw2 %>% 
  dplyr::filter(state1h == "Iran" & state2h == "United States") %>%
  dplyr::select(state1h, state2h, year, t, dyad_id, conflict_id, intensity) %>% 
  View()
```
--> ok

```{r}
conflict_dyad.pcw2 %>% 
  dplyr::filter(state1h == "Saudi Arabia" & state2h == "Yemen") %>%
  dplyr::select(state1h, state2h, year, t, dyad_id, conflict_id, intensity) %>% 
  View()
```
--> ok

```{r}
conflict_dyad.pcw2 %>% 
  dplyr::filter(state1h == "Sudan" & state2h == "Yemen") %>%
  dplyr::select(state1h, state2h, year, t, dyad_id, conflict_id, intensity) %>% 
  View()
```
--> ok

```{r}
conflict_dyad.pcw2 %>% 
  dplyr::filter(state1h == "Syria" & state2h == "Turkey") %>%
  dplyr::select(state1h, state2h, year, t, dyad_id, conflict_id, intensity) %>% 
  View()
```
--> ok

```{r}
conflict_dyad.pcw2 %>% 
  dplyr::filter(state1h == "United Arab Emirates" & state2h == "Yemen") %>%
  dplyr::select(state1h, state2h, year, t, dyad_id, conflict_id, intensity) %>% 
  View()
```
--> ok



##### delete duplicates

For these 5 dyads, I identified duplicate entries for 1998 & 1999:
  - "Congo - Kinshasa" vs "Uganda"
  - "Congo - Kinshasa" vs "Rwanda"
  - "Chad" vs "Uganda"
  - "Namibia" vs "Uganda"
  - "Uganda" vs "Zimbabwe"
The duplicates of these 5 dyads all concern the conflict dyad id 585 vs 586. We'll delete the duplicates manually.

Inspect all conflict with ids 586 & 585. Note e.g. dyad Angola-Uganda has two entries for 1988, one with dyad_id 585 and another with dyad_id 586.
```{r}
conflict_dyad.pcw2 %>%
  dplyr::filter(year %in% 1998:1999 & (dyad_id == 586 | dyad_id == 585)) %>% 
  dplyr::arrange(state1h, state2h)
```

--> Since 586 also identifies dyad pairs that do not have duplicate entries, we'll exclude conflicts with identifier 585 for all 5 dyads.
```{r}
conflict_dyad.pcw2 <- conflict_dyad.pcw2 %>%
  dplyr::filter(!(year %in% 1998:1999 & dyad_id == 585))
```
10 duplicate entries deleted.


### descriptive stats
```{r}
# How many conflicts do each unique dyad have in total between 1993-2023?
conflict_dyad.pcw2 %>% 
  group_by(dyad_name) %>%
  dplyr::summarise(n = n())
```


```{r}
# How many conflicts do each unique dyad have, broken down by t spell?
conflict_dyad.pcw2 %>% 
  group_by(t, dyad_name) %>% 
  dplyr::summarise(n = n())

# How many conflicts do each unique dyad have in t=5 (i.e. 2012-2016)
conflict_dyad.pcw2 %>% 
  dplyr::filter(t == "t5") %>% 
  group_by(dyad_name) %>% 
  dplyr::summarise(n = n())

# How many countries in the conflict system between 1993-2023?
length(union(conflict_dyad.pcw2$state1h, conflict_dyad.pcw2$state2h)) # 78 in total
# unique(c(conflict_dyad.pcw2$state1h,conflict_dyad.pcw2$state2h))

# check nas
colSums(is.na(conflict_dyad.pcw2))
```


### save 6
```{r}
# Original
# save(conflict_dyad.pcw, file = "conflict_dyad.pcw.RData") # as R data file
# load("conflict_dyad.pcw.RData") 

# MANUAL DELETION OF DUPLICATES
# save(conflict_dyad.pcw2, file = "conflict_dyad.pcw2.RData") # as R data file
load("conflict_dyad.pcw2.RData")
```



## I.4) Geographic distance (CShapes suite)


### import 

Several ways to import i.e. calculate distance between capitals. I'll use the cshape package since it uses up-to-date GIS data. Other options include Gleditsch & Ward handcoded data. However, it has not been updated since 2001.

- CShape: 
  - https://www.socialpolicydynamics.de/f/d2d9aa3a9b.pdf
  - https://journal.r-project.org/archive/2010/RJ-2010-004/RJ-2010-004.pdf
  - Schvitz, Guy, Seraina Rüegger, Luc Girardin, Lars-Erik Cederman, Nils Weidmann, and Kristian Skrede Gleditsch. 2023. “Mapping The International System, 1886-2017: The CShapes 2.0 Dataset.” Journal of Conflict Resolution 66(1): 144–61.

- CShape data use cow and gwn ccodes. Both use the designation Yugoslavia instead of Serbia.

```{r}
# install.packages("cshapes", dependencies = TRUE)
library(cshapes)
```

```{r}
## access cshapes dataset
# data for 1993-2024, with COW country code, without dependent entities of states --> 182 states
dat <- as.Date("01.01.1993", format="%d.%m.%Y")
cshp <- cshp(date = dat, useGW = F, dependencies = F) %>% # useGW = F --> use COW ccode instead of GW ccode
  dplyr::arrange(country_name)
```

```{r}
## calculate distance between capitals in km
capdist <- distlist(dat, type = "capdist", keep = 0.1, useGW = F,
dependencies = F)
```



### country codes harmonization

CShapes distance data, the original country designation is coded in cow numeric, in vbl ccode1 and ccode2.

#### add cow ccodes

```{r}
# cow name
capdist$cowen1 <- countrycode(capdist$ccode1, origin = 'cown', destination = 'cow.name')
capdist$cowen2 <- countrycode(capdist$ccode2, origin = 'cown', destination = 'cow.name')

# cow character
capdist$cowc1 <- countrycode(capdist$ccode1, origin = 'cown', destination = 'cowc')
capdist$cowc2 <- countrycode(capdist$ccode2, origin = 'cown', destination = 'cowc')

# rename cow numeric
capdist <- capdist %>% 
  dplyr::rename(cown1 = ccode1, cown2 = ccode2)
```


#### check for usual obsolete polities (Czechoslovakia, Yugoslavia, Yemen)
```{r}
View(capdist)
# use search to look for Czechoslovakia, Yemen, and Yugoslavia
```
-> no pb with Czecho and Yemen, but for "Yugoslavia" entries, we need to add "Serbia" in un m49 and iso 3 ccodes

#### add other ccodes
```{r}
# iso 3
capdist$iso1 <- countrycode(capdist$cown1, origin = 'cown', destination = 'iso3c')
capdist$iso2 <- countrycode(capdist$cown2, origin = 'cown', destination = 'iso3c')

# un m49
capdist$un1 <- countrycode(capdist$cown1, origin = 'cown', destination = 'un')
capdist$un2 <- countrycode(capdist$cown2, origin = 'cown', destination = 'un')
```
--> pb with 345 (Yugoslavia/Serbia) and 713 (Taiwan). Taiwan does not feature in the UN i.e. ISO system. 

#### recode Yugoslavia

```{r}
## change Serbia/Yugoslavia in iso. SRB is the code for Serbia
capdist <- capdist %>% 
  dplyr::mutate(iso1 = if_else(cowen1 == "Yugoslavia", "SRB", iso1),
         iso2 = if_else(cowen2 == "Yugoslavia", "SRB", iso2))
```

```{r}
## change Serbia/Yugoslavia in un m49. 688 is the code for Serbia
capdist <- capdist %>% 
  dplyr::mutate(un1 = if_else(cowen1 == "Yugoslavia", 688, un1),
         un2 = if_else(cowen2 == "Yugoslavia", 688, un2))
```



#### add own country designation system
```{r}
# english country names based on un m49
capdist$state1h <- countrycode(capdist$un1, origin = 'un', destination = 'country.name')
capdist$state2h <- countrycode(capdist$un2, origin = 'un', destination = 'country.name')
```

```{r}
# my own dyad naming system
capdist <- capdist %>%     # create an ID variable for each dyad combination
  dplyr::mutate(dyad_name = paste(state1h, state2h, sep = "_"))
```





### exclude states with NA in countrycodes

We'll delete observations with NAs in the cow and in the iso alpha 3/m49 columns. NAs in either of these ccode systems mean the entity is not a formal member of the international system starting 1993, either because they no longer exist, are politically contested territories, united with another entity to form a new state, or are not recognized as an independent state for some other reason.

These are usually e.g. 
Palestine (PSE), Hong Kong (HKG), Taiwan (TWN), Kosovo (KOS), Macau (MAC), Aruba (ABW), and West Sahara (ESH). Palestine, Hongkong, and Macao exist in the un m49 system because of observer or associated member status, but they are not in the cow system because of contested status as a sovereign state/territory. Taiwan, on the other hand, is not part of the UN m49 because it lost its seat in 1971, but remains in the cow ccode system.

```{r}
colSums(is.na(capdist))
capdist %>% 
  dplyr::filter(is.na(un1) | is.na(un2)) %>% 
  dplyr::filter(!(cowen1 == "Taiwan" | cowen2 == "Taiwan"))
# --> all missing values in un m49 country codes are Taiwan cases
```

```{r}
capdist <- capdist %>% 
  # delete iso alpha 3 & un m49 NA cases 
  dplyr::filter(!is.na(cown1) & !is.na(un1)) %>% 
  dplyr::filter(!is.na(cown2) & !is.na(un2))
  # delete info for contested territories
  # dplyr::filter(iso1 != "HKG" & iso1 != "PSE" & iso1 != "TWN" & iso1 != "ESH" & iso1 != "MAC") %>%
  # dplyr::filter(iso2 != "HKG" & iso2 != "PSE" & iso2 != "TWN" & iso2 != "ESH" & iso2 != "MAC")
```

```{r}
# check for duplicates
capdist[duplicated(capdist),] 
# capdist[duplicated(capdist) | duplicated(capdist, fromLast = TRUE),]
# Delete duplicates
# capdist <- capdist[!duplicated(capdist), ]
```


### labels
```{r}
# add vbl labels
# library(Hmisc)
label(capdist$capdist) <- "distance between capital cities (in km)"

label(capdist$state1h) <- "state1 harmonized name based on un m49"
label(capdist$state2h) <- "state2 harmonized name based on un m49"
label(capdist$iso1) <- "state1 iso alpha 3 country code"
label(capdist$iso2) <- "state2 iso alpha 3 country code"
label(capdist$un1) <- "state1 un m49 country number"
label(capdist$un2) <- "state2 un m49 country number"
label(capdist$dyad_name) <- "my own ID for dyad"

label(capdist$cowen1) <- "state1 COW name"
label(capdist$cowen2) <- "state2 COW name"
label(capdist$cown1) <- "state1 COW number"
label(capdist$cown2) <- "state2 COW number"
label(capdist$cowc1) <- "state1 COW character"
label(capdist$cowc2) <- "state2 COW character"
# Hmisc::label(capdist) # check result
```

--> capital distance remains the same through time, so no need to subset the data for post-CW period.

```{r}
capdist <- capdist %>% 
  dplyr::select(state1h, state2h, capdist, everything()) %>%
  dplyr::arrange(state1h, state2h)
```


### descriptives
```{r}
# 182 states = 181x181 edge list = 33124 dyads (inc. zero diagonals i.e. self-loop)
capdist %>% 
  pull(cowc1) %>% 
  unique() %>% 
  length()

capdist %>% 
  dplyr::select(cowen1) %>%
  unique() %>% 
  View()
```


### save 1
```{r}
# Save working file
# save(capdist, file = "capdist.RData") # as R data file
# load("capdist.RData") 
```






### [DROPPED] G&W handcoded capdist data

- handcoded data: geographic distance between capital cities (Gleditsch/Ward)
- cite: Gleditsch, Kristian S., and Michael D. Ward. (2001). "Measuring Space: A Minimum-Distance Database and Applications to International Studies." Journal of Conflict Resolution 38(6): 739-758.

Problem with G&W dataset. For some reason, these states were not found in the G&W database:
- Serbia, 340, SER (since 2006 independent) --> in cow system, Serbia is 345, SRB
- Kiribati, 970, KBI
- Tonga, 972, KBI
- South Sudan, 626, SSD (seit 2011)
- [Aruba (part of Netherlands)] --> does not exist in the COW ecosystem, so trying to match a cow code with Aruba is going to create NAs

```{r}
# # import Gleditsch & Ward list of independent states
# library(states) # not available for this R Version 4.0.0 Puppy Cup =/

# import manually Gleditsch & Ward dyadic data on capital distances
# capdist_o <- read.csv("data/Capital distance/capdist.csv", sep=",", header = T, check.names = F)
```


Codebook:

numa: COW code -- country A.
ida: Three letter ISO code -- country A.
numb: COW code -- country B.
idb: Three letter ISO code -- country B.
kmdist: Distance between capital cities in the kilometers.
midist: Minimal distance between capital cities in the kilometers.

#### G&W via peacesciencer package

https://svmiller.com/peacesciencer/articles/state-systems.html
https://cran.r-project.org/web/packages/peacesciencer/peacesciencer.pdf

```{r}
## Other ways to retrieve capital distance data
# library(peacesciencer)

## List of capital cities in gw country code system
capitals_gw <- gw_capitals

capitals_1993 <- capitals_gw %>% 
  dplyr::filter(endyear >= 1993)

capitals_1993 %>% 
  dplyr::filter(endyear != 2020) # Kazakhstan had Almaty as capital until 1998, Myanmar had Rangoon until 2005

capitals_1993 %>% 
  dplyr::filter(statenme == "Kazakhstan" | statenme == "Myanmar") # Kazakhstan = Astana, Myanmar = Pyinmana)

capitals_gw_2020 <- capitals_gw %>% 
  dplyr::filter(endyear >= 2020) %>% 
  dplyr::arrange(statenme)
```

```{r}
## List of capital cities in cow country code system
capitals_cow <- cow_capitals
capitals_cow_2020 <- capitals_cow %>% 
  dplyr::filter(endyear >= 2020) %>% 
  dplyr::arrange(statenme)
```

Add capital-to-capital distance
```{r}
cow_dy <- cow_ddy # all country-years since 18
cow_dy_capdist <- cow_dy %>% 
  add_capital_distance()
sty <- create_stateyears()
create_stateyears() %>% add_capital_distance()
```

#### add ccode
```{r}
# library(countrycode)
?codelist # country codes designations
# countrycode::guess_field(iat$supplier, min_similarity=80)
names(countrycode::codelist) # countrycode internal data frame listing country codes

# rename mem1 & mem2 to indicate country code used is cown (correlates of war numeric)
capdist <- capdist %>% 
  dplyr::rename(cow1 = numa,
                cow2 = numb,
                km_dist = kmdist,
                mi_dist = midist) 
```




  <br>
  <br>
  
  
  
  

# II) SYSTEM MEMBERS FOR COMPLETE NETWORK

--> A member of the international system is defined as being a member of the UN and of the COW State System Membership List: https://ourworldindata.org/grapher/united-nations-membership-status



## II.1) UN & COW system members

### UN list

@nga: citation
United Nations (2023) – with major processing by Our World in Data. “United Nations membership status” [dataset]. United Nations, “United Nations member states” [original data]. Retrieved July 30, 2024 from https://ourworldindata.org/grapher/united-nations-membership-status

--> UN membership status as of 2022

I) Import
```{r}
## UN countries
un_list <- read.csv("data/System_members/UN_members.csv", sep=",", header = T, check.names = F)
names(un_members)

# subset only members starting 1993
un_list <- un_list %>% 
  dplyr::rename(state = Entity, 
         ccode_un = Code, 
         year = Year,
         member = `United Nations membership status`) %>%
  dplyr::mutate(member = ifelse(member == "Member",1,0),
         year_member = ifelse(member == 1, year, NA)) %>% 
  dplyr::filter(year >= 1993)
```


II) country codes harmonization

which origin ccode
```{r}
library(countrycode)
## countrycodes
ccodes <- countrycode::codelist # data frame listing popular country codes
names(ccodes)
?codelist # country codes designations
```
If given a database of country codes and not sure what code format they are in, using guess_field() function shows what percentage of values match which which coding system.

```{r}
a <- un_list$state
b <- un_list$ccode_un
countrycode::guess_field(a, min_similarity=90) # cow.name or country.name
countrycode::guess_field(b, min_similarity=90) # iso3c seems fine
```


add ccodes
```{r}
## ISO & UN codes
un_list <- un_list %>% dplyr::rename(iso = ccode_un)
un_list$state <- countrycode(un_list$iso, origin = 'iso3c', destination = 'country.name')
un_list$un <- countrycode(un_list$iso, origin = 'iso3c', destination = 'un')

## COW codes
# cow character
un_list$cowc <- countrycode(un_list$iso, origin = 'iso3c', destination = 'cowc')
un_list <- un_list %>% dplyr::mutate(cowc = if_else(iso == "SRB", "YUG", cowc))
# cow name
un_list$cowen <- countrycode(un_list$iso, origin = 'iso3c', destination = 'cow.name')
un_list <- un_list %>% dplyr::mutate(cowen = if_else(state == "Serbia", "Yugoslavia", cowen))
# cow number
un_list$cown <- countrycode(un_list$cowc, origin = 'cowc', destination = 'cown')
un_list <- un_list %>% dplyr::mutate(cown = if_else(state == "Serbia", 345, cown))

```


### UN vs COW
```{r}
## COW countries
# load("cow_list.RData")
names(cow_list)

# cow system members after 1816 that do not feature in un member system of 2023
setdiff(cow_list$cowen, un_list$cowen)
```
--> entities that were dissolved or are no longer recognized as sovereign:

- German states unification in 1870: Bavaria, Saxony, Hanover, Wuerttemberg, Baden, Hesse, Mecklenburg Schwerin 
- Italy unification in 1870: Papal States (under sovereignty of the Pope), Modena. Parma, Tuscany, Two Sicilies
- Austria-Hungary dissolved in 1919
- Czechoslovakia broke up into Czech and Slovakia. 
- South and North Vietnam united in 1976. 
- North and South Yemen united in 1990. 
- East and West Germany united in 1990.
- Zanzibar partly-autonomous, part of Tanzania
- Kosovo claimed by Serbia i.e. Yugoslavia


```{r}
# un members in 2023 not in cow system
a <- setdiff(un_list$iso, cow_list$iso)
```

```{r}
un_list %>% 
  dplyr::filter(iso %in% a) %>% 
  group_by(state) %>% 
  dplyr::summarise(state = state, iso = iso) %>% 
  unique()
```
Why do these countries miss in the cow system?
- Serbia is called Yugoslavia in COW
- Palestine & Western Sahara have contested political status
- the rest are independent entities but under sovereignty of some other state


### save 1
```{r}
## all entities in UN list from 1993-2023
# save(un_list, file = "un_list.RData")
# load("un_list.RData")
```


## II.2) UN members after 1993

### Status between 1993-2022

```{r}
# in 1993 = 183 members
un_list %>% 
  dplyr::filter(year_member==1993) %>%
  group_by(state) %>% 
  count()

# in 2023 = 193
un_list %>% 
  dplyr::filter(year_member==2022) %>%
  group_by(state) %>% 
  count()
```
10 members joined the UN between 1993 and 2022 due to separation from or unification of states.


**Check which are the 10 members that were admitted to the UN after 1993 and when they joined**
```{r}
un_list %>%
  group_by(state) %>%
  dplyr::summarise(member = mean(member),
            year_joined = min(year_member, na.rm = T)) %>% 
  dplyr::filter(member > 0 & member < 1)
```

Countries admitted to UN after 1993
- East Timor 2002
- Kiribati 1999
- Montenegro 2006
- Nauru 1999
- Palau 1994
- Serbia 2000
- South Sudan 2011
- Switzerland 2002
- Tonga 1999
- Tuvalu 2000

These 10 countries might be missing some country and dyad data between 1993 and 2023, since they might have had a different name before joining the UN (e.g. Serbia used to be a apart of Yugoslavia), were only established as an independent state after 1993 (Montenegro after secession from Yugoslavia i.e. Serbia), or only decided to join the UN only after 1993 (e.g. Switzerland). 

As of the moment, the btergm function cannot handle NAs as of yet. Furthermore, adding exiting and entering nodes in the network proves to be complicated computationally. So, to simplify and avoid problems in the network modelling, these 10 countries will be treated as system members even during the time before they joined the UN, i.e. in t1 (1993-1997), t2 (1998-2002), and t3 (2003-2012).


### Contested territories

Contested territories: https://www.worlddata.info/alliances/un-united-nations.php
UN currently has 193 member states and their additionally dependent external territories. 

Countries and territories that are not members:

-   Northern Cyprus is actually a Turkish republic according to all UN member states. Turkey does not recognize Northern Cyprus.

-   Taiwan is claimed by China and was a regular member of the UN until 1971. Due to foreign policy constraints with China several states were forced to no longer recognize Taiwan and to consider it part of China in the future.

-   The status of Western Sahara under international law has not yet been clarified. There are still disputes between Morocco and the Sahrawis that do not currently allow recognition as an independent country.

-   The status of Kosovo under international law is also still controversial. Although more than half of the UN members now recognize Kosovo as a sovereign state, it is still under the administrative jurisdiction of the United Nations.

-   Vatican City and Palestine have the role of permanent observer. They are treated as members, but have no voting rights in the General Assembly.

-   The Cook Islands, Niue and Northern Mariana Islands are smaller Pacific island states with a total population of less than 70,000. They are freely associated with New Zealand and the USA respectively, but are monitored by the UN.

-   Curaçao is an island in the Caribbean and has actually become a sovereign state since the dissolution of the Netherlands Antilles in 2010. It is considered an "independent country within the Kingdom of the Netherlands" by the United Nations


**Check non-UN territories & states in the data set**:
```{r}
# not UN members 
un_list %>%
  group_by(state) %>% 
  dplyr::summarise(mean = mean(member)) %>% 
  dplyr::filter(mean == 0)
```

9x: French Guiana, French Southern Territories, Greenland, Kosovo, New Caledonia, Palestine, Puerto Rico, Taiwan, Western Sahara

These are entities that are non-sovereign/contested territories:
- French territories: French Guiana, Southern Territories, New Caledonia
- Greenland is an autonomous part of Denmark
- Kosovo is contested (claimed by Serbia)
- Palestine has no sovereign state status just yet
- Puerto Rico is territory of U.S.
- Taiwan is contested (claimed by China)
- Western Sahara is contested (claimed by Morocco)

--> Across all data sets, these entities will be excluded from analysis henceforth. 


### List of valid UN members

This is the list of valid members for the analysis henceforth:
```{r}
un_not_members <- un_list %>%
  group_by(state) %>% 
  dplyr::summarise(mean = mean(member)) %>% 
  dplyr::filter(mean == 0) %>% 
  pull(state)

un_members <- un_list %>%
  dplyr::filter(!state %in% un_not_members)
```

```{r}
# 193 members of the UN as of 2022
un_members %>% 
  group_by(state) %>%
  count()
```







### save 2
```{r}
## un, 193 valid members
# save(un_members, file = "un_members.RData")
# load("un_members.RData")
```




## II.3) UN members missing in data sets


### A) List of all nodes in iat/alliance/conflict data

#### iat nodes
```{r}
iat2 <- union(iat.pcw$state1h, iat.pcw$state2h)
iat2 <- unique(iat2)
# 178 countries trading weapons between 1993-2023
```

#### ally nodes
```{r}
ally2 <- union(ally.pcw$state1h, ally.pcw$state2h)
ally2 <- unique(ally2)
# 186 countries with alliance(s) between 1993-2023
```

#### conflict nodes
```{r}
conflict2 <- union(conflict_dyad.pcw$state1h, conflict_dyad.pcw$state2h)
conflict2 <- unique(conflict2)
# 78 countries involved in conflict(s) between 1993-2023
```

#### capdist nodes
```{r}
capdist2 <- union(capdist$state1h, capdist$state2h)
capdist2 <- unique(capdist2)
# 181 countries capital distances
```

#### all nodes combined
```{r}
# all countries in iat, alliance, conflict combined = active countries

# Save names of all active nodes in iat network 1993-2023
iat_ally2 <- union(iat2, ally2) 
iat_ally_conf2 <- union(iat_ally2, conflict2)
all_active2 <- union(iat_ally_conf2, capdist2)
rm(iat_ally_conf2)
rm(iat_)

all_active2 <- sort(all_active2) # 192 countries
```
--> countries from all edge cases combined are 192. Since there are only 178 countries that trade weapons, this means there are 14 countries that are isolates


#### compare nodes with UN members
```{r}
un2 <- un_members %>% pull(state) %>% unique() %>% sort()
```

```{r}
setdiff(all_active2, un2)
setdiff(un2, all_active2)
```

in all_active list but not in un member list: 0
in un member list but not in all_active list: Nauru

We'll add Nauru as an isolate to all of our matrices later. (iat, alliance, conflict, capdist)

#### save 3
```{r}
## all active nodes in the 3 networks, Nauru as the last UN member is missing.
# save(all_active2, file = "all_active2.RData")
# load("all_active2.RData")
```




### B) Compare nodes between matrices

#### iat nodes missing in other matrices
```{r}
setdiff(iat2, ally2) # 5 countries --> no pb
setdiff(iat2, conflict2) # 100 countries --> no pb
setdiff(iat2, un2) # 0

a <- setdiff(iat2, capdist2) # 9 countries --> pb :/
a
```
in iat, not capdist
  -   "Eritrea"         
  -   "Montenegro"      
  -   "North Macedonia" 
  -   "Kiribati"       
  -   "Tuvalu"          
  -   "Palau"           
  -   "Tonga"           
  -   "South Sudan"    
  -   "Timor-Leste"    


#### allied nodes missing in other matrices
```{r}
setdiff(ally2, iat2) # 13 countries --> no pb
setdiff(ally2, conflict2) # 108 countries --> no pb
setdiff(ally2, un2) # 0
b <- setdiff(ally2, capdist2) # 10 countries --> pb :/
b
```
in ally, not capdist
  -   "Monaco"
  -   "North Macedonia", 
  -   "Andorra", 
  -   "Eritrea", 
  -   "Montenegro", 
  -   "Timor-Leste", 
  -   "South Sudan", 
  -   "Kiribati", 
  -   "Tuvalu", 
  -   "Tonga"


#### conflict nodes missing in other matrices
```{r}
setdiff(conflict2, iat2) # 0
setdiff(conflict2, ally2) # 0
c <- setdiff(conflict2, capdist2) # 2 countries --> pb :/
```
in conflict, not capdist
  -   Eritrea
  -   South 
  
  
#### summary

The countries that feature in the IAT network, but do not have entries in the conflict and alliance networks, are not a problem. Their missing information in conflict and alliance will be interpreted as the absence of any alliance or conclicts. Their values will be coded as 0.



### C) Missing capdist data

#### check among all nodes
```{r}
nodes_no_capdist <- c(a,b,c)
nodes_no_capdist <- nodes_no_capdist %>% unique() %>%  sort() # 11 countries in total, that have missing data in capdist
nodes_no_capdist
```


#### check among UN members
```{r}
un_no_capdist <- setdiff(un2, capdist2) %>% sort() # 12 countries --> pb :/
un_no_capdist
capdist2
```
The countries featuring among the iat/alliance/conflict data that do not have capdist data are about the same as those among the un members that do not have capdist data.


**summary: 12 countries with missing capdist information**
  -   "Andorra"   
  -   "Eritrea"  
  -   "Monaco"          
  -   "Montenegro"  
  -   "Nauru"
  -   "North Macedonia" 
  -   "Kiribati"       
  -   "Tuvalu"          
  -   "Palau"           
  -   "Tonga"           
  -   "South Sudan"    
  -   "Timor-Leste"  

#### list of nodes missing capdist data

--> TODO: hunt for capdist info of 12 UN members i.e. of 11 active nodes in iat/ally/conflict

These countries that are missing capdist data are a problem. - now, that's a problem. We cannot impute any value to the missing capdist information. This information has to be retrieved online - and added to the data manually.




## II.4) capdist: world cities data set

Esri Data and Maps: https://hub.arcgis.com/datasets/esri::world-cities/about

https://dominicroye.github.io/en/2020/geographic-distance/
https://www.rdocumentation.org/packages/maps/versions/3.4.2/topics/world.cities

Since we still miss the information for Monaco and South Sudan,
we'll use the maps package and the world city data set inc. latitude and longitude information to retrieve the capital distance information. With this, we'll create the capital distance data ourselves. 

```{r}
# Common packages for spatial analysis
library(sf)
library(units)
library(rnaturalearth)
library(ggmap)
```


#### world city data

##### import
```{r}
# packages: sf, units, maps, rnaturalearth
library(maps)
cities <- world.cities # all cities 
# Juba (South Sudan) and Suva (Fiji) not flagged as capital cities
```

The dataset has a variable called capital, which flags whether a city in the list is also a country's capital city.
South Sudan a young country, existing since 2011, and also the most recent UN member. It's capital is "Juba". Juba is not flagged as a capital city, probably because the list of world city has not been updated to reflect this change just yet. For some reason, Fiji's capital city Suva and Montenegro's capital city Podgorica were also not flagged as such. 

I'll later report these mistakes to the maps package creators and those that maintain the dataset.
```{r}
# only capital cities
ccities <- cities %>%
  dplyr::mutate(capital = ifelse(name == "Juba" | name == "Suva" | name == "Podgorica", 1, capital)) %>% # add Juba & Suva as capital cities
  dplyr::filter(capital == 1) %>% # filter for capital cities
  dplyr::rename(state = country.etc, # rename variables
         capital = name,
         etc = capital) %>%
  dplyr::select(-etc)
```


##### add country codes

###### prep
```{r}
a <- ccities$state
countrycode::guess_field(a, min_similarity=85) # the closest ccode permitted as origin is country.name.en
?codelist
```

Usually, Micronesia's designation has to be adapted for it to be recognized in the countrycode package's database:
```{r}
ccities <- ccities %>% 
  dplyr::mutate(state = ifelse(state == "Micronesia", "Micronesia (Federated States of)", state))
```


###### ccodes
```{r}
## iso
ccities$iso <- countrycode(ccities$state, origin = 'country.name', destination = 'iso3c') # nm: Netherlands Antilles

## un
ccities$un <- countrycode(ccities$state, origin = 'country.name', destination = 'un')
```
Netherlands Antilles w& Taiwan were not matched, which is not a problem since they are not UN i.e. system members.

```{r}
## cow
# cown
ccities$cown <- countrycode(ccities$state, origin = 'country.name', destination = 'cown')

## change Serbia/Yugoslavia in iso. SRB is the code for Serbia
ccities <- ccities %>% 
  dplyr::mutate(cown = if_else(state == "Serbia", 345, cown))

# cow name
ccities$cowen <- countrycode(ccities$cown, origin = 'cown', destination = 'cow.name')

# cow character
ccities$cowc <- countrycode(ccities$cown, origin = 'cown', destination = 'cowc')
```
37 entities not matched (but that does not matter, as none of them is a sovereign state and thus not a system member):
"American Samoa", "Anguilla", "Aruba", "Bermuda", "British Virgin Islands", "Cayman Islands", "Cook Islands", "Falkland Islands", "Faroe Islands", "French Guiana", "French Polynesia", "Gibraltar", "Greenland", "Guadeloupe", "Guam", "Guernsey and Alderney", "Isle of Man", "Jersey", "Martinique", "Mayotte", "Netherlands Antilles", "New Caledonia", "Niue", "Norfolk Island", "Northern Mariana Islands", "Pitcairn", "Puerto Rico", "Reunion", "Saint Helena", "Saint Pierre and Miquelon", "Serbia", "Svalbard and Jan Mayen", "Tokelau", "Turks and Caicos", "US Virgin Islands", "Wallis and Futuna", "Western Sahara"

```{r}
# harmonized state name: english country names based on un m49
ccities$state <- countrycode(ccities$un, origin = 'un', destination = 'country.name')
```


##### check UN members in world.cities dataset

```{r}
## UN members not in ccities dataset
setdiff(unique(un_members$state), ccities$state) # none, so all UN members are in the ccities dataset

## Entities in the ccities data set that are not UN members
setdiff(ccities$state, unique(un_members$state)) # none among them is a sovereign state
```

```{r}
## only keep UN members in ccities dataset 
not_members <- setdiff(ccities$state, unique(un_members$state))
ccities <- ccities %>%
  dplyr::filter(!state %in% not_members)
```

```{r}
## check for duplicates
ccities %>% dplyr::filter(duplicated(state) | duplicated(state, fromLast = TRUE)) # there are two entries for Cyprus and Costa Rica
```
There are two entries for Cyprus and Costa Rica. We'll have to evaluate which is the valid entry to keep and the duplicate to delete. In this case, we have 2 different population information for Cyprus and Costa Rica. Nicosia has one entry for ca. 200000 and another for ca. 42000 population count. San Jose has an entry with ca. 32000 and another with ca. 340000. 
I looked up online which one is true. It seems (report this later to the maps package creators) we can retain the Nicosia row with 202000 population and San Jose with 340000.

```{r}
ccities <- ccities %>% 
  dplyr::filter(!(capital == "Nicosia" & pop == 42372)) %>% 
  dplyr::filter(!(capital == "San Jose" & pop == 32187))
```

Check again
```{r}
## check for duplicates
ccities %>% dplyr::filter(duplicated(state) | duplicated(state, fromLast = TRUE)) # no more duplicates
```

```{r}
## check whether states in both data sets align
length(ccities$state) # 193 states
length(unique(un_members$state)) # 193 states

## same 193 states in both data sets
a <- sort(ccities$state)
b <- sort(unique(un_members$state))
identical(a,b) # looks good
```

Now that we've cleaned the ccities dataset to only contain UN members,
we can proceed to calculate the capital distances.



##### final cleaning

```{r}
ccities <- ccities %>% dplyr::arrange(state)
```


To convert points with longitude and latitude into a spatial object of class sf, we use the function st_as_sf(), indicating the coordinate columns and the coordinate reference system (WSG84, epsg: 4326).
```{r}
# library(sf) # Simple Feature: import, export and manipulate vector data
# library(units) # Support for measurement units in R vectors, matrices and arrays: propagation, conversion, derivation

# convert the points into an sf object with CRS WSG84
ccities2 <- st_as_sf(ccities, coords = c("long", "lat"), crs = 4326)
```

The advantage of the sf package is the possibility of applying functions of the tidyverse collection to manipulate the attributes. In addition, we add a column with new labels using the str_c() function of the stringr package, which is similar to that of R Base paste()
```{r}
# create a new label combining name and country
ccities2 <- dplyr::mutate(ccities2, state_capital = str_c(state, " (", capital, ")"))
```

##### save 2
```{r}
# save(ccities2, file = "ccities2.RData")
# load("ccities2.RData")

# save(ccities, file = "ccities.RData")
# load("ccities.RData")
```




#### capital distance

-   Tutorial by: https://dominicroye.github.io/en/2020/geographic-distance/
-   https://www.r-bloggers.com/2019/10/geographic-distance/
-   (https://milospopovic.net/geo-business_intelligence-compute-shortest-driving-distance-in-r/)
-   (https://rpubs.com/yixin_zhang/GVDCR) 


```{r}
library(maps) # Draw geographical maps
library(stringr)
library(sf) # Simple Feature: import, export and manipulate vector data
library(units) # Support for measurement units in R vectors, matrices and arrays: propagation, conversion, derivation
library(rnaturalearth) # Hold and facilitate interaction with Natural Earth map data
# library(gmapsdistance) 
```


##### calculate
Geographical distance (Euclidean or greater circle) is calculated with the st_distance() function, either between two points, between one point and others or between all points. In the latter case we obtain a symmetric matrix of distances (NxN), taken pairwise between the elements of the capital city set. In the diagonal we find the combinations between the same points giving all null values.

In the second step, we estimate the distance matrix between all the capital cities. It is important to 
```{r}
# calculate distance matrix
capdist_mat <- st_distance(ccities2)
# class(capdist_mat) # unit
# typeof(capdist_mat) # double
dim(capdist_mat)

# change m to km
capdist_mat <- set_units(capdist_mat, km)

## IGNORE: convert the null values to NA to subsequently obtain the correct matrix index. replace 0 m distance to NA. 0 values are loops, i.e. distance from Berlin to Berlin. For my use case of network analysis, no need to transform 0 into NA.
# capdist_mat[capdist_mat == set_units(0, km)] <- NA
```
When the result is of the units class, it is necessary to use the same class to be able to make logical queries. For example, set_units(1, m) == set_units(1, m) vs. set_units(1, m) == 1. In my case, I do not want to replace 0 with NAs, as I want to keep the zero values in the matrix.


##### adj matrix & edge list
```{r}
## Matrix
# Convert object of class "units" into distance matrix class
capdist_mat <- as.data.frame(as.matrix(drop_units(capdist_mat)))
# Add state names as row and column names
rownames(capdist_mat) <- ccities$state
colnames(capdist_mat) <- ccities$state

## Edge List
capdist_wc <- capdist_mat %>% # convert matrix into long format df
  rownames_to_column(var = "state1h") %>%
  pivot_longer(-state1h, names_to = "state2h", values_to = "capdist_km") # in km
```

##### ccodes
```{r}
## iso
capdist_wc$iso1 <- countrycode(capdist_wc$state1h, origin = 'country.name', destination = 'iso3c')
capdist_wc$iso2 <- countrycode(capdist_wc$state2h, origin = 'country.name', destination = 'iso3c')

## un
capdist_wc$un1 <- countrycode(capdist_wc$state1h, origin = 'country.name', destination = 'un')
capdist_wc$un2 <- countrycode(capdist_wc$state2h, origin = 'country.name', destination = 'un')

# cown
capdist_wc$cown1 <- countrycode(capdist_wc$state1h, origin = 'country.name', destination = 'cown')
capdist_wc$cown2 <- countrycode(capdist_wc$state2h, origin = 'country.name', destination = 'cown')
## change Serbia/Yugoslavia in iso. SRB is the code for Serbia
capdist_wc <- capdist_wc %>% 
  dplyr::mutate(cown1 = if_else(state1h == "Serbia", 345, cown1)) %>% 
  dplyr::mutate(cown2 = if_else(state2h == "Serbia", 345, cown2))

# cow name
capdist_wc$cowen1 <- countrycode(capdist_wc$cown1, origin = 'cown', destination = 'cow.name')
capdist_wc$cowen2 <- countrycode(capdist_wc$cown2, origin = 'cown', destination = 'cow.name')

# cow character
capdist_wc$cowc1 <- countrycode(capdist_wc$cown1, origin = 'cown', destination = 'cowc')
capdist_wc$cowc2 <- countrycode(capdist_wc$cown2, origin = 'cown', destination = 'cowc')
```


```{r}
## harmonized state name: english country names based on un m49
# capdist_wc$state1h <- countrycode(capdist_wc$un1, origin = 'un', destination = 'country.name')
# capdist_wc$state2h <- countrycode(capdist_wc$un2, origin = 'un', destination = 'country.name')
```

```{r}
# my own dyad naming system
capdist_wc <- capdist_wc %>%     # create an ID variable for each dyad combination
  dplyr::mutate(dyad_name = paste(state1h, state2h, sep = "_"))
```


##### descriptives
```{r}
range(capdist_wc$capdist_km) # 0-20000
hist(capdist_wc$capdist_km,100)
```

##### rescale
```{r}
capdist_wc <- capdist_wc %>% 
  mutate(capdist_10km = capdist_km/10,
         capdist_100km = capdist_km/100,
         capdist_1000km = capdist_km/1000) %>% 
  select(state1h,state2h,capdist_km,capdist_10km,capdist_100km,capdist_1000km)
```


##### labels
```{r}
# names(capdist_wc)
# add vbl labels
# library(Hmisc)
label(capdist_wc$capdist_km) <- "distance between capital cities (in km)"
label(capdist_wc$capdist_10km) <- "distance between capital cities (in 10 km)"
label(capdist_wc$capdist_100km) <- "distance between capital cities (in 100 km)"
label(capdist_wc$capdist_1000km) <- "distance between capital cities (in 1000 km)"

label(capdist_wc$state1h) <- "state1 harmonized name based on un m49"
label(capdist_wc$state2h) <- "state2 harmonized name based on un m49"
label(capdist_wc$iso1) <- "state1 iso alpha 3 country code"
label(capdist_wc$iso2) <- "state2 iso alpha 3 country code"
label(capdist_wc$un1) <- "state1 un m49 country number"
label(capdist_wc$un2) <- "state2 un m49 country number"
label(capdist_wc$dyad_name) <- "my own ID for dyad"

label(capdist_wc$cowen1) <- "state1 COW name"
label(capdist_wc$cowen2) <- "state2 COW name"
label(capdist_wc$cown1) <- "state1 COW number"
label(capdist_wc$cown2) <- "state2 COW number"
label(capdist_wc$cowc1) <- "state1 COW character"
label(capdist_wc$cowc2) <- "state2 COW character"
# Hmisc::label(capdist_wc) # check result
```


##### save 3
```{r}
# save(capdist_mat, file = "capdist_mat.RData")
# load("capdist_mat.RData")

# save(capdist_wc, file = "capdist_wc.RData")
# load("capdist_wc.RData")
```

```{r}
# View(capdist_wc)
```






<br>
<br>




  
# III) DYADIC DATA: PREP FOR NETWORK OBJECT

## III.1) Check UN members in datasets

```{r}
## UN member list
un_mlist <- un_members %>% pull(state) %>% unique() %>% sort() # 193

## nodes in cap distance
capdist_mlist <- union(capdist_wc$state1h, capdist_wc$state2h) %>% unique() %>% sort() # 193

## nodes in iat
iat_mlist <- union(iat.pcw$state1h, iat.pcw$state2h) %>% unique() %>% sort() # 179

## nodes in alliance
ally_mlist <- union(ally.pcw$state1h, ally.pcw$state2h) %>% unique() %>% sort() # 186

## nodes in conflict
conf_mlist <- union(conflict_dyad.pcw2$state1h, conflict_dyad.pcw2$state2h) %>% unique() %>% sort() # 78
```



### capdist

```{r}
## UN members not in capdist dataset
setdiff(un_mlist, capdist_mlist) # none, so all UN members are in the capdist dataset

## Entities in the ccities data set that are not UN members
setdiff(capdist_mlist, un_mlist) # none, so all nodes in the capdist dataset are UN members
```


### iat
```{r}
## UN members not in iat dataset
setdiff(un_mlist, iat_mlist) # 14 UN members missing in the iat dataset, i.e. have not participated in weapons trade since 1993

## Entities in the iat data set that are not UN members
setdiff(iat_mlist, un_mlist) # none = all iat nodes are UN members
```


### alliance
```{r}
## UN members not in alliance dataset
setdiff(un_mlist, ally_mlist) # 7 UN members missing in the iat dataset, i.e. do not have any alliances since 1993

## Entities in the alliance data set that are not UN members
setdiff(ally_mlist, un_mlist) # none = all alliance nodes are UN members
```


### conflict
```{r}
## UN members not in conflict dataset
setdiff(un_mlist, conf_mlist) # 115 UN members missing in the conflict dataset, i.e. have not experienced violent conflicts since 1993

## Entities in the conflict data set that are not UN members
setdiff(conf_mlist, un_mlist) # none = all conflict nodes are UN members
```

```{r}
## only keep UN members in dataset 
# not_members <- setdiff(df1$state, unique(df2$state))
# df1 <- df1 %>%
#   dplyr::filter(!state %in% not_members)
```

```{r}
## check for duplicates
# df1 %>% dplyr::filter(duplicated(state) | duplicated(state, fromLast = TRUE))
```


  
  As the btergm function cannot handle NAs, we need to address nodes that are present at some time spells but are missing at others.

There are two types of missing values in a matrix:
1) nodes drop in and out of the network at particular tspells
2) node did not give any information on its ties in the network (unit non-response)

There are 3 main options to handle missings. First, they are replaced by the modal value (usually 0). Secondly, nodes with incomplete edge profiles (i.e. having a missing value in one of the matrices) are removed from the dataset. Finally, missings are imputed according to established strategies from the literature.

The first option, i.e. replacing missings with 0, makes sense in situations where one can assume that all present edges will be observed, though we may not have a specific recording of 0 for absent edges. (Leitfeld et al 2018: 16)

This is arguably the case for arms transfer, conflict and alliance networks. For events as big and important as conflict occurrences and alliance agreements, there is no reason to assume that existing ties are not recorded in the data. As for arms transfer: there might indeed exist instances of weapons being traded in secret, but the likelihood of any major transfers going unnoticed and therefore not being recorded in the SIPRI dataset is unlikely. I will argue that any such undocumented deliveries, small enough to be overlooked by the SIPRI data collecting efforts, are negligible in the analysis.

There are no NA coded values in the iat, conflict and alliance matrices. Consequently, any dyads not recorded in the matrices will be added and imputed with 0 to present absent edges, i.e. isolates.



## III.2) Aggregate data to dyad-t level

```{r}
# delete original country names (they are not harmonized, i.e. they differ between data sets)
# iat.pcw <- iat.pcw %>% dplyr::select(-c(state1,state2))
```


### a) iat dyads

The data is already on the dyad-year level (million tiv per year), so we'll proceed to aggregate it from yearly to 5-year level.

```{r}
## OLD CODE: aggregate to dyad-year level (from dyad-delivery level)
# iat_year_agg <- iat.pcw %>%
#   dplyr::select(-c(categories:local_production)) %>%
#   group_by(iso1, iso2, un1, un2, state1h, state2h, dyad_name, t, year) %>%
#   dplyr::summarise(
#     tiv = sum(tiv, na.rm = T), # yearly total tiv
#     category = paste(unique(category), collapse = ", ")
#     ) %>% 
#   dplyr::select(state1h,state2h, tiv, everything()) %>% 
#   dplyr::arrange(year) %>% 
#   ungroup()
```

```{r}
library(dplyr)
names(iat.pcw)

# aggregated to dyad-t (from dyad-year level)
# iat_t_agg <- iat_year_agg %>%
iat_t_agg <- iat.pcw %>%
  group_by(iso1, iso2, un1, un2, cown1, cown2, state1h, state2h, dyad_name, t) %>%
  dplyr::summarise(
    tiv = mean(tiv, na.rm = T), # av. yearly tiv during t
    # category = paste(unique(category), collapse = ", ")
    ) %>% 
  dplyr::select(state1h,state2h,tiv,t,everything()) %>% 
  dplyr::arrange(t,state1h,state2h) %>% 
  ungroup()
```
@nga: 4769 dyads

```{r}
label(iat_t_agg$tiv) <- "av. yearly total tiv (in million) during t"
```


Examine
```{r}
# OLD CODE: By delivery-year
# iat.pcw %>% 
#   dplyr::select(-c(categories:local_production)) %>% 
#   dplyr::filter(dyad_name == "Germany-Israel") %>% 
#   dplyr::select(dyad_name,year,tiv,everything())
# # We see that in 2000, Germany made 3 weapons delivieries to Israel, with an estimated trend indicator value of 250, 6 and 15 respectively

# OLD CODE: By dyad-year
iat_year_agg %>%
  dplyr::filter(dyad_name == "Germany-Israel") %>%
  dplyr::select(dyad_name,year,tiv,everything())
# We see now that the delivery values for 2000 were summed up together, i.e. tiv = 271
# # We see that in 2000, Germany made 3 weapons delivieries to Israel (deal_ids = 25546, 37437, 28948), with an estimated trend indicator value (tiv) of 271
```

```{r}
library(magrittr)
library(dplyr)
library(tidyr)
# By dyad-t
iat_t_agg %>% 
  dplyr::filter(dyad_name == "Germany_Israel") %>% 
  dplyr::select(dyad_name,t,tiv,everything())
# We see that after the end of the cold war, Germany delivered weapons with the highest value during the t5 time period, with a tiv of ca. 172 million tiv
tspells[[5]] # which is 2013-2017
```





### b) alliance dyads


The data is already on the dyad-year level (number of active alliances), so we'll proceed to aggregate it to dyad-t level.
```{r}
# library(dplyr)
# aggregated to dyad-t (from dyad-year level)
alliance_t_agg <- ally.pcw %>%
  dplyr::select(-dyad_atop) %>%
  group_by(iso1, iso2, un1, un2, cown1, cown2, state1h, state2h, dyad_name, t) %>%
  dplyr::summarise(
    number = mean(number, na.rm = T)) %>% # av. yearly number of alliances (bilat & multilat) during t
  dplyr::select(state1h,state2h,number,t,everything()) %>% 
  dplyr::arrange(t,state1h,state2h) %>% 
  ungroup()
```

```{r}
label(alliance_t_agg$number) <- "av. yearly number of alliances (bilat & multilat) during t"
```

Examine
```{r}
# Before aggregation
ally.pcw %>% 
  dplyr::filter(dyad_name == "France_Germany") %>% 
  dplyr::select(state1h, year, number, everything())
# We see that France and Germany have only 26 out of 31 possible entries. There are missing records for 2019-2023. This is not a problem, however, as we are aggregating the data to t-level. E.g. for t6 (2018-23), we will use the average value of active alliance agreements during this period. This means that it is enough to have information for one of the years within 2017-2023. In France and Germany's case, we have data for the year 2018, whose average will be used as data for the whole t6 time spell.

# By dyad-t
alliance_t_agg %>% 
  dplyr::filter(dyad_name == "France_Germany") %>% 
  dplyr::select(dyad_name,t,number, everything())
# We see for t6, the number of active alliances was estimated as 4.
```



### c) conflict dyads

The data is already on dyad-year level (how many armed conflicts did the dyad engaged in in a given year?)
```{r}
# delete original country names (they are not harmonized, i.e. they differ between data sets)
# conflict_dyad.pcw2 <- conflict_dyad.pcw2 %>% dplyr::select(-c(state1,state2))
```

#### descriptives
```{r}
conflict_dyad.pcw2 %>% 
  dplyr::filter(state1h == "Iraq" | state2h == "Iraq") %>% 
  dplyr::select(state1h, state2h, year, everything())
# e.g. Iraq was fighting against Australia, UK and US in 2003
```

```{r}
# library(sjmisc)
frq(conflict_dyad.pcw2$incompatibility) # during pCW period, ca 33% of the dyads are in a conflict due to territorial issues. ca 67% of the dyads fight due to political issues. 
frq(conflict_dyad.pcw2$intensity) # ca 47 % of the dyads have a minor violent conflict, while the other 53 % fight in an all out war (min. 1000 deaths)
frq(conflict_dyad.pcw2$type_of_conflict) # ca. 80% are intrastate (civil) conflict with foreign intervention, which ca 20% interstate (international) conflict.

# Initially this variable had 4 categories, inc. intrastate conflict without foreign intervention and extrasystamic conflict. But theses categories had too little cases (e.g. 1% for incompatibility third category), they do not feature in the data (i.e. thus categories of no use for explanatory purposes)
```
Note that for the period 1993-2023, there were no extra-systemic conflicts. In 96% of the cases, violent conflicts were not carried out between nation states. Almost all of the militarized conflicts during this period were intrastate ones, the only difference being whether foreign parties' were involved in the conflict or not.

@nga: additional infos
-   in the last 5 years of CW, 24% of conflicts are civil wars, while 76% of conflicts were between states
-   after end of CW, the ratio between civil and international conflicts reversed. Now, the percentage of interstate conflicts decreased relatively to 23% while that of civil conflicts increased to 77%.
-   Note that for the period 1993-2023, there were no extra-systemic conflicts or civil conflicts with no foreign intervention. In 96% of the cases, violent conflicts were not carried out between nation states. Almost all of the militarized conflicts during this period were intrastate ones, the only difference being whether foreign parties' were involved in the conflict or not.

```{r}
conflict_dyad.pcw2 %>% 
  dplyr::filter(state1h == "United States" | state2h == "United States") %>%
  dplyr::select(state1h, state2h, incompatibility, intensity, type_of_conflict)
```
@nga: USA in 3 wars and 4 minor militarized conflicts. Serbia vs US was about territory, the rest are political conflicts


#### aggregate
```{r}
# library(dplyr)
# aggregated by dyad-year
conflict_t_agg <- conflict_dyad.pcw2 %>%
  dplyr::select(-c(conflict_id,dyad_id)) %>%
  dplyr::group_by(iso1, iso2, un1, un2, cown1, cown2, state1h, state2h, dyad_name, t) %>%
  dplyr::summarise(
    n_years = n(), # duration of conflict during t (in years)
    intensity = round(mean(intensity, na.rm = T),3), # between 0-1. 0 = only minor incidences in all conflict years; 1 = war in all conflict years. The closer to 1, the more intense the conflict
    y_war = round((intensity * n_years),0), # dyad involved in war how many years during t
    y_minor = round((n_years - y_war),0), # dyad involved in minor conflict how many years during t
    d_war = ifelse(mean(intensity, na.rm = T)>0,1,0), # dyad involved in war, dummy
    d_minor = ifelse(mean(intensity, na.rm = T)<1,1,0), # dyad involved in minor conflict, dummy
    
    issue = round(mean(incompatibility, na.rm = T),3), # 0 = dyad involved in conflicts due to pol issues, >0 = dyad involved in min. a conflict due to territory in t
    y_ter = round((issue * n_years),0), # dyad involved in territorial conflict how many years during t
    y_pol = round((n_years - y_ter),0), # dyad involved in political conflict how many years during t during t
    d_ter = ifelse(mean(incompatibility, na.rm = T)>0,1,0), # dyad involved in conflict(s) due to territory issue, dummy
    d_pol = ifelse(mean(incompatibility, na.rm = T)<1,1,0), # dyad involved in conflict(s) due to political issue, dummy
    types = paste(as.character(type_of_conflict), collapse = ", "), # which types of conflict(s) was dyad involved in during t?
    location = paste(unique(location), collapse = ", ")) %>%
  dplyr::select(state1h,state2h,n_years,t,y_war,y_minor,d_war,d_minor,issue,y_ter,y_pol,d_ter,d_pol,types,location,everything()) %>% 
  dplyr::arrange(t,state1h,state2h) %>% 
  ungroup()
```

#### label
```{r}
# add vbl labels
# library(Hmisc)
label(conflict_t_agg$n_years) <- "duration of conflict during t (in years)"
label(conflict_t_agg$types) <- "1=interstate, 0=intrastate with foreign intervention"
label(conflict_t_agg$y_ter) <- "years fought due to territory issue"
label(conflict_t_agg$y_pol) <- "years fought due to government issue"
label(conflict_t_agg$d_ter) <- "involved in conflict about territory issue yes/no"
label(conflict_t_agg$d_pol) <- "involved in conflict about government issue yes/no"
label(conflict_t_agg$y_minor) <- "years fought in minor conflicts (25-999 deaths)"
label(conflict_t_agg$y_war) <- "years fought in wars (min. 1000 deaths)"
label(conflict_t_agg$d_minor) <- "involved in minor conflict, yes/no"
label(conflict_t_agg$d_war) <- "involved in war, yes/no"
label(conflict_t_agg$issue) <- "0 = only conflicts due to pol issue(s), >0 = min. in one year fighting due to ter issue"
label(conflict_t_agg$intensity) <- "between 0-1; 0 = only minor incidences (<1000 deaths) during all conflict years; 1 = war in all conflict years (<=1000 deaths). The closer to 1, the more intense the conflict during t (max 5-6 years)"
label(conflict_t_agg$location) <- "location of fightings"
```


#### check

```{r}
conflict_dyad.pcw2 %>% 
  group_by(iso1, iso2, un1, un2, state1h, state2h, dyad_name, t) %>% 
  dplyr::summarise(
    n = n()) %>% 
  dplyr::select(dyad_name, n, everything()) %>% 
  View()

View(conflict_dyad.pcw2)
View(conflict_t_agg)
```




### d) distance dyads

Data stays the same over time, so no country-year observations necessary i.e. available. So we'll use the same adjacency matrix for capital distance as an edge covariate for each time spell. We'll just copy the cap distance data 6x later.



### save
```{r}
# save(iat_t_agg, file = "iat_t_agg.RData")
load("iat_t_agg.RData")

# save(alliance_t_agg, file = "alliance_t_agg.RData")
load("alliance_t_agg.RData")

# save(conflict_t_agg, file = "conflict_t_agg.RData")
load("conflict_t_agg.RData")
```




## III.3) Edge lists

```{r}
# load("iat_t_agg.RData") # arms transfer edges
# load("alliance_t_agg.RData") # alliance edges
# load("conflict_t_agg.RData") # conflict edges
# load("capdist_wc.RData") # capdist edges
```

### descriptives for 3x networks
```{r}
## DON'T USE; BIASED
## iat = continuous measure
# av. yearly trend indicator value of arms transfer delivery
# iat.value <- iat_t_agg %>% pull(tiv)
# mean(iat.value) # 42
# median(iat.value) # 11
# hist(iat.value, 100)
# range(iat.value) # dyads with up to 2365 million tiv worth of arms trade
# 
# iat.value_sub <- as.data.frame(iat.value) %>% 
#   dplyr::filter(iat.value <= 300) %>% 
#   hist()
```

```{r}
## USE THIS
iat.value <- iat.pcw %>% pull(tiv)
mean(iat.value) # 67
median(iat.value) # 13
hist(iat.value, 100)
range(iat.value) # dyads with up to 3830 million tiv worth of arms trade per year
```

```{r}
## alliance = count measure
# number of alliances
alliance.value <- ally.pcw %>% pull(number) 
mean(alliance.value) # 1.5
median(alliance.value) # 1, alles andere ist mehr als 1
frq(alliance.value)
range(alliance.value) # dyads with up to 9 active alliance agreements
```

```{r}
## conflict = count measure
# duration of conflict (in years) during t
conf.value <- conflict_t_agg %>% pull(n_years) 
mean(conf.value) # 2 years
median(conf.value) #  year
frq(conf.value)
range(conf.value) # dyads in conflict(s) between 1-6 years within one 5-6 years time spell
```

### 4x edge lists, all t
```{r}
iat_el <- iat_t_agg %>%
  # ungroup() %>%
  dplyr::select(state1h,state2h,tiv,t) %>%
  dplyr::rename(weight = tiv) # av. yearly trend indicator value of arms transfer delivery during t

alliance_el <- alliance_t_agg %>% 
  # ungroup() %>%
  dplyr::select(state1h,state2h,number,t) %>% 
  dplyr::rename(weight = number) # av. yearly number of active alliance agreements during t

conflict_el <- conflict_t_agg %>% 
  # ungroup() %>%
  dplyr::select(state1h,state2h,n_years,t) %>% 
  dplyr::rename(weight = n_years) # duration of conflict (in years) during t
```

No separation of cap dist edge list by t necessary, since the capital distances of all states stay the same between 1993-2023.
```{r}
capdist_el <- capdist_wc %>% 
  # # ungroup() %>%
  # dplyr::select(state1h,state2h,capdist_km,capdist_10km,capdist_100km,capdist_1000km)

capdist_el <- capdist_wc %>%
  dplyr::select(state1h,state2h,capdist_km) %>% 
  dplyr::rename(weight = capdist_km) 
capdist_el10 <- capdist_wc %>%
  dplyr::select(state1h,state2h,capdist_10km) %>%
  dplyr::rename(weight = capdist_10km) 
capdist_el100 <- capdist_wc %>%
  dplyr::select(state1h,state2h,capdist_100km) %>%
  dplyr::rename(weight = capdist_100km)
capdist_el1000 <- capdist_wc %>%
  dplyr::select(state1h,state2h,capdist_1000km) %>% 
  dplyr::rename(weight = capdist_1000km)
```



Explore
```{r}
## during t:
mean(iat_el$weight) # 42 million tiv
mean(alliance_el$weight) # 1.5 active alliance agreements
mean(conflict_el$weight) # 2 conflict years duration
```




### 3x edge list by t

```{r}
# Create a list with iat data frames for t1-t6
iat_list <- split(iat_el, iat_el$t) 
iat_list <- lapply(iat_list, function(i) {
  dplyr::select(i, -t)
})
iat_list

```

```{r}
# Create a list with alliance data frames for t1-t6
alliance_list <- split(alliance_el, alliance_el$t)
alliance_list <- lapply(alliance_list, function(i) {
  dplyr::select(i, -t)
})
alliance_list

```

```{r}
# Create a list with conflict data frames for t1-t6
conflict_list <- split(conflict_el, conflict_el$t)
conflict_list <- lapply(conflict_list, function(i) {
  dplyr::select(i, -t)
})
conflict_list

```


No need to store capdist data frames for each time spell, since the distance between capitals remains the same between 1993-2023. 


### save
```{r}
## EDGE LIST 1993-2023
# save(iat_el, file = "iat_el.RData") # as R data file
# load("iat_el.RData")
# save(alliance_el, file = "alliance_el.RData") # as R data file
# load("alliance_el.RData") 
# save(conflict_el, file = "conflict_el.RData") # as R data file
# load("conflict_el.RData")

# save(capdist_el, file = "capdist_el.RData") # as R data file
# load("capdist_el.RData") 
# save(capdist_el10, file = "capdist_el10.RData") # as R data file
# load("capdist_el10.RData") 
# save(capdist_el100, file = "capdist_el100.RData") # as R data file
# load("capdist_el100.RData") 
# save(capdist_el1000, file = "capdist_el1000.RData") # as R data file
# load("capdist_el1000.RData") 

## EDGE LISTS SEPARATED BY T
# save(iat_list, file = "iat_list.RData") # as R data file
# load("iat_list.RData") 
# save(alliance_list, file = "alliance_list.RData") # as R data file
# load("alliance_list.RData") 
# save(conflict_list, file = "conflict_list.RData") # as R data file
# load("conflict_list.RData") 
```




## III.4) Adjacency matrices (weighted & binary)

### iat

```{r}
library(igraph)

# Initialize empty lists to store the adjacency matrices
iat_adj_weight <- list()
iat_adj_binary <- list()

# Loop over each edge list in iat_list
for(i in 1:length(iat_list)) {
  # Convert the edge list to a graph
  g <- igraph::graph_from_data_frame(iat_list[[i]], directed = T)
  
  # Convert the graph to a weighted adjacency matrix
  adj_weight <- igraph::as_adjacency_matrix(g, attr = "weight")
  adj_weight <- round(adj_weight, 4) # round to 2 decimals
  
  # Create a binary matrix version
  adj_binary <- adj_weight
  adj_binary[adj_binary != 0] <- 1
  
  # Save the adjacency matrices to lists
  iat_adj_weight[[names(iat_list)[i]]] <- adj_weight
  iat_adj_binary[[names(iat_list)[i]]] <- adj_binary
}
```

#### check iat adj
```{r}
View(as.matrix(iat_adj_weight$t1))
View(as.matrix(iat_adj_binary$t1))

View(as.matrix(iat_adj_weight$t6))
View(as.matrix(iat_adj_binary$t6))
```





### alliance

```{r}
# library(igraph)

# Initialize empty lists to store the adjacency matrices
alliance_adj_weight <- list()
alliance_adj_binary <- list()

# Loop over each edge list in alliance_list
for(i in 1:length(alliance_list)) {
  # Convert the edge list to a graph
  g <- igraph::graph_from_data_frame(alliance_list[[i]], directed = F)
  
  # Convert the graph to a weighted adjacency matrix
  adj_weight <- igraph::as_adjacency_matrix(g, attr = "weight")
  adj_weight <- round(adj_weight, 4) # round to 2 decimals
  
  # Create a binary matrix version
  adj_binary <- adj_weight
  adj_binary[adj_binary != 0] <- 1
  
  # Save the adjacency matrices to lists
  alliance_adj_weight[[names(alliance_list)[i]]] <- adj_weight
  alliance_adj_binary[[names(alliance_list)[i]]] <- adj_binary
}

```

#### check alliance adj
```{r}
View(as.matrix(alliance_adj_weight$t1))
View(as.matrix(alliance_adj_binary$t1))

View(as.matrix(alliance_adj_weight$t6))
View(as.matrix(alliance_adj_binary$t6))
```




### conflict
```{r}
# library(igraph)

# Initialize empty lists to store the adjacency matrices
conflict_adj_weight <- list()
conflict_adj_binary <- list()

# Loop over each edge list in conflict_list
for(i in 1:length(conflict_list)) {
  # Convert the edge list to a graph
  g <- igraph::graph_from_data_frame(conflict_list[[i]], directed = F)
  
  # Convert the graph to a weighted adjacency matrix
  adj_weight <- igraph::as_adjacency_matrix(g, attr = "weight")
  adj_weight <- round(adj_weight, 4) # round to 2 decimals
  
  # Create a binary matrix version
  adj_binary <- adj_weight
  adj_binary[adj_binary != 0] <- 1
  
  # Save the adjacency matrices to lists
  conflict_adj_weight[[names(conflict_list)[i]]] <- adj_weight
  conflict_adj_binary[[names(conflict_list)[i]]] <- adj_binary
}


```

#### check conflict adj
```{r}
View(as.matrix(conflict_adj_weight$t1))
View(as.matrix(conflict_adj_binary$t1))

View(as.matrix(conflict_adj_weight$t6))
View(as.matrix(conflict_adj_binary$t6))
```





### capdist

```{r}
# load("capdist_wc.RData")
# load("capdist_el.RData")
# load("capdist_el10.RData")
# load("capdist_el100.RData")
# load("capdist_el1000.RData")
```


Since capital distance data remains static, provide a matrix object for btergm later.
```{r}
# 1km
capdist_mat <- igraph::graph_from_data_frame(capdist_el, directed = F)
capdist_mat <- igraph::as_adjacency_matrix(capdist_mat, attr = "weight")
capdist_mat <- as.matrix(capdist_mat) # all 193 countries
# load("capdist_mat.RData")
```

```{r}
# 10 km
capdist_mat10 <- igraph::graph_from_data_frame(capdist_el10, directed = F)
capdist_mat10 <- igraph::as_adjacency_matrix(capdist_mat10, attr = "weight")
capdist_mat10 <- as.matrix(capdist_mat10)
```

```{r}
# 100km
capdist_mat100 <- igraph::graph_from_data_frame(capdist_el100, directed = F)
capdist_mat100 <- igraph::as_adjacency_matrix(capdist_mat100, attr = "weight")
capdist_mat100 <- as.matrix(capdist_mat100)
```

```{r}
# 1000km
capdist_mat1000 <- igraph::graph_from_data_frame(capdist_el1000, directed = F)
capdist_mat1000 <- igraph::as_adjacency_matrix(capdist_mat1000, attr = "weight")
capdist_mat1000 <- as.matrix(capdist_mat1000)
```

```{r}
hist(capdist_wc$capdist_100km,500)
```


### save
```{r}
# save(iat_adj_binary, file = "iat_adj_binary.RData")
# load("iat_adj_binary.RData")
# save(iat_adj_weight, file = "iat_adj_weight.RData")
# load("iat_adj_weight.RData")

# save(alliance_adj_binary, file = "alliance_adj_binary.RData")
# load("alliance_adj_binary.RData")
# save(alliance_adj_weight, file = "alliance_adj_weight.RData")
# load("alliance_adj_weight.RData")

# save(conflict_adj_binary, file = "conflict_adj_binary.RData")
# load("conflict_adj_binary.RData")
# save(conflict_adj_weight, file = "conflict_adj_weight.RData")
# load("conflict_adj_weight.RData")

# save(capdist_mat, file = "capdist_adj_weight.RData")
# load("capdist_mat.RData")
# save(capdist_mat10, file = "capdist_adj_weight10.RData")
# load("capdist_mat10.RData")
# save(capdist_mat100, file = "capdist_adj_weight100.RData")
# load("capdist_mat100.RData")
# save(capdist_mat1000, file = "capdist_adj_weight1000.RData")
# load("capdist_mat1000.RData")
```



## III.5) harmonize/impute matrix dim across t (only weighted matrices)


We'll harmonize the dimensions of matrices across time spells

#### iat

@nga: 
I have three list of networks that I want to use in a tergm. The elements in these network lists are of the statnet network class. All 3 lists contain 6 elements respectively, representing the networks at 6 time spells at t1, t2, t3, t4, t5, t6. The first list "arms_transfer_list" contains 6 "iat_snet" network objects at the 6 time spells and will be the target networks whose tie probabilities will be estimated in the tergm. The second list, "conflict_list", contains 6 “conflict_snet” network objects at the 6 time spells and the third list, “alliance_list” contains 6 "alliance_snet” network objects at the 6 time spells. Each of the 6 network objects stored in a network list represent the network at a different time spell which are in consecutive temporal order. The alliance_snet and conflict_snet network objects will be used as dyad-level terms (using edgecov()) to predict ties of the iat_snet networks.

However, the network objects in the "conflict_list" and  “alliance_list” have different dimensions than the target network objects in the arms_transfer_list. I want a code in R to prepare the dyad-level covariate network objects "alliance_snet" and "conflict_snet" stored in the “alliance_list” and "conflict_list" to have the same dimensions as their corresponding elements numbered from 1 to 6 in the target "arms_transfer_list". The output should be 3 lists of networks “arms_transfer_list_t”, “conflict_list_t” and “alliance_list_t”, each containing 6 network objects at the 6 different time spells but now the dimesions of the 3 networks at each time spell align. This format should be usable in a tergm.

The following loop  will deal with the network objects elements of the arms_transfer_list, conflict_list and alliance_list for each time spell successively in an ascending order from t1 to t6. 


The loop includes: 

(First operation: turn all the elements (i.e. network objects) of the three network lists into adjacency matrices and store them in 3 lists called “iat_adj”, “conflict_adj” and “alliance_adj”, each containing 6 adjacency matrices corresponding to the networks at different time spells. The adjacency matrices stored in the “iat_adj” list are named iat_adj_t1, iat_adj_t2…iat_adj_t6. The adjacency matrices stored in the “conflict_adj” list are named conflict_adj_t1, conflict_adj_t2 … conflict_adj_t6. The adjacency matrices stored in the “alliance_adj” list are named alliance_adj_t1, alliance_adj_t2 … alliance_adj_t6.)

Then, create 3 empty lists “iat_adj_imp”, “alliance_adj_imp” and conflict_adj_imp”.

Second operation: In a loop: for all 6 iat_adj adjacency matrices, i.e. at all time spells combined, identify all unique nodes names (i.e. nodes with at least one present tie with another node) and save them as a vector called “iat_active”. Check in iat_adj matrix at t1 whether a node stored in “iat_active” is missing from the iat_adj matrix at t1. Add those missing nodes to the iat_adj matrix at t1. The newly added nodes are coded as an isolate, i.e. it receives the value 0 for all its cells crossing with other nodes to represent absent edges. Store the newly imputed adjacency matrices in the new lists “iat_adj_imp”. Repeat the process for the iat_adj matrices at the remaining 5 time spells in successive order. The output “iat_adj_imp” contains all 6 imputed iat adjacency matrices.

= adding missing nodes from one tspell to another as isolates = nodes that enter and exit between the 6 time spells


```{r}
## DIMENSION ADJUSTED TO UN MEMBER LIST
# Save names of all active nodes in iat network 1993-2023
# iat_active <- union(iat_t_agg$state1h, iat_t_agg$state2h) %>% sort() # @nga: 179 active countries
# save(iat_active, file = "iat_active.RData")
# load("iat_active.RData")

# Create empty list to store the imputed adjacency matrices
iat_adj_imp <- list()
iat_adj_imp_df <- list()

# Loop over the arms transfer adj matrices and harmonize dimensions between all time spells, i.e. adding missing nodes from one tspell to another as isolates = nodes that enter and exit
for (i in 1:6) {
  
  # identify missing nodes
  missing_nodes <- setdiff(un_mlist, rownames(iat_adj_weight[[i]]))
  
  # create matrix
  iat_adj_imp[[i]] <- rbind(
    cbind(iat_adj_weight[[i]], 
          matrix(0, 
                 nrow = nrow(iat_adj_weight[[i]]), 
                 ncol = length(missing_nodes))), 
    cbind(matrix(0, 
                 nrow = length(missing_nodes), 
                 ncol = ncol(iat_adj_weight[[i]])), 
          matrix(0, 
                 nrow = length(missing_nodes), 
                 ncol = length(missing_nodes))))
  
  rownames(iat_adj_imp[[i]]) <- colnames(iat_adj_imp[[i]]) <- c(rownames(iat_adj_weight[[i]]), missing_nodes)
  
  # Convert sparse matrix to regular matrix
  iat_adj_imp[[i]] <- as.matrix(iat_adj_imp[[i]])
  
  # Convert to a data frame
  iat_adj_imp_df[[i]] <- as.data.frame(iat_adj_imp[[i]])
}
```


##### check

```{r}
# inspect
rownames(iat_adj_imp[[i]])
# dimnames(iat_adj_imp_df[[i]]) 
dim(iat_adj_imp_df[[i]]) # 193 x 193 matrix
iat_adj_imp_df[[i]]
```

```{r}

# dimensions of original matrices
iat_dim_original <- vector()
for (i in 1:6) {
  dim <- nrow(iat_adj_weight[[i]])
  iat_dim_original[[i]] <- dim
}

# dimensions of imputed matrices
iat_dim_imputed <- vector()
for (i in 1:6) {
  dim <- nrow(iat_adj_imp[[i]])
  iat_dim_imputed[[i]] <- dim
}

```

```{r}
# compare
par(c(1,1))
iat_dim_original
iat_dim_imputed
```

@nga: Originally, the dimensions of the 6 iat matrices are: 144 138 147 154 152 167. We see that the dimensions of the 6x iat adj matrices grew to 193 after adding isolate nodes from the UN members list across all time spells.

However, the number of non-zero entries in the original and imputed adj matrices should be the same:

```{r}
library(Matrix)

# count the non-zero entries in the original matrices
iat_ties_original <- vector()
for (i in 1:length(iat_adj_weight)) {
  iat_ties_original[i] <- nnzero(iat_adj_weight[[i]])
}

# count the non-zero entries in the imputed matrices
iat_ties_imputed <- vector()
for (i in 1:length(iat_adj_imp)) {
  iat_ties_imputed[[i]] <- nnzero(iat_adj_imp[[i]])
}
```

```{r}
# compare
par(c(1,1))
iat_ties_original
iat_ties_imputed
```

@nga: Looks good, i.e. the same! The non-zero entries in both the 6x original and imputed matrices are: 653 696 720 848 948 976.
Even though the dimensions of the original adjacency matrix and the imputed one differ, both still record the same present ties between nodes. So any additional nodes in the imputed matrix received a 0 value.



```{r}
iat_adj_imp[1]
```


#### alliance
@nga: Fourth operation: Repeat the second operation, but this time using the 6 alliance_adj adjacency matrices as input instead of the iat_adj matrices. Store the imputed conflict adjacency matrices in the alliance_adj_imp” list.

```{r}
# # Save names of all active nodes in alliance network 1993-2023
# alliance_active <- union(alliance_t_agg$state1h, alliance_t_agg$state2h) %>% sort() # @nga: 190 active

# Create empty list to store the imputed adjacency matrices
alliance_adj_imp <- list()
alliance_adj_imp_df <- list()

# Loop over the alliance adj matrices and harmonize dimensions between all time spells, i.e. adding missing nodes from one tspell to another as isolates
for (i in 1:6) {
  
  # identify missing nodes
  missing_nodes <- setdiff(un_mlist, rownames(alliance_adj_weight[[i]]))
  
  # create matrix
  alliance_adj_imp[[i]] <- rbind(
    cbind(alliance_adj_weight[[i]], 
          matrix(0, 
                 nrow = nrow(alliance_adj_weight[[i]]), 
                 ncol = length(missing_nodes))), 
    cbind(matrix(0, 
                 nrow = length(missing_nodes), 
                 ncol = ncol(alliance_adj_weight[[i]])), 
          matrix(0, 
                 nrow = length(missing_nodes), 
                 ncol = length(missing_nodes))))
  
  rownames(alliance_adj_imp[[i]]) <- colnames(alliance_adj_imp[[i]]) <- c(rownames(alliance_adj_weight[[i]]), missing_nodes)
  
  # Convert sparse matrix to regular matrix
  alliance_adj_imp[[i]] <- as.matrix(alliance_adj_imp[[i]])
  
  # Convert to a data frame
  alliance_adj_imp_df[[i]] <- as.data.frame(alliance_adj_imp[[i]])
}

```

##### check

```{r}
# inspect
rownames(alliance_adj_imp[[i]])
# dimnames(alliance_adj_imp_df[[i]]) 
dim(alliance_adj_imp_df[[i]]) # 193 x 193 matrix
alliance_adj_imp_df[[i]]
```

```{r}

# dimensions of original matrices
alliance_dim_original <- vector()
for (i in 1:6) {
  dim <- nrow(alliance_adj_weight[[i]])
  alliance_dim_original[[i]] <- dim
}

# dimensions of imputed matrices
alliance_dim_imputed <- vector()
for (i in 1:6) {
  dim <- nrow(alliance_adj_imp[[i]])
  alliance_dim_imputed[[i]] <- dim
}
```

```{r}
# compare
par(c(1,1))
alliance_dim_original
alliance_dim_imputed
```
@nga: dimension of the 6x alliance matrices originally: 165 181 185 186 186 186.
We see that the dimensions of the alliance adj matrices grew to 193 after harmonizing the entry of nodes across time spells as well as with the active nodes' entries in the iat & alliance networks.

However, the number of non-zero entries in the original vs imputed adj matrices should be the same:
```{r}
# library(Matrix)
# non-zero entries in original matrices
alliance_ties_original <- vector()
for (i in 1:6) {
  dim <- nrow(which(alliance_adj_weight[[i]] != 0, arr.ind = TRUE))
  alliance_ties_original[[i]] <- dim
}

# non-zero entries in imputed matrices
alliance_ties_imputed <- vector()
for (i in 1:6) {
  dim <- nrow(which(alliance_adj_imp[[i]] != 0, arr.ind = TRUE))
  alliance_ties_imputed[[i]] <- dim
}
```

```{r}
# compare
par(c(1,1))
alliance_ties_original
alliance_ties_imputed
```

@nga: Looks good, i.e. the same! Non-zero entries of original and imputed matrices: 4714 7244 7770 8134 8452 8456. Even though the dimensions of the original adjacency matrix and the imputed one differ, both still record the same present ties between nodes. So any additional nodes in the imputed matrix received a 0 value.



#### conflict

@nga: Third operation: Repeat the second operation, but this time using the 6 conflict_adj adjacency matrices as input instead of the iat_adj matrices. Store the imputed conflict adjacency matrices in the conflict_adj_imp” list.
```{r}
# Save names of all active nodes in conflict network 1993-2023
# conflict_active <- union(conflict_t_agg$state1h, conflict_t_agg$state2h) %>% sort() # @nga: 71 active
# save(conflict_active, file = "conflict_active.RData")
# load("conflict_active.RData")

# Create empty list to store the imputed adjacency matrices
conflict_adj_imp <- list()
conflict_adj_imp_df <- list()

# Loop over the arms transfer adj matrices and harmonize dimensions between all time spells, i.e. adding missing nodes from one tspell to another as isolates
for (i in 1:6) {
  
  # identify missing nodes
  missing_nodes <- setdiff(un_mlist, rownames(conflict_adj_weight[[i]]))
  
  # create matrix
  conflict_adj_imp[[i]] <- rbind(
    cbind(conflict_adj_weight[[i]], 
          matrix(0, 
                 nrow = nrow(conflict_adj_weight[[i]]), 
                 ncol = length(missing_nodes))), 
    cbind(matrix(0, 
                 nrow = length(missing_nodes), 
                 ncol = ncol(conflict_adj_weight[[i]])), 
          matrix(0, 
                 nrow = length(missing_nodes), 
                 ncol = length(missing_nodes))))
  
  rownames(conflict_adj_imp[[i]]) <- colnames(conflict_adj_imp[[i]]) <- c(rownames(conflict_adj_weight[[i]]), missing_nodes)
  
  # Convert sparse matrix to regular matrix
  conflict_adj_imp[[i]] <- as.matrix(conflict_adj_imp[[i]])
  
  # Convert to a data frame
  conflict_adj_imp_df[[i]] <- as.data.frame(conflict_adj_imp[[i]])
}

```


##### check

```{r}
# inspect
rownames(conflict_adj_imp[[i]]) # 193 x 193 matrix
# dimnames(conflict_adj_imp_df[[i]]) 
dim(conflict_adj_imp_df[[i]]) 
conflict_adj_imp_df[[i]]
```

```{r}

# dimensions of original matrices
conflict_dim_original <- vector()
for (i in 1:6) {
  dim <- nrow(conflict_adj_weight[[i]])
  conflict_dim_original[[i]] <- dim
}

# dimensions of imputed matrices
conflict_dim_imputed <- vector()
for (i in 1:6) {
  dim <- nrow(conflict_adj_imp[[i]])
  conflict_dim_imputed[[i]] <- dim
}

```

```{r}
# compare
par(c(1,1))
conflict_dim_original
conflict_dim_imputed
```

@nga: dimension of the 6x conflict matrices originally: 19 38 11 13 23 35.
We see that the dimensions of the conflict adj matrices grew to 193 after harmonizing the entry of nodes across time spells as well as with the active nodes' entries in the iat & alliance networks.

However, the number of non-zero entries in the original vs imputed adj matrices should be the same:
```{r}
# non-zero entries in original matrices
conflict_ties_original <- vector()
for (i in 1:6) {
dim <- nrow(which(conflict_adj_weight[[i]] != 0, arr.ind = TRUE))
conflict_ties_original[[i]] <- dim
}

# non-zero entries in imputed matrices
conflict_ties_imputed <- vector()
for (i in 1:6) {
dim <- nrow(which(conflict_adj_imp[[i]] != 0, arr.ind = TRUE))
conflict_ties_imputed[[i]] <- dim
}

```

```{r}
# compare
par(c(1,1))
conflict_ties_original
conflict_ties_imputed
```

@nga: Looks good, i.e. the same! Non-zero entries are for both original and imputed data: 28 74 14 14 36 64. Even though the dimensions of the original adjacency matrix and the imputed one differ, both still record the same present ties between nodes. So any additional nodes in the imputed matrix received a 0 value.


#### save
```{r}
# save(iat_adj_imp, file = "iat_adj_imp.RData")
# load("iat_adj_imp.RData")
# save(iat_adj_imp_df, file = "iat_adj_imp_df.RData")
# load("iat_adj_imp_df.RData")

# save(alliance_adj_imp, file = "alliance_adj_imp.RData")
# load("alliance_adj_imp.RData")
# save(alliance_adj_imp_df, file = "alliance_adj_imp_df.RData")
# load("alliance_adj_imp_df.RData")

# save(conflict_adj_imp, file = "conflict_adj_imp.RData")
# load("conflict_adj_imp.RData")
# save(conflict_adj_imp_df, file = "conflict_adj_imp_df.RData")
# load("conflict_adj_imp_df.RData")
```



# IV) NODAL DATA: IMPORT & CLEANING


## Overview

@nga: Data is available for the following periods (before then values are automatically NA coded)
-   **sipri milex.pcw** data 1949-2023
-   **imf gdp.pcw** data 1980-2023 (+ predictions for 2024-2029)
-   **imf population.pcw** data 1980-2023 (+ predictions 2024-2029)
-   **ucdp conflict** data 1946-2023
-   **vdem.pcw regime (democracy score)** data 1789-2023
-   **vdem.pcw sovereignty variables (domestic policy, foreign policy, territory)** data 1789-2023
-   **vdem.pcw attempted coups** data 1950-2023


## IV.1) Military expenditure (SIPRI) 


### import 

Unit: constant prices in US$ millions (10^6) (at constant 2021 prices and exchange rates)
```{r}
# milex <- read.csv("data/SIPRI_milex/SIPRI_milex_constant_usd_2.csv", sep=";", header = T, check.names = F)

milex <- read.csv("data/SIPRI_milex/SIPRI-Milex-data-1948-2023_constant_usd_2.csv", sep=";", header = T, check.names = F)
```


```{r}
# pivot wide to long df shape
library(data.table)
milex  <- melt(setDT(milex), 
               id.vars = "Country", 
               variable.name = "year", 
               value.name = "milex") # alternatively use pivot_longer() from tidyr
# convert back from data.table to data.frame
milex <- as.data.frame(milex) 
```

```{r}
names(milex) # change year to integer, milex to numeric
milex <- milex %>%
  dplyr::rename(state1h = Country) %>%
  dplyr::mutate(milex = if_else(milex == "notindep", NA, milex),
         milex = as.numeric(milex),
         state1h = as.character(state1h),
         year = as.integer(as.character(year)))
```


### subset 1993-2023
Subset post Cold War (1993-2023) data and add time spells
--> dissolution of USSR on 26.12.1991, and subsequent changes & independence declarations during 1992, so observation period starts with 1993
```{r}
# Compute t-spells
milex.pcw <- milex %>% 
  # subset post Cold War period
  dplyr::filter(year >= 1993 & year <= 2023) %>%
  # create a variable t to assign time spell identifier
  dplyr::mutate(t = ifelse(year <= 1997, "t1",
                      ifelse(year <= 2002, "t2",
                           ifelse(year <= 2007, "t3",
                                  ifelse(year <= 2012, "t4",
                                         ifelse(year <= 2017, "t5",
                                                ifelse(year <= 2023, "t6"
                                                ))))))) %>% 
  # order columns
  dplyr::select(state1h, t, year, everything()) %>%
  # order rows
  dplyr::arrange(year, state1h)
```


### country code harmonisation


#### recode problematic/obsolete state designations

Check for usual obsolete polities (Czechoslovakia, Yugoslavia, USSR i.e. Soviet, Yemen etc)

```{r}
View(milex.pcw)
```


```{r}
# entities with NA values throughout all observation years
milex.pcw %>%
  group_by(state1h) %>%
  summarize(all_na = all(is.na(milex))) %>% # Summarize the data to check if all “milex” values are NA for each “state1h”
  dplyr::filter(all_na) %>%
  dplyr::select(state1h)
```

These 9 entities only have NA values:
Cuba			
Czechoslovakia			
German Democratic Republic			
Korea, North			
Somalia			
Syria			
USSR			
Yemen, North			
Yugoslavia

Countries that no longer exist from 1993 onwards that will be deleted from the dataset or have their information fused with the successor state: Czechoslovakia, German Democratic Republic, USSR, Yemen North, Yugoslavia. For Cuba, North Korea, Somalia, and Syria we have missing value for the complete observation period.

```{r}
delete <- c("Czechoslovakia", "German Democratic Republic", "Yugoslavia") # "USSR", "Yemen, North"
milex.pcw <- milex.pcw %>% dplyr::filter(!state1h %in% delete)
```

```{r}
## Fuse data of former state and successor state
milex.pcw <- milex.pcw %>% 
  dplyr::mutate(state1h = if_else(state1h == "Yemen, North", "Yemen", state1h)) # Yemen
milex.pcw <- milex.pcw %>% 
  dplyr::mutate(state1h = if_else(state1h == "USSR", "Russia", state1h)) # Russia/USSR

## Micronesia: Usually, Micronesia's designation has to be adapted for it to be recognized in the countrycode package's database
# milex.pcw <- milex.pcw %>%
#   dplyr::mutate(state1h = ifelse(state1h == "Micronesia", "Micronesia (Federated States of)", state1h))

## For "Serbia" entries, we need to add "Yugoslavia" to cow codes
```

```{r}
## delete duplicates with NA values in milex
milex.pcw <- milex.pcw %>%
  group_by(state1h, t, year) %>%
  dplyr::mutate(valid_milex = sum(!is.na(milex))) %>%
  dplyr::filter(!(is.na(milex) & valid_milex > 0)) %>%
  dplyr::select(-valid_milex) %>%
  ungroup()
```


Other cleaning operations for country designations
```{r}
# View(milex.pcw)
# use search to look for Czechoslovakia, Yemen, German Democratic Republic, USSR, and Serbia/Yugoslavia

## Usually, Micronesia's designation has to be adapted for it to be recognized in the countrycode package's database
# milex.pcw <- milex.pcw %>% 
#   dplyr::mutate(state1h = ifelse(state1h == "Micronesia", "Micronesia (Federated States of)", state1h))

# For "Serbia" entries, we need to add "Yugoslavia" to cow codes
```

#### add ccodes
```{r}
# library(countrycode)
a <- milex.pcw$state1h
countrycode::guess_field(a, min_similarity=85) # the closest ccode permitted as origin is country.name.en
?codelist
```

```{r}
# cown
milex.pcw$cown1 <- countrycode(milex.pcw$state1h, origin = 'country.name', destination = 'cown') # nm: European Union, Serbia
# Take care of Serbia/Yugoslavia pb in COW ccode
milex.pcw <- milex.pcw %>%
  dplyr::mutate(cown1 = if_else(state1h == "Serbia", 345, cown1))

# cowc
milex.pcw$cowc1 <- countrycode(milex.pcw$cown1, origin = 'cown', destination = 'cowc')

# cowen
milex.pcw$cowen1 <- countrycode(milex.pcw$cown1, origin = 'cown', destination = 'cow.name')

# iso 3
milex.pcw$iso1 <- countrycode(milex.pcw$state1h, origin = 'country.name', destination = 'iso3c') # European Union, Kosovo

# un m49
milex.pcw$un1 <- countrycode(milex.pcw$state1h, origin = 'country.name', destination = 'un') # European Union, Kosovo, Taiwan. Taiwan and Kosovo not UN members so unrecognized in UN/ISO system

# harmonized country names
milex.pcw$state1h <- countrycode(milex.pcw$un1, origin = 'un', destination = 'country.name')
```


### exclude states with NA in countrycodes

We'll delete observations with NAs in the cow and in the iso alpha 3/m49 columns. NAs in either of these ccode systems mean the entity is not a formal member of the international system starting 1993, either because they no longer exist, are politically contested territories, united with another entity to form a new state, or are not recognized as an independent state for some other reason.

These are usually e.g. 
Palestine (PSE), Hong Kong (HKG), Taiwan (TWN), Kosovo (KOS), Macau (MAC), Aruba (ABW), and West Sahara (ESH). Palestine, Hongkong, and Macao exist in the un m49 system because of observer or associated member status, but they are not in the cow system because of contested status as a sovereign state/territory. Taiwan, on the other hand, is not part of the UN m49 because it lost its seat in 1971, but remains in the cow ccode system.

```{r}
milex.pcw %>%
  group_by(state1h) %>%
  dplyr::filter(is.na(un1)) %>% View() # mainly Kosovo, Taiwan, EU entries turned into NA cases
```

```{r}
milex.pcw <- milex.pcw %>% 
  # delete iso alpha 3 & un m49 NA cases 
  dplyr::filter(!is.na(cown1) & !is.na(un1)) # %>%
  # delete info for contested territories
  # dplyr::filter(iso1 != "HKG" & iso1 != "PSE" & iso1 != "TWN" & iso1 != "ESH" & iso1 != "MAC") %>% 
  # delete USSR
  # dplyr::filter(state1 != "USSR")

# check for duplicates
milex.pcw[duplicated(milex.pcw),] 
# milex.pcw[duplicated(milex.pcw) | duplicated(milex.pcw, fromLast = TRUE),]

# delete dups
milex.pcw <- milex.pcw[!duplicated(milex.pcw), ]
```


### check NAs & UN membership

#### NAs
```{r}
colSums(is.na(milex.pcw)) # 520 NAs in GDP data
milex.pcw %>% dplyr::filter(is.na(milex)) %>% pull(state1h) %>% unique() %>% sort() # 49 states with incomplete data
```

#### UN members
```{r}
## UN member list
un_mlist <- un_members %>% pull(state) %>% unique() %>% sort() # 193

## nodes in milex data
milex_mlist <- milex.pcw$state1h %>% unique() %>% sort() # 166
milex_mlist
```

```{r}
## UN members not in dataset
missing_milex <- setdiff(un_mlist, milex_mlist) # 27 UN members that are not in the dataset at all
missing_milex

## Entities in data set that are not UN members
setdiff(milex_mlist, un_mlist) # none, so all nodes in the dataset are UN members
```

--> a total of 27 UN countries with complete missing milex data. Most of them are microstates:
Andorra, Antigua & Barbuda, Bahamas, Barbados, Bhutan, Comoros, Dominica, Grenada, Kiribati, Liechtenstein, Maldives, Marshall Islands, Micronesia (Federated States of), Monaco, Nauru, Palau, Samoa, San Marino, São Tomé & Príncipe, Solomon Islands, St. Kitts & Nevis, St. Lucia, St. Vincent & Grenadines, Suriname, Tonga, Tuvalu, Vanuatu


#### number of missings by state
```{r}
## frequency of NAs by country
milex.pcw %>%
  dplyr::filter(is.na(milex)) %>%
  group_by(state1h) %>% 
  dplyr::summarise(n_missings = n()) %>% 
  dplyr::arrange(desc(n_missings)) %>% 
  print()

# 4 countries without any data points at all between 1993-2023: Cuba, North Korea, Somalia, Syria. Countries with many missing country-year observations: Turkmenistan, Usbekistan, Eritrea, Qatar (between 20-25 NAs out of 31 years)
```

--> these 4 countries with missing milex data "Cuba", "Liechtenstein", "Monaco", "North Korea" will be added to the list of 27 countries without any country-year observations in the milex dataset
```{r}
missing_milex <- c(missing_milex, "Cuba", "North Korea", "Somalia", "Syria")
```

--> a total of 31 UN countries with complete missing milex data


### labels
```{r}
# add vbl labels
# library(Hmisc)
# label(milex.pcw$state1) <- "country name"
label(milex.pcw$iso1) <- "iso alpha 3 code"
label(milex.pcw$un1) <- "un m49 country code"
label(milex.pcw$cown1) <- "cow numeric code"
label(milex.pcw$cowen1) <- "cow name"
label(milex.pcw$cowc1) <- "cow character code"
label(milex.pcw$state1h) <- "harmonized name based on un m49"
label(milex.pcw$milex) <- "military expenditure in constant USD (million)"
# Hmisc::label(milex.pcw) # check result

# head(milex.pcw)
```

### descriptive stats

```{r}
# How many states in total between 1993-2023?
milex.pcw %>% 
  group_by(state1h) %>%
  dplyr::summarise(n = n())
unique(milex.pcw$state1h) # 166

# How many conflicts do each unique dyad have, broken down by t spell?
# milex.pcw %>% 
#   group_by(t, state1h) %>% 
#   dplyr::summarise(n = n())

# How many conflicts do each unique dyad have in t=5 (i.e. 2012-2016)
# milex.pcw %>% 
#   dplyr::filter(t == "t5") %>% 
#   group_by(state1h) %>% 
#   dplyr::summarise(n = n())

# check nas
colSums(is.na(milex.pcw))
```

### save
```{r}
# save(milex, file = "milex.RData") # as R data file
# load("milex.RData")

# save(milex.pcw, file = "milex.pcw.RData") # as R data file
# load("milex.pcw.RData")
```




## IV.2) GDP (IMF)

### import weo

First, we'll import the world economic outlook data provided yearly by the IMF, the latest version being April 2024. For more information on IMF world economic outlook data:
https://www.imf.org/en/Publications/WEO/Issues/2023/04/11/world-economic-outlook-april-2023#tools

-   GDP, in constant US$ billion (10^9)

OLD DATA
```{r}
## To access github developer packages use personal access token
# library(usethis)
# usethis::edit_r_environ() # GITHUB_PAT=mypat --> use github personal access token 
```

```{r}
## Package to import IMF world economic outlook data by Matt Cowgill: https://github.com/MattCowgill/readweo
# library(devtools)
# devtools::install_github("MattCowgill/readweo")
## `read_weo()` 

# library(readweo) # returns a tidy (long) tibble df, might take a minute to load bcs the weo is a large dataset
# weo_apr23 <- read_weo("April 2023") # if argument = NULL, defaults to most updated weo dataset
# weo_apr23 %>% dplyr::filter(weo_subject_code == "NGDPD", units == "U.S. dollars") %>% View()

# save(weo_apr23, file = "weo_apr23.RData")
# load("weo_apr23.RData") 

```


NEW DATA
```{r}
library(readr)
weo_apr24 <- read_tsv("data/IMF_WEO/WEOApr2024all.tsv", locale = locale(encoding = "UTF-8"))

# to lower
names(weo_apr24) <- tolower(gsub(" ", "_", names(weo_apr24)))

# change character encoding to UTF-8
weo_apr24[] <- lapply(weo_apr24, function(x) {
  if (is.character(x)) {
    iconv(x, from = "latin1", to = "UTF-8")
  } else {
    x
  }
})
# weo_apr24$country <- iconv(weo_apr24$country, from = "latin1", to = "UTF-8")

# save(weo_apr24, file = "weo_apr24.RData")
load("weo_apr24.RData")
```



inspect meta data
```{r}
# weo dataset comprises 196 countries
weo_apr24 %>%       
  dplyr::select(country) %>% 
  unique() %>% 
  dplyr::arrange()

# weo dataset contains 28 economic indicators
unique(weo_apr24$subject_descriptor)
```



### subset nominal GDP

The IMF World Economic Outlook dataset provides data on Gross Domestic Product (GDP) in different forms, including “Gross domestic product, constant prices”, “Gross domestic product, current prices” and “Gross domestic product, deflator”. Here is an explanation of the differences between these three measures:
  
**Gross domestic product, constant prices**: This measure of GDP is expressed in terms of the prices of a base year. It is also known as real GDP. This measure allows for comparisons of economic growth over time by removing the effects of inflation.
**Gross domestic product, current prices**: This measure of GDP is expressed in terms of the prices of the current year. It is also known as nominal GDP. This measure reflects both changes in the volume of production and changes in the prices of goods and services.
**Gross domestic product, deflator**: The GDP deflator is a measure of the overall level of prices in an economy. It is calculated by dividing nominal GDP by real GDP and multiplying by 100. The GDP deflator can be used to convert nominal GDP into real GDP by removing the effects of price changes.

Source: 
  -   https://data.imf.org/regular.aspx?key=61545852
  -   https://www.imf.org/en/Publications/WEO/weo-database/2024/April


I would have prefered using real GDP values. However, WEO only records real GDP (constant prices) in units of national currency. So I will use the nominal GDP i.e. current prices (in USD billions) to facilitate comparison of GDP values across countries. 
```{r}
# description of data on nominal GDP (in USD billions)
weo_apr24 %>% 
  dplyr::filter(weo_subject_code == "NGDPD", units == "U.S. dollars") %>% 
  dplyr::select(subject_notes) %>% 
  unique() %>% 
  as.vector()
```
Note: "Values are based upon GDP in national currency converted to U.S. dollars using market exchange rates (yearly average). Exchange rate projections are provided by country economists for the group of other emerging market and developing countries. Exchanges rates for advanced economies are established in the WEO assumptions for each WEO exercise. Expenditure-based GDP is total final expenditures at purchasers' prices (including the f.o.b. value of exports of goods and services), less the f.o.b. value of imports of goods and services. [SNA 1993]"



Subset gdp

```{r}
library(dplyr)
gdp <- weo_apr24 %>% 
  dplyr::filter(subject_descriptor == "Gross domestic product, current prices",
         units == "U.S. dollars") %>%
  dplyr::rename(country_notes = `country/series-specific_notes`) %>% 
  dplyr::select(-c(weo_subject_code, weo_country_code, subject_descriptor, subject_notes, units, scale, country_notes, estimates_start_after))
```

```{r}
library(tidyr)
gdp <- gdp %>%
  tidyr::pivot_longer(
    cols = starts_with("1980"):starts_with("2029"),
    names_to = "year",
    values_to = "value") %>% 
  dplyr::rename(gdp = value,
         state1h = country,
         iso1 = iso)%>% 
  dplyr::arrange(year,state1h) %>% 
  dplyr::mutate(gdp = gsub(",", "", gdp))

```

```{r}
# str(gdp)
gdp <- gdp %>% 
  dplyr::mutate(year = as.integer(year),
                gdp = as.numeric(gdp))
```


```{r}
# check gdp time series using Germany as example
gdp %>% 
  dplyr::filter(state1h == "Germany")
```




### subset 1993-2023
Subset post Cold War (1993-2023) data and add time spells
--> dissolution of USSR on 26.12.1991, and subsequent changes & independence declarations during 1992, so observation period starts with 1993
```{r}
# Compute t-spells
gdp.pcw <- gdp %>% 
  # subset post Cold War period
  dplyr::filter(year >= 1993 & year <= 2023) %>%
  # create a variable t to assign time spell identifier
  dplyr::mutate(t = ifelse(year <= 1997, "t1",
                           ifelse(year <= 2002, "t2",
                                  ifelse(year <= 2007, "t3",
                                         ifelse(year <= 2012, "t4",
                                                ifelse(year <= 2017, "t5",
                                                       ifelse(year <= 2023, "t6"
                                                       ))))))) %>% 
  # order columns
  dplyr::select(state1h, t, year, everything()) %>%
  # order rows
  dplyr::arrange(year, state1h)

```



### country codes harmonization

```{r}
# add country codes
# library(countrycode)
# ?codelist # country codes designations
```


#### prep
```{r}
a <- gdp.pcw$state1h
countrycode::guess_field(a, min_similarity=85) # the closest ccode permitted as origin is country.name.en
?codelist
```


Check for usual obsolete polities (Czechoslovakia, Yugoslavia, USSR i.e. Soviet, Yemen etc)
```{r}
View(gdp.pcw) # all's good. Micronesia designation needs to be changed
```

```{r}
# delete <- c("Czechoslovakia", "German Democratic Republic", "USSR", "Yemen, North", "Yugoslavia")
# gdp.pcw <- gdp.pcw %>% dplyr::filter(!state1h %in% delete)
```

```{r}
## Usually, Micronesia's designation has to be adapted for it to be recognized in the countrycode package's database
gdp.pcw <- gdp.pcw %>%
  dplyr::mutate(state1h = ifelse(state1h == "Micronesia", "Micronesia (Federated States of)", state1h))

# For "Serbia" entries, we need to add "Yugoslavia" to cow codes
```



#### add ccodes
```{r}
# cown
gdp.pcw$cown1 <- countrycode(gdp.pcw$state1h, origin = 'country.name', destination = 'cown') # nm: Aruba, Hong Kong SAR, Macao SAR, Puerto Rico, Serbia, West Bank and Gaza
# Take care of Serbia/Yugoslavia pb in COW ccode
gdp.pcw <- gdp.pcw %>%
  dplyr::mutate(cown1 = if_else(state1h == "Serbia", 345, cown1))

# cowc
gdp.pcw$cowc1 <- countrycode(gdp.pcw$cown1, origin = 'cown', destination = 'cowc')

# cowen
gdp.pcw$cowen1 <- countrycode(gdp.pcw$cown1, origin = 'cown', destination = 'cow.name')

# iso 3
gdp.pcw$iso1 <- countrycode(gdp.pcw$state1h, origin = 'country.name', destination = 'iso3c') # Kosovo

# un m49
gdp.pcw$un1 <- countrycode(gdp.pcw$state1h, origin = 'country.name', destination = 'un') # Kosovo, Taiwan Province of China

# harmonized country names
gdp.pcw$state1h <- countrycode(gdp.pcw$un1, origin = 'un', destination = 'country.name')
```


### exclude states with NA in countrycodes

We'll delete observations with NAs in the cow and in the iso alpha 3/m49 columns. NAs in either of these ccode systems mean the entity is not a formal member of the international system starting 1993, either because they no longer exist, are politically contested territories, united with another entity to form a new state, or are not recognized as an independent state for some other reason.

These are usually e.g. 
Palestine (PSE), Hong Kong (HKG), Taiwan (TWN), Kosovo (KOS), Macau (MAC), Aruba (ABW), and West Sahara (ESH). Palestine, Hongkong, and Macao exist in the un m49 system because of observer or associated member status, but they are not in the cow system because of contested status as a sovereign state/territory. Taiwan, on the other hand, is not part of the UN m49 because it lost its seat in 1971, but remains in the cow ccode system.

```{r}
# colSums(is.na(gdp.pcw))

gdp.pcw %>%
  group_by(state1h) %>%
  dplyr::filter(is.na(iso1)) %>% View() # NAs = Kosovo

gdp.pcw %>%
  group_by(state1h) %>%
  dplyr::filter(is.na(un1)) %>% View() # NAs = Kosovo, Taiwan

gdp.pcw %>%
  group_by(state1h) %>%
  dplyr::filter(is.na(cowen1)) %>% View() # NAs = Aruba, Hong Kong SAR, Macao SAR, Puerto Rico, West Bank and Gaza

# unique(gdp.pcw$state1h)
```

```{r}
gdp.pcw <- gdp.pcw %>% 
  # delete iso alpha 3 & un m49 NA cases 
  dplyr::filter(!is.na(cown1) & !is.na(un1))
  # delete info for contested territories
  # dplyr::filter(iso1 != "HKG" & iso1 != "PSE" & iso1 != "TWN" & iso1 != "ESH" & iso1 != "MAC")
  
# check for duplicates
gdp.pcw[duplicated(gdp.pcw),] 
# gdp.pcw2[duplicated(gdp.pcw2) | duplicated(gdp.pcw2, fromLast = TRUE),]
```




### check NAs & UN membership


#### NAs
```{r}
colSums(is.na(gdp.pcw)) # 158 NAs in GDP data
gdp.pcw %>% dplyr::filter(is.na(gdp)) %>% pull(state1h) %>% unique() %>% sort() # 25 states with some missing gdp data
```

#### UN membership
```{r}
## UN member list
un_mlist <- un_members %>% pull(state) %>% unique() %>% sort() # 193

## nodes in gdp data
gdp_mlist <- gdp.pcw$state1h %>% unique() %>% sort() # 189, i.e. 4 UN members have complete missing gdp data
gdp_mlist

```

```{r}
## UN members not in dataset
missing_gdp <- setdiff(un_mlist, gdp_mlist) # 4 UN members that are not in the dataset: "Cuba", "Liechtenstein", "Monaco", "North Korea" 
missing_gdp

## Entities in data set that are not UN members
setdiff(gdp_mlist, un_mlist) # none, so all nodes in the dataset are UN members
```

--> a total of 4 UN countries with complete missing gdp data: "Cuba", "Liechtenstein", "Monaco", "North Korea" 

#### number of missings by state
```{r}
## frequency of NAs by country
gdp.pcw %>%
  dplyr::filter(is.na(gdp)) %>%
  group_by(state1h) %>% 
  dplyr::summarise(n_missings = n()) %>% 
  dplyr::arrange(desc(n_missings)) %>% 
  print()

# Somalia with 18 missing country-year observations, South Sudan 19, Syria 13 etc..
```



### labels
```{r}
# add vbl labels
# library(Hmisc)
label(gdp.pcw$iso1) <- "iso alpha 3 code"
label(gdp.pcw$un1) <- "un m49 country code"
label(gdp.pcw$cown1) <- "cow numeric code"
label(gdp.pcw$cowen1) <- "cow name"
label(gdp.pcw$cowc1) <- "cow character code"
label(gdp.pcw$state1h) <- "harmonized name based on un m49"
label(gdp.pcw$gdp) <- "gdp (in constant US$ billion =10^9)"
# Hmisc::label(gdp.pcw) # check result
```

```{r}
# inspect
# head(gdp.pcw, 10)
# tail(gdp.pcw, 10)
```


### descriptive stats

```{r}
# How many states in total between 1993-2023?
gdp.pcw %>% 
  group_by(state1h) %>%
  dplyr::summarise(n = n())
unique(gdp.pcw$state1h) # 189

# How many conflicts do each unique dyad have, broken down by t spell?
# gdp.pcw %>% 
#   group_by(t, state1h) %>% 
#   dplyr::summarise(n = n())

# How many conflicts do each unique dyad have in t=5 (i.e. 2012-2016)
# gdp.pcw %>% 
#   dplyr::filter(t == "t5") %>% 
#   group_by(state1h) %>% 
#   dplyr::summarise(n = n())

# check nas
colSums(is.na(gdp.pcw))
```


### save
```{r}
# save(weo_apr24, file = "weo_apr24.RData")
# load("weo_apr24.RData") 

# save(gdp, file = "gdp.RData")
# load("gdp.RData") 

# save(gdp.pcw, file = "gdp.pcw.RData")
# load("gdp.pcw.RData")
```



## IV.3) Population (IMF)

### subset population

The population data is also extracted from the IMF's world economic outlook data.

Unit: in millions of individuals
```{r}
# weo dataset also contain population information
unique(weo_apr24$subject_descriptor)
```

```{r}
# description of population variable
weo_apr24 %>% 
  dplyr::filter(subject_descriptor == "Population") %>% 
  dplyr::select(subject_notes) %>% 
  unique() %>% 
  as.vector()
```
Note: "For census purposes, the total population of the country consists of all persons falling within the scope of the census. In the broadest sense, the total may comprise either all usual residents of the country or all persons present in the country at the time of the census. [Principles and Recommendations for Population and Housing Censuses, Revision 1, paragraph 2.42]"

```{r}
weo_apr24 %>% 
  dplyr::filter(subject_descriptor == "Population") %>% 
  dplyr::select(`country/series-specific_notes`) %>% 
  unique() %>% 
  as.vector()
```


```{r}
# library(dplyr)
population <- weo_apr24 %>% 
  dplyr::filter(subject_descriptor == "Population") %>% 
  dplyr::rename(country_notes = `country/series-specific_notes`) %>% 
  dplyr::select(-c(weo_subject_code, weo_country_code, subject_descriptor, subject_notes, units, scale, country_notes, estimates_start_after))

```

```{r}
# library(tidyr)
population <- population %>%
  pivot_longer(
    cols = starts_with("1980"):starts_with("2029"),
    names_to = "year",
    values_to = "value") %>% 
  dplyr::rename(population = value,
         state1h = country,
         iso1 = iso)%>% 
  dplyr::arrange(year,state1h) %>% 
  dplyr::mutate(population = gsub(",", "", population))
```


```{r}
population <- population %>% 
  dplyr::mutate(year = as.integer(year),
         population = as.numeric(population))
```

```{r}
# check time series using Germany as example
population %>% 
  dplyr::filter(state1h == "Germany")
```



### subset 1993-2023
Subset post Cold War (1993-2023) data and add time spells
--> dissolution of USSR on 26.12.1991, and subsequent changes & independence declarations during 1992, so observation period starts with 1993
```{r}
# Compute t-spells
population.pcw <- population %>% 
  # subset post Cold War period
  dplyr::filter(year >= 1993 & year <= 2023) %>%
  # create a variable t to assign time spell identifier
  dplyr::mutate(t = ifelse(year <= 1997, "t1",
                           ifelse(year <= 2002, "t2",
                                  ifelse(year <= 2007, "t3",
                                         ifelse(year <= 2012, "t4",
                                                ifelse(year <= 2017, "t5",
                                                       ifelse(year <= 2023, "t6"
                                                       ))))))) %>% 
  # order columns
  dplyr::select(state1h, t, year, everything()) %>%
  # order rows
  dplyr::arrange(year, state1h)
```


### country codes harmonization

```{r}
# add country codes
# library(countrycode)
# ?codelist # country codes designations
```


#### prep
```{r}
a <- population.pcw$state1h
countrycode::guess_field(a, min_similarity=85) # the closest ccode permitted as origin is country.name.en
?codelist
```


Check for usual obsolete polities (Czechoslovakia, Yugoslavia, USSR i.e. Soviet, Yemen etc)
```{r}
View(population.pcw) # all's good. Micronesia designation needs to be changed
```

```{r}
# delete <- c("Czechoslovakia", "German Democratic Republic", "USSR", "Yemen, North", "Yugoslavia")
# population.pcw <- population.pcw %>% dplyr::filter(!state1h %in% delete)
```

```{r}
## Usually, Micronesia's designation has to be adapted for it to be recognized in the countrycode package's database
population.pcw <- population.pcw %>%
  dplyr::mutate(state1h = ifelse(state1h == "Micronesia", "Micronesia (Federated States of)", state1h))

# For "Serbia" entries, we need to add "Yugoslavia" to cow codes
```



#### add ccodes
```{r}
# cown
population.pcw$cown1 <- countrycode(population.pcw$state1h, origin = 'country.name', destination = 'cown') # nm: Aruba, Hong Kong SAR, Macao SAR, Puerto Rico, Serbia, West Bank and Gaza
# Take care of Serbia/Yugoslavia pb in COW ccode
population.pcw <- population.pcw %>%
  dplyr::mutate(cown1 = if_else(state1h == "Serbia", 345, cown1))

# cowc
population.pcw$cowc1 <- countrycode(population.pcw$cown1, origin = 'cown', destination = 'cowc')

# cowen
population.pcw$cowen1 <- countrycode(population.pcw$cown1, origin = 'cown', destination = 'cow.name')

# iso 3
population.pcw$iso1 <- countrycode(population.pcw$state1h, origin = 'country.name', destination = 'iso3c') # Kosovo

# un m49
population.pcw$un1 <- countrycode(population.pcw$state1h, origin = 'country.name', destination = 'un') # Kosovo, Taiwan Province of China

# harmonized country names
population.pcw$state1h <- countrycode(population.pcw$un1, origin = 'un', destination = 'country.name')
```


### exclude states with NA in countrycodes

We'll delete observations with NAs in the cow and in the iso alpha 3/m49 columns. NAs in either of these ccode systems mean the entity is not a formal member of the international system starting 1993, either because they no longer exist, are politically contested territories, united with another entity to form a new state, or are not recognized as an independent state for some other reason.

These are usually e.g. 
Palestine (PSE), Hong Kong (HKG), Taiwan (TWN), Kosovo (KOS), Macau (MAC), Aruba (ABW), and West Sahara (ESH). Palestine, Hongkong, and Macao exist in the un m49 system because of observer or associated member status, but they are not in the cow system because of contested status as a sovereign state/territory. Taiwan, on the other hand, is not part of the UN m49 because it lost its seat in 1971, but remains in the cow ccode system.

```{r}
population.pcw %>%
  group_by(state1h) %>%
  dplyr::filter(is.na(un1)) %>% View() # mainly Kosovo, Taiwan entries turned into NA cases
```


```{r}
population.pcw <- population.pcw %>% 
  # delete iso alpha 3 & un m49 NA cases 
  dplyr::filter(!is.na(cown1) & !is.na(un1))
  # delete info for contested territories
  # dplyr::filter(iso1 != "HKG" & iso1 != "PSE" & iso1 != "TWN" & iso1 != "ESH" & iso1 != "MAC")
  
# check for duplicates
population.pcw[duplicated(population.pcw),] 
# population.pcw2[duplicated(population.pcw2) | duplicated(population.pcw2, fromLast = TRUE),]


```




### check NAs & UN membership

#### NAs
```{r}
colSums(is.na(population.pcw)) # 178 NAs
population.pcw %>% dplyr::filter(is.na(population)) %>% pull(state1h) %>% unique() %>% sort() # 26 states with some missing data
```

#### UN members
```{r}
## UN member list
un_mlist <- un_members %>% pull(state) %>% unique() %>% sort() # 193

## nodes in population data
population_mlist <- population.pcw$state1h %>% unique() %>% sort() # 189
population_mlist

```

```{r}
## UN members not in dataset
missing_pop <- setdiff(un_mlist, population_mlist) # 4 UN members that are not in the dataset: Cuba, Liechtenstein, Monaco, North Korea
missing_pop

## Entities in data set that are not UN members
setdiff(population_mlist, un_mlist) # none, so all nodes in the dataset are UN members
```
--> a total of 4 UN countries with complete missing pop data:  Cuba, Liechtenstein, Monaco, North Korea

#### number of missings by state
```{r}
## frequency of NAs by country
population.pcw %>%
  dplyr::filter(is.na(population)) %>%
  group_by(state1h) %>% 
  dplyr::summarise(n_missings = n()) %>% 
  dplyr::arrange(desc(n_missings)) %>% 
  print()
# Somalia with 19 missing country-year observations, South Sudan 18, Andorra 17, Syria 13 etc..
```



### labels
```{r}
# add vbl labels
# library(Hmisc)
label(population.pcw$iso1) <- "iso alpha 3 code"
label(population.pcw$un1) <- "un m49 country code"
label(population.pcw$cown1) <- "cow numeric code"
label(population.pcw$cowen1) <- "cow name"
label(population.pcw$cowc1) <- "cow character code"
label(population.pcw$state1h) <- "harmonized name based on un m49"
label(population.pcw$population) <- "in millions individuals"
# Hmisc::label(population.pcw) # check result
```

```{r}
# inspect
# head(population.pcw, 10)
# tail(population.pcw, 10)
```

### descriptive stats

```{r}
# How many states in total between 1993-2023?
population.pcw %>% 
  group_by(state1h) %>%
  dplyr::summarise(n = n())
unique(population.pcw$state1h) # 166

# How many conflicts do each unique dyad have, broken down by t spell?
# population.pcw %>% 
#   group_by(t, state1h) %>% 
#   dplyr::summarise(n = n())

# How many conflicts do each unique dyad have in t=5 (i.e. 2012-2016)
# population.pcw %>% 
#   dplyr::filter(t == "t5") %>% 
#   group_by(state1h) %>% 
#   dplyr::summarise(n = n())

# check nas
colSums(is.na(population.pcw))
```

### save
```{r}
# save(population, file = "population.RData")
# load("population.RData") 

# save(population.pcw, file = "population.pcw.RData")
load("population.pcw.RData")
```



## IV.4) Regime, Sovereignty, Stability (V-dem)

### import

V-Dem (Version 14.0, 2024) complete version 
For more info: 
-   https://github.com/vdeminstitute/vdemdata
-   https://v-dem.net/data/the-v-dem-dataset/

-  **Political regime** operationalized via v2x_polyarchy: electoral democracy index (interval, from low to high, 0-1) is a weighted average of...
    * v2x_freexp_altinf 
    * v2x_frassoc_thick 
    * v2x_suffr 
    * v2xel_frefair 
    * v2x_elecoff
(cf. Vdem Codebook v13 2023: 44)

-   **Political stability** operationalized via e_pt_coup_attempts (numeric): number of coup attempts in a year (1950-2023)

-   **Sovereignty** operationalized via 2 dimensions: 
    -   1) attribute of states within the context of the international system (i.e. state’s autonomy from other actors in the system) 
    -   2) relationship of the state to the population and territory over which it claims to rule (i.e. extent of recognition of the preeminent authority of the state
over its claimed territory and population)
    -   Indicators:
        * Domestic autonomy (C) (v2svdomaut) (p. 189): 0,1,2 
            (cf. Pemstein et al. (2023, V-Dem Working Paper Series 2023:21) in Vdem codebook 2023: 190)
        * International autonomy (C) (v2svinlaut) (p. 190): 0,1,2 
            (cf. Pemstein et al. (2023, V-Dem Working Paper Series 2023:21) in Vdem codebook 2023: 190)
        * State authority over territory (C) (v2svstterr) (p. 191): %
        * Independent states (A) (v2svindep) (p.194): 0/1 
            (cf. Gleditsch and Ward (1999; 2013); IPU Parline; IDEA in Vdem codebook 2023: 194)
            
            
Multidimensional and disaggregated dataset that reflects the complexity of the concept of democracy as a system of rule that goes beyond the simple presence of elections. The V-Dem project distinguishes between five high-level principles of democracy: electoral, liberal, participatory, deliberative, and egalitarian, and collects data to measure these principles.

Package: Maerz, Seraphine F., Amanda B. Edgell, Sebastian Hellemeier, and Nina Illchenko. 2023. vdemdata: An R package to load, explore and work with the most recent V-Dem (Varieties of Democracy) dataset. https://github.com/vdeminstitute/vdemdata

V-Dem (13.0) dataset: Coppedge, Michael, John Gerring, Carl Henrik Knutsen, Staffan I. Lindberg, Jan Teorell, David Altman, Michael Bernhard, Agnes Cornell, M. Steven Fish, Lisa Gastaldi, Haakon Gjerløw, Adam Glynn, Ana Good God, Sandra Grahn, Allen Hicken, Katrin Kinzelbach, Joshua Krusell, Kyle L. Marquardt, Kelly McMann, Valeriya Mechkova, Juraj Medzihorsky, Natalia Natsika, Anja Neundorf, Pamela Paxton, Daniel Pemstein, Josefine Pernes, Oskar Rydén, Johannes von Römer, Brigitte Seim, Rachel Sigman, Svend-Erik Skaaning, Jeffrey Staton, Aksel Sundström, Eitan Tzelgov, Yi-ting Wang, Tore Wig, Steven Wilson and Daniel Ziblatt. 2023. ”V-Dem [Country-Year/Country-Date] Dataset v13” Varieties of Democracy (V-Dem) Project. https://doi.org/10.23696/vdemds23. Accessible: https://www.v-dem.net/data/dataset-archive/


```{r}
library(usethis)
library(rlang)
# install.packages("rtools")
# library(rtools)
library(devtools)
# devtools::install_github("vdeminstitute/vdemdata")
library(vdemdata)

# vdem_24 <- vdem # Version 14, March 2024
# save(vdem_24, file = "vdem_24.RData") # original data
load("vdem_24.RData") 

```


```{r}
names(vdem_24)
vdem <- vdem_24 %>% 
  # select attributes to keep
  dplyr::select(country_name, year, # COWcode, 
         v2x_polyarchy,    # elective democracy
         e_pt_coup_attempts, # coup attempts
         v2svdomaut, v2svinlaut, v2svstterr, v2svindep) %>% # sovereignty
  # harmonize variable names
  dplyr::rename(state1h = country_name, 
         democracy = v2x_polyarchy, # elective democracy score
         coups = e_pt_coup_attempts, # number of coups attemps
         sov_domestic = v2svdomaut,  
         sov_foreign = v2svinlaut,
         sov_territory = v2svstterr,
         sov_independent = v2svindep)
```

```{r}
# str(vdem)
vdem <- vdem %>% dplyr::mutate(year = as.integer(year))
```



### subset 1993-2023
Subset post Cold War (1993-2023) data and add time spells
--> dissolution of USSR on 26.12.1991, and subsequent changes & independence declarations during 1992, so observation period starts with 1993
```{r}
# Compute t-spells
vdem.pcw <- vdem %>% 
  # subset post Cold War period
  dplyr::filter(year >= 1993 & year <= 2023) %>%
  # create a variable t to assign time spell identifier
  dplyr::mutate(t = ifelse(year <= 1997, "t1",
                      ifelse(year <= 2002, "t2",
                           ifelse(year <= 2007, "t3",
                                  ifelse(year <= 2012, "t4",
                                         ifelse(year <= 2017, "t5",
                                                ifelse(year <= 2023, "t6"
                                                ))))))) %>% 
  # order columns
  dplyr::select(state1h, t, year, everything()) %>%
  # order rows
  dplyr::arrange(year, state1h)
```



### country codes harmonization

```{r}
# add country codes
# library(countrycode)
# ?codelist # country codes designations
```

#### prep
```{r}
a <- vdem.pcw$state1h
countrycode::guess_field(a, min_similarity=85) # the closest ccode permitted as origin is country.name.en
?codelist
```



#### recode problematic/obsolete state designations

Check for usual obsolete polities (Czechoslovakia, Yugoslavia, USSR i.e. Soviet, Yemen etc)
```{r}
View(vdem.pcw) 
```

```{r}
# delete <- c("Czechoslovakia", "German Democratic Republic", "USSR", "Yemen, North", "Yugoslavia")
# vdem.pcw <- vdem.pcw %>% dplyr::filter(!state1h %in% delete)
```

```{r}
# ## Yemen
# vdem.pcw <- vdem.pcw %>% 
#   dplyr::mutate(state1h = if_else(state1h == "Yemen, North", "Yemen", state1h))
# 
# ## Russia/USSR
# vdem.pcw <- vdem.pcw %>% 
#   dplyr::mutate(state1h = if_else(state1h == "USSR", "Russia", state1h))

## Micronesia: Usually, Micronesia's designation has to be adapted for it to be recognized in the countrycode package's database
# vdem.pcw <- vdem.pcw %>%
#   dplyr::mutate(state1h = ifelse(state1h == "Micronesia", "Micronesia (Federated States of)", state1h))

## For "Serbia" entries, we need to add "Yugoslavia" to cow codes
```


#### add ccodes
```{r}
# cown
vdem.pcw$cown1 <- countrycode(vdem.pcw$state1h, origin = 'country.name', destination = 'cown') # nm: Hong Kong, Palestine/Gaza, Palestine/West Bank, Serbia, Somaliland
# Take care of Serbia/Yugoslavia pb in COW ccode
vdem.pcw <- vdem.pcw %>%
  dplyr::mutate(cown1 = if_else(state1h == "Serbia", 345, cown1))

# cowc
vdem.pcw$cowc1 <- countrycode(vdem.pcw$cown1, origin = 'cown', destination = 'cowc')

# cowen
vdem.pcw$cowen1 <- countrycode(vdem.pcw$cown1, origin = 'cown', destination = 'cow.name')

# iso 3
vdem.pcw$iso1 <- countrycode(vdem.pcw$state1h, origin = 'country.name', destination = 'iso3c') # Kosovo claimed by Serbia, Somaliland not sovereign claimed by Somali, Zanzibar semi-autonomous part of Tanzania

# un m49
vdem.pcw$un1 <- countrycode(vdem.pcw$state1h, origin = 'country.name', destination = 'un') # Kosovo, Somaliland, Taiwan, Zanzibar

# harmonized country names
vdem.pcw$state1h <- countrycode(vdem.pcw$un1, origin = 'un', destination = 'country.name')
```



### exclude states with NA in countrycodes

We'll delete observations with NAs in the cow and in the iso alpha 3/m49 columns. NAs in either of these ccode systems mean the entity is not a formal member of the international system starting 1993, either because they no longer exist, are politically contested territories, united with another entity to form a new state, or are not recognized as an independent state for some other reason.

These are usually e.g. 
Palestine (PSE), Hong Kong (HKG), Taiwan (TWN), Kosovo (KOS), Macau (MAC), Aruba (ABW), and West Sahara (ESH). Palestine, Hongkong, and Macao exist in the un m49 system because of observer or associated member status, but they are not in the cow system because of contested status as a sovereign state/territory. Taiwan, on the other hand, is not part of the UN m49 because it lost its seat in 1971, but remains in the cow ccode system.

```{r}
vdem.pcw %>%
  group_by(state1h) %>%
  dplyr::filter(is.na(un1)) %>% View() # mainly Kosovo, Taiwan, Zanzibar, Somaliland
```


```{r}
vdem.pcw <- vdem.pcw %>% 
  # delete iso alpha 3 & un m49 NA cases 
  dplyr::filter(!is.na(cown1) & !is.na(un1))
  # delete info for contested territories
  # dplyr::filter(iso1 != "HKG" & iso1 != "PSE" & iso1 != "TWN" & iso1 != "ESH" & iso1 != "MAC")
  
# check for duplicates
vdem.pcw[duplicated(vdem.pcw),] 
# vdem.pcw2[duplicated(vdem.pcw2) | duplicated(vdem.pcw2, fromLast = TRUE),]

```




### check NAs & UN membership

#### NAs
```{r}
colSums(is.na(vdem.pcw)) # 17 NAsfor sov_territory, 524 for coups

vdem.pcw %>% dplyr::filter(is.na(sov_territory)) %>% pull(state1h) %>% unique() %>% sort() # "Montenegro" and "Timor-Leste" are missing some or all data points for sov_territory

vdem.pcw %>% dplyr::filter(is.na(coups)) %>% pull(state1h) %>% unique() %>% sort() # 172 states with some or all missing data regarding coups
```

#### UN members
```{r}
## UN member list
un_mlist <- un_members %>% pull(state) %>% unique() %>% sort() # 193

## nodes in vdem data
vdem_mlist <- vdem.pcw$state1h %>% unique() %>% sort() # 189
vdem_mlist

```

```{r}
## UN members not in dataset
missing_vdem <- setdiff(un_mlist, vdem_mlist) # 21 UN members that are not in the dataset at all
missing_vdem

## Entities in data set that are not UN members
setdiff(vdem_mlist, un_mlist) # none, so all nodes in the dataset are UN members
```


--> a total of 21 UN countries with complete missing vdem data. Most of them are microstates:
Andorra, Antigua & Barbuda, Bahamas, Belize, Brunei, Dominica, Grenada, Kiribati, Liechtenstein, Marshall Islands, Micronesia (Federated States of), Monaco, Nauru, Palau, Samoa, San Marino, St. Kitts & Nevis, St. Lucia, St. Vincent & Grenadines, Tonga, Tuvalu 

#### number of missings by state
```{r}
## frequency of NAs by country

# coups: timor-leste and montenegro missing 11-12 country year observations. All the other countries miss 3 coutry-year observations each, which are the years 2021-2023.
vdem.pcw %>%
  dplyr::filter(is.na(coups)) %>%
  group_by(state1h) %>% 
  dplyr::summarise(n_missings = n()) %>% 
  dplyr::arrange(desc(n_missings)) %>% 
  print()

# sov territory: timor-leste & montenegro are missing 8-9 country-year observations
vdem.pcw %>%
  dplyr::filter(is.na(sov_territory)) %>%
  group_by(state1h) %>% 
  dplyr::summarise(n_missings = n()) %>% 
  dplyr::arrange(desc(n_missings)) %>% 
  print()
```


### labels
```{r}
# add vbl labels
# library(Hmisc)
label(vdem.pcw$iso1) <- "iso alpha 3 code"
label(vdem.pcw$un1) <- "un m49 country code"
label(vdem.pcw$cown1) <- "cow numeric code"
label(vdem.pcw$cowen1) <- "cow name"
label(vdem.pcw$cowc1) <- "cow character code"
label(vdem.pcw$state1h) <- "harmonized name based on un m49"
label(vdem.pcw$democracy) <- "vdem score 0-1 (auto-demo)"
# Hmisc::label(vdem.pcw) # check result
```



### value labels

In Vdem sov_domestic (v2svdomaut) and sov_foreign (v2svinlaut) are ordinal 0-2, but were converted to interval by measurement model. Hence we don't factorize them here. sov_independent (v2svindep) is dichotomous and will therefore be factorized.

```{r}
# add value labels
## library(labelled)
# library(dplyr)
# library(haven)
vdem.pcw <- vdem.pcw %>% 
  dplyr::mutate(sov_score = round(((sov_domestic + sov_foreign)/2),3)) #%>% # sov scale
  # dplyr::mutate(sov_independent = haven::labelled(sov_independent,
  #                                          c("no" = 0,
  #                                            "yes" =1,
  #                                            "missing" = NA),
  #                                          label = "independent state?"))
Hmisc::label(vdem.pcw$sov_score) <- "autonomous from other states in domestic & foreign policy? (low = non-autonomous)"
# check
# head(vdem.pcw$sov_independent)
# head(vdem.pcw)
```


### descriptive stats

```{r}
vdem %>% 
  dplyr::filter(year == 2020 & sov_score <0) %>% 
  View()
vdem %>% 
  dplyr::filter(year == 2020 & sov_score >=0 & sov_score <=1) %>% 
  View()
range(vdem$sov_score)
hist(vdem$sov_score,100)
median(vdem$sov_score)
```

```{r}
# How many states in total between 1993-2023?
vdem.pcw %>% 
  group_by(state1h) %>%
  dplyr::summarise(n = n())

# How many conflicts do each unique dyad have, broken down by t spell?
# vdem.pcw %>% 
#   group_by(t, state1h) %>% 
#   dplyr::summarise(n = n())

# How many conflicts do each unique dyad have in t=5 (i.e. 2012-2016)
# vdem.pcw %>% 
#   dplyr::filter(t == "t5") %>% 
#   group_by(state1h) %>% 
#   dplyr::summarise(n = n())

# check nas
colSums(is.na(vdem.pcw))
```


### save
```{r}
# save(vdem, file = "vdem.RData")
# load("vdem.RData") 

# save(vdem.pcw, file = "vdem.pcw.RData")
load("vdem.pcw.RData")
```




## IV.5) Armed conflict (UCDP state level)

USE DYAD-ID TO AGGREGATE BY ENEMY; USE CONFLICT-ID TO AGGREGATE BY CONFLICT

Output
```{r}
# load("conflict_state.RData") 
```

### a) import

Unit of analysis = state-year (is the state engaged in interstate, intrastate or extrasystemic armed conflict in a given year?) 

UCDP Dyadic Armed Conflict Dataset 1946-2023
-   Harbom, Lotta, Erik Melander & Peter Wallensteen (2008) Dyadic Dimensions of Armed Conflict, 1946-2007. Journal of Peace Research 45(5): 697-710,
-   Davies, Shawn, Therese Pettersson & Magnus Öberg (2023). Organized violence 1989-2023, and the return of conflict between states. Journal of Peace Research 60(4).
-   Pettersson, Therese (2023) UCDP Dyadic Dataset Codebook v 23.1 (https://ucdp.uu.se/downloads/).

```{r}
# import dyadic conflict-year dataset
ucdp <- read.csv("data/UCDP Prio conflict engagement/conflict/dyadic/Dyadic_v24_1.csv", sep=",", header = T, check.names = F)
# names(ucdp)
```

```{r}
# names(ucdp)
# ucdp %>% dplyr::filter(year == 2023)
```

```{r}
# str(ucdp)
ucdp <- ucdp %>% dplyr::mutate(year = as.integer(year))
```


### b) country data, by incidence (between a dyad)

#### initial cleaning
By definition, all conflicts included in UCDP dataset are state-based conflicts, i.e. at least one state is involved, so all type of conflicts are retained this time (unlike the dyadic version from previously).

```{r}
ucdp %>%
  filter(year <=1992) %>%
  filter(intensity_level == 2) %>% # minor
  frq(type_of_conflict)
```


```{r}
names(ucdp)
ucdp_1state <- ucdp %>%
  # for character vbls: Replace blanks with NA
  mutate_if(is.character, list(~na_if(., ""))) %>% 
  
  # for all observations where type_of_conflict =1 (extrasystemic conflicts), =3 (intrastate without foreign intervention) or =4 (intrastate with foreign intervention), replace the values of side_b with NA, since those record non-state actors. For all observations where type_of_conflict =2 (interstate conflicts), retain their original side_b values, since those record state actors. Retain all side_a, side_a_2nd, side_b_2nd values for all types of conflicts, since they always record state actors.
  dplyr::mutate(side_b = ifelse(type_of_conflict == 1 
                         |type_of_conflict == 3
                         |type_of_conflict == 4, 
                         NA, side_b)) %>%
  # retain relevant variables
  dplyr::select(dyad_id:side_a,side_a_2nd,side_b,side_b_2nd,incompatibility,year,intensity_level,type_of_conflict) 
```

```{r}
# check: are there any observations for conflict type 1, 3 or 4 that do not have side_b NA coded?
ucdp_1state %>% 
  dplyr::filter(type_of_conflict == 1 
         |type_of_conflict == 3
         |type_of_conflict == 4) %>%
  dplyr::filter(!is.na(side_b)) # looks good, there are no such cases
```



#### wide format

Previously, `split_data()` function was created to split comma-separated string values for main (side_a or side_b) and secondary parties (side_a_2nd & side_b_2nd) involved in the conflict into separate columns (see Dyad-level --> Armed conflict UCDP/PRIO). We can reuse the function. (Careful to not load the midasr package, because it has a function with the same name i.e. split_data())
```{r}
load("spl_data.RData") # Careful to not load the midasr package, because it has a function with the same name i.e. split_data()

# Function to split comma-separated string values for main and secondary parties involved in side_a or side_b

# 
# spl_data <- function(data, a = "", b = "", a2 = "", b2 = "") {
#   # load packages
#   library(tidyr)
#   library(stringr)
#   
#   # Split the side_a and side_b columns into separate columns
#   data <- data %>%
#     # create new columns to store split
#     dplyr::mutate(
#       !!a := str_split(!!sym(a), ","),
#       !!b := str_split(!!sym(b), ","),
#       !!a2 := str_split(!!sym(a2), ","),
#       !!b2 := str_split(!!sym(b2), ",")
#    ) %>%
#     # turn each element of a list-column into a column
#     unnest_wider(!!sym(a), names_sep = "") %>% 
#     unnest_wider(!!sym(b), names_sep = "") %>%
#     unnest_wider(!!sym(a2), names_sep = "") %>% 
#     unnest_wider(!!sym(b2), names_sep = "") %>%
#     # column names for parties on side a and b to start with "a" & "b"
#     rename_with(
#       .fn = ~ str_replace(.x, a, "side_a"),
#       .cols = starts_with(a)
#    ) %>%
#     rename_with(
#       .fn = ~ str_replace(.x, b, "side_b"),
#       .cols = starts_with(b)
#    )
#   
#   return(data)
# }


```


```{r}
# apply function 
ucdp_1state.wide <- spl_data(ucdp_1state, a = "side_a", b= "side_b", a2 = "side_a_2nd", b2 = "side_b_2nd")
```

```{r}
# check
names(ucdp_1state.wide) 
# it seems there were conflict-years with up to 63 secondary parties involved on side a and up to 30 secondary parties involved on side b. That's a total of 95 parties involved

# Which conflict-year had so many states involved?
ucdp_1state.wide %>% 
  dplyr::filter(!is.na(side_a_2nd63)) %>% 
  View() # that's conflict number 11347 i.e. Mali war. The maximal number of belligerents involved were in 2021.


# Data with original comma-separated enumeration of belligerents
ucdp %>%  # = 11 columns
  dplyr::filter(conflict_id == 11347) %>%
  dplyr::select(1:4,6:7,9:12,14) %>% 
  View()
# In an internationalized intrastate conflict (ID 11347), the Mali government and its allied coalition of 63 states fought against Al-Qaeda (inc. non-state actors Ansar Dine, Red Berets military faction, MUJAO, AQIM, al-Murabitun and JNIM). Cf. https://en.wikipedia.org/wiki/Mali_War
```



#### long format

Pivot from wide to long based on unique conflict-dyad combinations. This function is slightly different from the previously written function to pivot the dyadic conflict dataset. This time, however, we are not just interested in conflicts between two states, but generally whether a state is engaged in armed conflict in a given year or not (be the other conflict party a state OR a non-state actor). So we'll alter the pivot function to take this into consideration.
```{r}
# Function to turn all unique dyad combinations of side_a and side_b involved in the same conflict (only one side needs to be a state actor, not both) into separate dyad-year observations

# save(piv_data2, file = "piv_data2.RData")
load("piv_data2.RData")

# piv_data2 <- function(data) {
#     # load packages
#     library(tidyr)
#     library(dplyr)
#     
#     # Gather all columns starting with "side_a" and "side_b" into two separate columns
#     data <- data %>%
#       pivot_longer(
#         cols = starts_with("side_a"),
#         names_to = "a_key",
#         values_to = "side_a"
#      ) %>%
#       pivot_longer(
#         cols = starts_with("side_b"),
#         names_to = "b_key",
#         values_to = "side_b"
#      ) %>%
#       select(-a_key, -b_key) %>%
#       
#       # At least one side, either side_a or side_b, should have a non-NA value
#       dplyr::filter(!is.na(side_a) | !is.na(side_b)) %>% 
#       unique() %>% # delete duplicates
#       # gather all values from side_a and side_b to one column
#       gather(key = "side", value = "value", side_a, side_b) %>% 
#       select(-side) %>% # delete signifier column
#       dplyr::rename(state1 = value) %>% # harmonize variable name to state1
#       # Filter out rows with missing values in column "state1"
#       dplyr::filter(!is.na(state1)) %>% 
#       unique() # delete duplicates
#     
#     return(data)
#   }

```


Turn wide to long format
```{r}
# apply function to wide conflict df
ucdp_1state.long <- piv_data2(ucdp_1state.wide)
names(ucdp_1state.long)

# inspect
head(ucdp_1state.long[,c(1:4,6:8)], 10) %>% 
  kbl() %>% 
  kable_classic()
```

Check
```{r}
# Check, whether the pivot to long function worked correctly, using examples of conflict_id 293 (Vietnam war) and conflict_id 300 (Cambodian-Vietnamese war)

# Compare before...
ucdp_1state.wide %>% 
  dplyr::filter(conflict_id == 293 | conflict_id == 300) %>%
  dplyr::filter(year == 1970)
```

```{r}
# ...and after
ucdp_1state.long3 %>%
  dplyr::filter(conflict_id == 293 | conflict_id == 300) %>%
  dplyr::filter(year == 1970) 
```

##### save
```{r}
# save(ucdp_1state.wide, file = "ucdp_1state.wide.RData")
# load("ucdp_1state.wide.RData")

# save(ucdp_1state.long, file = "ucdp_1state.long.RData")
# load("ucdp_1state.long.RData")
```


#### string cleaning
```{r}
# load("ucdp_1state.long.RData") 
conflict_incidence <- ucdp_1state.long # rename

# get rid of the "Government of" part in strings of states' names
conflict_incidence$state1 <- gsub(" Government of |Government of ", 
                                  "", conflict_incidence$state1)
```

```{r}
# compare before...
head(ucdp_1state.long[,c(8,4,7)], 10) %>% 
  kbl() %>%
  kable_classic()

# ...and after
head(conflict_incidence[,c(8,4,7)], 10) %>% 
  kbl() %>%
  kable_classic()

# remove old versions from environment
# rm(ucdp_1state)
# rm(ucdp_1state.wide)
# rm(ucdp_1state.long)
```


#### subset 1993-2023

Subset post Cold War (1993-2023) data and add time spells
--> dissolution of USSR on 26.12.1991, and subsequent changes & independence declarations during 1992, so observation period starts with 1993
```{r}
# Compute t-spells
conflict_incidence.pcw <- conflict_incidence %>% 
  # subset post Cold War period
  dplyr::filter(year >= 1993 & year <= 2023) %>%
  # create a variable t to assign time spell identifier
  dplyr::mutate(t = ifelse(year <= 1997, "t1",
                      ifelse(year <= 2002, "t2",
                           ifelse(year <= 2007, "t3",
                                  ifelse(year <= 2012, "t4",
                                         ifelse(year <= 2017, "t5",
                                                ifelse(year <= 2023, "t6"
                                                ))))))) %>% 
  # order columns
  dplyr::select(state1, t, year, everything()) %>%
  # order rows
  dplyr::arrange(year, state1)
```



#### country code harmonization

##### recode problematic/obsolete state designations
```{r}
# Yemen (North Yemen)
conflict_incidence.pcw <- conflict_incidence.pcw %>% 
  dplyr::mutate(state1 = if_else(state1 == "Yemen (North Yemen)", "Yemen", state1))

conflict_incidence.pcw <- conflict_incidence.pcw %>% 
  dplyr::mutate(location = if_else(location == "Yemen (North Yemen)", "Yemen", location))

# Russia (Soviet Union)
conflict_incidence.pcw <- conflict_incidence.pcw %>% 
  dplyr::mutate(state1 = if_else(state1 == "Russia (Soviet Union)", "Russia", state1))

conflict_incidence.pcw <- conflict_incidence.pcw %>% 
  dplyr::mutate(location = if_else(location == "Russia (Soviet Union)", "Russia", location)) 


# DR Congo (Zaire)
conflict_incidence.pcw <- conflict_incidence.pcw %>% 
  dplyr::mutate(state1 = if_else(state1 == "DR Congo (Zaire)", "Congo-Kinshasa", state1))

conflict_incidence.pcw <- conflict_incidence.pcw %>% 
  dplyr::mutate(location = if_else(location == "DR Congo (Zaire)", "Congo-Kinshasa", location))


# Zimbabwe (Rhodesia)
conflict_incidence.pcw <- conflict_incidence.pcw %>% 
  dplyr::mutate(state1 = if_else(state1 == "Zimbabwe (Rhodesia)", "Zimbabwe", state1))

conflict_incidence.pcw <- conflict_incidence.pcw %>% 
  dplyr::mutate(location = if_else(location == "Zimbabwe (Rhodesia)", "Zimbabwe", location))


# Cambodia (Kampuchea)
conflict_incidence.pcw <- conflict_incidence.pcw %>% 
  dplyr::mutate(state1 = if_else(state1 == "Cambodia (Kampuchea)", "Cambodia", state1))

conflict_incidence.pcw <- conflict_incidence.pcw %>% 
  dplyr::mutate(location = if_else(location == "Cambodia (Kampuchea)", "Cambodia", location))


# Serbia/Yugoslavia
# change Serbia/Yugoslavia name
conflict_incidence.pcw <- conflict_incidence.pcw %>% 
  dplyr::mutate(state1 = if_else(state1 == "Serbia (Yugoslavia)", "Serbia", state1))

conflict_incidence.pcw <- conflict_incidence.pcw %>% 
  dplyr::mutate(location = if_else(location == "Serbia (Yugoslavia)", "Serbia", location))
```



##### add country codes

```{r}
# library(countrycode)
# ?codelist # country codes designations

# cowen
conflict_incidence.pcw$cowen1 <- countrycode(conflict_incidence.pcw$state1, origin = 'country.name', destination = 'cow.name') # Serbia
## change Serbia/Yugoslavia in COW
conflict_incidence.pcw <- conflict_incidence.pcw %>% 
  dplyr::mutate(cowen1 = if_else(state1 == "Serbia", "Yugoslavia", cowen1))

# cow number
conflict_incidence.pcw$cown1 <- countrycode(conflict_incidence.pcw$cowen1, origin = 'country.name', destination = 'cown')

# cow character
conflict_incidence.pcw$cowc1 <- countrycode(conflict_incidence.pcw$cowen1, origin = 'country.name', destination = 'cowc')

# iso 3
conflict_incidence.pcw$iso1 <- countrycode(conflict_incidence.pcw$state1, origin = 'country.name', destination = 'iso3c')

# un m49
conflict_incidence.pcw$un1 <- countrycode(conflict_incidence.pcw$state1, origin = 'country.name', destination = 'un')

# harmonized country names
conflict_incidence.pcw$state1h <- countrycode(conflict_incidence.pcw$un1, origin = 'un', destination = 'country.name')

```



#### exclude states with NA in countrycodes

We'll delete any observations that have NA value in either the country codes cow OR in the un m49 systems. That means any observation that do not have valid values in both these ccode systems will be dropped. NAs in either of these two ccode systems mean the entity is not a formal member of the international system starting 1993, either because they no longer exist, are politically contested territories, united with another entity to form a new state, or are not recognized as an independent state for some other reason. E.g. Palestine, Hongkong, and Macao exist in the un m49 system because of observer or associated member status, but they are not in the cow system because of contested status as a sovereign state/territory. Taiwan, on the other hand, is not part of the UN m49 because it lost its seat in 1971, but remains in the cow ccode system.

```{r}
conflict_incidence.pcw %>%
  group_by(state1) %>%
  dplyr::filter(is.na(un1)) %>% View() # no NAs
```

```{r}
conflict_incidence.pcw <- conflict_incidence.pcw %>% 
  # delete iso alpha 3 & un m49 NA cases 
  dplyr::filter(!is.na(cown1) & !is.na(un1))
  # delete info for contested territories
  # dplyr::filter(iso1 != "HKG" & iso1 != "PSE" & iso1 != "TWN" & iso1 != "ESH" & iso1 != "MAC")

# check for duplicates
conflict_incidence.pcw[duplicated(conflict_incidence.pcw),] 
# conflict_incidence2[duplicated(conflict_incidence2) | duplicated(conflict_incidence2, fromLast = TRUE),]

colSums(is.na(conflict_incidence.pcw))
```

--> initially, the dyadic conflict data for 1993-2023 only records ca. 260 conflict-dyad-year level observations. Now, we have a total of ca. 5650 conflict-year level observation of states' engagement in an armed conflict for the same period.


#### recode
```{r}
# decriptives
library(sjmisc)
# frq(conflict_incidence.pcw$intensity_level) # 1=minor, 2 = war
# frq(conflict_incidence.pcw$incompatibility) #  1=territory,2=government,3=gov & ter
# frq(conflict_incidence.pcw$type_of_conflict) # 1=extra,2=inter,3=intra,4=inter intra

# library(dplyr)
conflict_incidence.pcw <- conflict_incidence.pcw %>% 
  # dplyr::mutate(intensity = ifelse(intensity_level == 1,0,1)) %>% 
  # dplyr::mutate(incompatibility = ifelse(incompatibility == 1,1,2)) %>% 
  dplyr::rename(intensity = intensity_level) %>%
  dplyr::select(-state1) %>%
  dplyr::select(state1h,  year, everything())%>% 
  dplyr::arrange(year, state1h)
```

There are only 9 cases out of ca. 5000 where the conflict occurred due both to territorial and political issues. In this case, the variable "incompatibility" has the value 3. I will duplicate these 9 cases and then change the value 3 to 1 (for territorial issue) for one set of observations and for the other the value 3 will be changed to 2 (for political issue). This way, the conflicts are documented as two separate observations as being fought 1) for territoral and 2) for political reasons.
```{r}
conflict_incidence.pcw <- conflict_incidence.pcw

# Loop through each row of conf_df
df1 <-data.frame()
df2 <-data.frame()

for (i in 1:nrow(conf_df)) {
  # Check if the value in the "incompatibility" column is 3
  if (conf_df$incompatibility[i] == 3) {
    # Duplicate the row and add it to conf_df1 & df2
    df1 <- rbind(df1, conf_df[i, ])
    df2 <- rbind(df2, conf_df[i, ])
  }
}

df1 <- df1 %>% 
  dplyr::mutate(incompatibility = ifelse(incompatibility == 3,1,incompatibility))
df2 <- df2 %>% 
  dplyr::mutate(incompatibility = ifelse(incompatibility == 3,2,incompatibility))

conflict_incidence.pcw <- conflict_incidence.pcw %>% 
  rbind(.,df1,df2) %>%
  dplyr::filter(!incompatibility == 3) %>%
  # rbind(.,conf_df_new) %>% 
  dplyr::arrange(state1h,year,t)
                                 
```



#### compute additional variables

```{r}
frq(conflict_incidence.pcw$type) # dummies for all factors. type factor 1 (extrasystemic conflict) will be deleted since there i no occurrence of this value
```

```{r}
conflict_incidence.pcw <- conflict_incidence.pcw %>%
  dplyr::rename(type = type_of_conflict) %>% # 1=extra,2=inter,3=intra,4=inter intra
  dplyr::mutate(
    # type_extra = ifelse(type == 1,1,0),# 1=extra,2=inter,3=intra,4=inter intra
    type_inter = ifelse(type == 2,1,0),
    type_intra = ifelse(type == 3,1,0),
    type_interintra = ifelse(type == 4,1,0),
    minor = ifelse(intensity == 1,1,0),
    war = ifelse(intensity == 2,1,0),
    issue_ter = ifelse(incompatibility == 1,1,0),
    issue_pol = ifelse(incompatibility == 2,1,0))
```


#### save unlabelled versions
```{r}
# conflict_incidence.pcw_ul <- conflict_incidence.pcw
# save(conflict_incidence.pcw_ul, file = "conflict_incidence.pcw_ul.RData")
# load("conflict_incidence.pcw_ul.RData")
```



### c) country-conflict level

We will first aggregate the data from incidence level to conflict level and then to year level.
```{r}
conflict_state_conf <- conflict_incidence.pcw %>% 
  group_by(state1h, iso1, un1, cowen1, cown1, cowc1, t, year, conflict_id) %>% # conflict-level variables
  dplyr::summarise(
    conf_dyad_ids = paste(unique(dyad_id), collapse = ", "), # which dyads?
    enem_n = n(), # how many enemies in the given year?
    conf_types = paste(unique(type), collapse = ", "),
    enem_inter = sum(type_inter),
    enem_intra = sum(type_intra),
    enem_interintra = sum(type_interintra),
    conf_incompatibility = paste(unique(incompatibility), collapse = ", "),
    enem_issue_ter = sum(issue_ter),
    enem_issue_pol = sum(issue_pol),
    conf_intensity = mean(intensity), # bw 1-2, from minor to war
    enem_minor = sum(minor),
    enem_war = sum(war),
    conf_locations = paste(unique(location), collapse = ", ")) %>%
  ungroup()
```

```{r}
## check
# names(conflict_state_conf)
frq(conflict_state_conf$conf_intensity) # mean, bw 1-2
frq(conflict_state_conf$conf_types) # enumeration
frq(conflict_state_conf$conf_incompatibility) # enumeration
```




### d) country-year level

aggregate from conflict to year level.
```{r}
conflict_state_year <- conflict_state_conf %>% 
  group_by(state1h, iso1, un1, cowen1, cown1, cowc1, t, year) %>% # conflict-level variables
  dplyr::summarise(
    conf_conflict_ids = paste(unique(conflict_id), collapse = ", "),
    conf_n = n(), # how many enemies in the given year?
    conf_dyad_ids = paste(unique(conf_dyad_ids), collapse = ", "), # which dyads?
    enem_n = sum(enem_n),
    conf_types = paste(unique(conf_types), collapse = ", "),
    # conf_type = mean(type),
    enem_inter = sum(enem_inter),
    enem_intra = sum(enem_intra),
    enem_interintra = sum(enem_interintra),
    # incompatibility = paste(unique(incompatibility), collapse = ", "),
    conf_incompatibility = paste(unique(conf_incompatibility), collapse = ", "),
    enem_issue_ter = sum(enem_issue_ter),
    enem_issue_pol = sum(enem_issue_pol),
    # intensity = paste(unique(intensity), collapse = ", "),
    conf_intensity = mean(conf_intensity), # bw 1-2, from minor to war
    enem_minor = sum(enem_minor),
    enem_war = sum(enem_war),
    conf_locations = paste(unique(conf_locations), collapse = ", ")) %>%
  ungroup()
```

```{r}
## compute additional variables
conflict_state_year <- conflict_state_year %>% 
  dplyr::mutate(d_conf = ifelse(conf_n > 0,1,0),
         d_inter = ifelse(enem_inter > 0,1,0),
         d_intra = ifelse(enem_intra > 0,1,0),
         d_interintra = ifelse(enem_interintra > 0,1,0),
         d_ter = ifelse(enem_issue_ter > 0,1,0),
         d_pol = ifelse(enem_issue_pol > 0,1,0),
         d_minor = ifelse(enem_minor > 0,1,0),
         d_war = ifelse(enem_war > 0,1,0))

```

```{r}
# names(conflict_state_year)
frq(conflict_state_year$conf_intensity) #  bw 1-2; 1 = minor / 2 = war
frq(conflict_state_year$conf_types) #  enumeration
frq(conflict_state_year$conf_incompatibility) #  enumeration
```


### check/comparison
```{r}
a <- conflict_incidence.pcw %>%
  dplyr::filter(state1h == "Iraq") #%>% View()
b <- conflict_state_conf %>%
  dplyr::filter(state1h == "Iraq") #%>% View()
c <- conflict_state_year %>%
  dplyr::filter(state1h == "Iraq") #%>% View()


View(a)
View(b)
View(c)
```





### e) further cleaning


#### strings
```{r}
# names(conflict_state_year)
# The "location" variable still contains duplicate country names within the same string value,so we define a function to remove those duplicates
remove_duplicates <- function(input_string) {
  unique_values <- unique(unlist(strsplit(input_string, ", ")))
  return(paste(unique_values, collapse = ", "))
}
# Apply the function to the location column
conflict_state_year$conf_locations <- sapply(conflict_state_year$conf_locations, remove_duplicates)
```

#### example interpretation
```{r}
conflict_state_year %>% 
  dplyr::filter(year == 2003 & iso1 == "USA")
```
@nga: e.g. in year 2003 we record for the USA four parties (states or non-state-actors) it is fighting against. In total, the USA was fighting against 4 different actors in 2003: one "enemy" was fought within the context of an interstate conflict (type 2), while the other 3 were fought in internationalized intrastate conflict(s) (type 4).

We know the USA is involved in internationalized intrastate, i.e. type 4 conflict(s) against 3 adversaries. But we don't know whether the USA is fighting against the 3 actors in 3 separate internationalized intrastate conflicts, or in one single conflict. The USA could also be one of the intrastate parties, or the foreign power intervening in such a conflict. 

The US was fighting one partie in a war (min. 1000 deaths), and 3 parties in minor conflict(s) (between 25-999 deaths).The US was in conflict with those 4 parties all due to a government related (political) issue(s).

The 3 different numbers in `conflict_id` tells us that the US was indeed involved in 3 different conflicts, each with their own unique ucdp conflict ID. `dyad_id`, on the other hand, gives us the unique ucdp dyad ID, indicating which actors the US was involved with. For other dyadic information (such as which countries or non-state actors it was opposing), see the dyadic ucdp dataset previously compiled.


#### check NAs & UN membership

##### NAs
```{r}
colSums(is.na(conflict_state_year)) # no missing data
```

##### UN members
```{r}
## UN member list
# un_mlist <- un_members %>% pull(state) %>% unique() %>% sort() # 193

## nodes in conflict_state_year data
conflict_state_year_mlist <- conflict_state_year$state1h %>% unique() %>% sort() # 144 were involved in a conflict
conflict_state_year_mlist
```

```{r}
## UN members not in dataset
missing_conflict <- setdiff(un_mlist, conflict_state_year_mlist) # 49 UN members that are not in the dataset i.e. did not experience any conflicts
missing_conflict

## Entities in data set that are not UN members
setdiff(conflict_state_year_mlist, un_mlist) # all nodes in the dataset are UN members
```



##### add missing UN members

We can assume that all UN countries that do not have any conflict incidence registered in the UCDP dataset simply did not experience any conflicts at all. These missing UN countries will be added as new data entries with the values 0 as country incidence-year observation.
```{r}
# library(dplyr)

# create copy before adding cases
# conflict_state_year_bu <- conflict_state_year
# conflict_state_year <- conflict_state_year_bu


# Create a template data frame with NA values for the country code variables
template <- conflict_state_year[1, ]
template[,] <- NA

# Create the missing country-year rows
missing_data <- expand.grid(state1h = missing_conflict, year = 1993:2023)
missing_data$state1h <- as.character(missing_data$state1h)

# Combine the template with the missing country-year rows
# Exclude the 'year' column from the template to avoid duplication
missing_data <- cbind(missing_data, template[rep(1, nrow(missing_data)), -which(names(template) %in% c("state1h", "year"))])

# Bind the new rows to the original conflict_state_year data frame
conflict_state_year <- bind_rows(conflict_state_year, missing_data)
```

```{r}
## Function to replace NA values based on variable type
replace_na <- function(df) {
  for (col in names(df)) {
    if (is.character(df[[col]])) {
      df[[col]][is.na(df[[col]])] <- "no conflicts"
    } else if (is.numeric(df[[col]])) {
      df[[col]][is.na(df[[col]])] <- 0
    } else if (is.integer(df[[col]])) {
      df[[col]][is.na(df[[col]])] <- 0
    }
  }
  return(df)
}

# Apply the function to the dataframe
conflict_state_year <- replace_na(conflict_state_year)
```


```{r}
## add time spells
conflict_state_year <- conflict_state_year %>% 
  # subset post Cold War period
  dplyr::filter(year >= 1993 & year <= 2023) %>%
  # create a variable t to assign time spell identifier
  dplyr::mutate(t = ifelse(year <= 1997, "t1",
                           ifelse(year <= 2002, "t2",
                                  ifelse(year <= 2007, "t3",
                                         ifelse(year <= 2012, "t4",
                                                ifelse(year <= 2017, "t5",
                                                       ifelse(year <= 2023, "t6"
                                                       ))))))) %>% 
  # order columns
  dplyr::select(state1h, t, year, everything()) %>%
  # order rows
  dplyr::arrange(year, state1h)
```

```{r}
## add ccodes
# cown
conflict_state_year$cown1 <- countrycode(conflict_state_year$state1h, origin = 'country.name', destination = 'cown')
conflict_state_year <- conflict_state_year %>%
  dplyr::mutate(cown1 = if_else(state1h == "Serbia", 345, cown1))

# cowc
conflict_state_year$cowc1 <- countrycode(conflict_state_year$cown1, origin = 'cown', destination = 'cowc')

# cowen
conflict_state_year$cowen1 <- countrycode(conflict_state_year$cown1, origin = 'cown', destination = 'cow.name')

# iso 3
conflict_state_year$iso1 <- countrycode(conflict_state_year$state1h, origin = 'country.name', destination = 'iso3c') # Kosovo

# un m49
conflict_state_year$un1 <- countrycode(conflict_state_year$state1h, origin = 'country.name', destination = 'un') # Kosovo, Taiwan Province of China

# harmonized country names
conflict_state_year$state1h <- countrycode(conflict_state_year$un1, origin = 'un', destination = 'country.name')

```




##### save unlabelled versions
```{r}
# conflict_state_conf_ul <- conflict_state_conf
# save(conflict_state_conf_ul, file = "conflict_state_conf_ul.RData")
# load("conflict_state_conf_ul.RData")

# conflict_state_year_ul <- conflict_state_year
# save(conflict_state_year_ul, file = "conflict_state_year_ul.RData")
# load("conflict_state_year_ul.RData")
```



### f) labels

#### conflict_year (inc. zero occurrances)

```{r}
# names(conflict_state_year)
# add vbl labels
# library(Hmisc)
label(conflict_state_year$iso1) <- "iso alpha 3 country code"
label(conflict_state_year$un1) <- "un m49 country code"
label(conflict_state_year$cown1) <- "cow numeric code"
label(conflict_state_year$cowen1) <- "cow name"
label(conflict_state_year$cowc1) <- "cow character code"
label(conflict_state_year$state1h) <- "harmonized name based on un m49"

label(conflict_state_year$conf_dyad_ids) <- "UCDP ID(s) for the conflict dyad(s) the state was involved in in a given year"
label(conflict_state_year$conf_conflict_ids) <- "UCDP ID(s) for the conflict(s) the state was involved in in a given year"
label(conflict_state_year$conf_locations) <- "location(s) of conflict"
label(conflict_state_year$conf_n) <- "in conflict(s) with how many parties in a given year?"
label(conflict_state_year$d_conf) <- "involved in conflict in given year"
label(conflict_state_year$conf_types) <- "1=extrasystemic, 2=interstate, 3=intrastate, 4=intrastate with foreign intervention"
label(conflict_state_year$conf_incompatibility) <- "list of conflict issues encountered in given year, 1 = ter, 2 = pol"
label(conflict_state_year$enem_n) <- "number of enemies in given year?"
label(conflict_state_year$enem_inter) <- "number of enemies fought in interstate conf in given year"
label(conflict_state_year$enem_intra) <- "number of enemies fought in intrastate conf in given year"
label(conflict_state_year$enem_interintra) <- "number of enemies fought in internationalized interstate conf in given year"

label(conflict_state_year$d_inter) <- "involved in inter conf in given year"
label(conflict_state_year$d_intra) <- "involved in intra conf in given year"
label(conflict_state_year$d_interintra) <- "involved in interintra conf in given year"
label(conflict_state_year$enem_issue_ter) <- "number of enemies fought due to territory issue"
label(conflict_state_year$enem_issue_pol) <- "number of enemies fought due to government issue"
label(conflict_state_year$d_ter) <- "involved in conflict about territory issue"
label(conflict_state_year$d_pol) <- "involved in conflict about government issue"
label(conflict_state_year$enem_minor) <- "number of enemies fought in minor conflicts (25-999 deaths)"
label(conflict_state_year$enem_war) <- "number of enemies fought in wars (min. 1000 deaths)"
label(conflict_state_year$d_minor) <- "involved in minor conflict"
label(conflict_state_year$d_war) <- "involved in war"
label(conflict_state_year$conf_intensity) <- "average intensity of conflict(s) in given year. 0 = no conflict, 1 = minor, 2 = war, 1-2 = in between"
```



#### conflict_conf
```{r}
# names(conflict_state_conf)
# add vbl labels
# library(Hmisc)
label(conflict_state_conf$iso1) <- "iso alpha 3 country code"
label(conflict_state_conf$un1) <- "un m49 country code"
label(conflict_state_conf$cown1) <- "cow numeric code"
label(conflict_state_conf$cowen1) <- "cow name"
label(conflict_state_conf$cowc1) <- "cow character code"
label(conflict_state_conf$state1h) <- "harmonized name based on un m49"

label(conflict_state_conf$conflict_id) <- "UCDP ID(s) for the conflict dyad(s) the state was involved in in a given conflict"
label(conflict_state_conf$conf_dyad_ids) <- "UCDP ID(s) for the conflict(s) the state was involved in in a given conflict"
label(conflict_state_conf$conf_locations) <- "location(s) of conflict"

label(conflict_state_conf$conf_types) <- "1=extrasystemic, 2=interstate, 3=intrastate, 4=intrastate with foreign intervention"
label(conflict_state_conf$conf_incompatibility) <- "1 = ter, 2 = pol"
label(conflict_state_conf$enem_n) <- "number of enemies in given conflict"
label(conflict_state_conf$enem_inter) <- "number of enemies fought in interstate conf in given conflict"
label(conflict_state_conf$enem_intra) <- "number of enemies fought in intrastate conf in given conflict"
label(conflict_state_conf$enem_interintra) <- "number of enemies fought in internationalized interstate conf in given conflict"

label(conflict_state_conf$enem_issue_ter) <- "number of enemies fought due to territory issue in given conflict"
label(conflict_state_conf$enem_issue_pol) <- "number of enemies fought due to government issue in given conflict"
label(conflict_state_conf$enem_minor) <- "number of enemies fought in minor conflicts (25-999 deaths) in given conflict"
label(conflict_state_conf$enem_war) <- "number of enemies fought in wars (min. 1000 deaths) in given conflict"
label(conflict_state_conf$conf_intensity) <- "average intensity of conflict(s) in given conflict. bw 1-2, 1=minor 2=war"
```



#### conflict_incidence
```{r}
# names(conflict_incidence.pcw)
# add vbl labels
# library(Hmisc)
label(conflict_incidence.pcw$iso1) <- "iso alpha 3 country code"
label(conflict_incidence.pcw$un1) <- "un m49 country code"
label(conflict_incidence.pcw$cown1) <- "cow numeric code"
label(conflict_incidence.pcw$cowen1) <- "cow name"
label(conflict_incidence.pcw$cowc1) <- "cow character code"
label(conflict_incidence.pcw$state1h) <- "harmonized name based on un m49"

label(conflict_incidence.pcw$dyad_id) <- "UCDP unique conflict dyad ID"
label(conflict_incidence.pcw$conflict_id) <- "UCDP unique conflict ID"
label(conflict_incidence.pcw$location) <- "location of conflict?"
label(conflict_incidence.pcw$type) <- "1=extrasystemic, 2=interstate, 3=intrastate, 4=intrastate with foreign intervention"
label(conflict_incidence.pcw$incompatibility) <- "1=territory,2=political"
label(conflict_incidence.pcw$intensity) <- "1=minor,2=war"

label(conflict_incidence.pcw$type_inter) <- "interstate conflict?"
label(conflict_incidence.pcw$type_intra) <- "intrastate conflict?"
label(conflict_incidence.pcw$type_interintra) <- "internationalized interstate conflict?"

label(conflict_incidence.pcw$minor) <- "minor (<1000 deaths)?"
label(conflict_incidence.pcw$war) <- "war (>= 1000 deaths)?"

label(conflict_incidence.pcw$issue_ter) <- "minor (<1000 deaths)?"
label(conflict_incidence.pcw$issue_pol) <- "war (>= 1000 deaths)?"

label(conflict_incidence.pcw$type_interintra) <- "internationalized interstate conflict?"
label(conflict_incidence.pcw$type_interintra) <- "internationalized interstate conflict?"

```


### g) descriptive stats

```{r}
nrow(conflict_incidence.pcw) # ca. 5660
nrow(conflict_state_conf) # ca. 4271
nrow(conflict_state_year) # ca. 3677
```


```{r}
conflict_state_year %>% 
  group_by(state1h)
# all 193 UN countries in the data frame

conflict_state_year %>% 
  group_by(year)
# covering 31 years
range(conflict_state_year$year)
```
--> aggregated data has 3677 recorded country-year observations

### descriptive stats

```{r}
# How many states in total between 1993-2023?
conflict_state_year %>% 
  group_by(state1h) %>%
  dplyr::summarise(n = n())
unique(conflict_state_year$state1h) # 166

# How many conflicts do each unique dyad have, broken down by t spell?
# conflict_state_year %>% 
#   group_by(t, state1h) %>% 
#   dplyr::summarise(n = n())

# How many conflicts do each unique dyad have in t=5 (i.e. 2012-2016)
# conflict_state_year %>% 
#   dplyr::filter(t == "t5") %>% 
#   group_by(state1h) %>% 
#   dplyr::summarise(n = n())

# check nas
colSums(is.na(conflict_state_year))
```


### save
```{r}
# save(conflict_incidence, file = "conflict_incidence.RData")
# load("conflict_incidence.RData")
# save(conflict_incidence.pcw, file = "conflict_incidence.pcw.RData")
# load("conflict_incidence.pcw.RData")
# 
# save(conflict_incidence.pcw, file = "conflict_incidence.pcw.RData")
# load("conflict_incidence.pcw.RData")
# save(conflict_state_conf, file = "conflict_state_conf.RData")
# load("conflict_state_conf.RData")
# save(conflict_state_year, file = "conflict_state_year.RData")
load("conflict_state_year.RData")
```






# V) NODAL DATA: PREP FOR NETWORK OBJECT

Currently, missing data in attributes is not supported by tergm. So we'll have to deal with them somehow.

## V.1) Missing countries in datasets

### analyse

```{r}
# missing_conflict # 0
# missing_milex # 31
# missing_gdp # 4
# missing_pop # 4
# missing_vdem # 21

# total = 33
missing_states <- c(missing_milex, missing_gdp, missing_pop, missing_vdem) %>% unique() %>% sort()
missing_states
```

```{r}
cov_agg %>% pull(sov_score) %>% descr()
cov_agg %>% pull(democracy) %>% descr()
```


-> 33 nodes with complete missing data for all country-year observations in specific data sets. These are mostly microstates and a few isolated/unstable countries such as North Korea, Cuba, Syria, and Somalia.


### list of microstates and isolated/unstable states

@nga: After analysing the data, we mostly have NAs for the microstates, esp. for the military expenditure and the vdem data sets. We will therefore exclude these microstates from the analysis.

Microstates are those defined as having a population with less than 250 000 individuals. (Gleditsch & Ward 2001)

List of microstates (<250k population count) as of 2001
```{r}
# library(states)
# library(countrycode)
microstates <- cowstates %>% dplyr::filter(microstate == TRUE) %>% dplyr::select(-c(start,end,microstate))

## ccodes
microstates$un1 <- countrycode(microstates$cowcode, origin = 'cown', destination = 'un')
microstates$state1h <- countrycode(microstates$un1, origin = 'un', destination = 'country.name')
```

```{r}
## list of microstates Gleditch & Ward 2001
micros <- microstates$state1h %>% unique() %>% sort()
setdiff(missing_states, micros) # missing states that are not microstates
setdiff(micros, missing_states) # microstates that are not missing in the data = Seychelles
```

@nga: Our missing states that are not defined as microstates by Gleditsch and Ward are still very small countries, with population count in 2001 not much above the 250k threshhold suggested by G&W.

- Bahamas 400k (in 2023), 300k (in 2001)
- Barbados 290k (in 2023), 270k (in 2001)
- Belize 450k (in 2023), 256 (in 2001)
- Bhutan 770k (in 2023), 570k (in 2001)
- Brunei 440k (in 2023), 330k (in 2001)
- Comoros 990k (in 2023), 550k (in 2001)
- Maldives 400k (in 2023), 270k (in 2001)
- Solomon Islands 740k (in 2023), 425k (in 2001)
- Suriname 640k (in 2023), 470k (in 2001)

The 4 bigger countries missing in our data are isolated or politically unstable states, which is why there is no reliable data about them. These states are Cuba, North Korea, Somalia, and Syria. These countries will be excluded from the analysis.


### drop countries with complete missing data

These countries are excluded due to complete missing country-year observations for some one or more covariate variable(s).

@nga: These 33 states constitute ca. 205 out of 11480 entries, which makes up only 1.8% of the weapons trade. So it should not impact the analysis too much even if we exclude these states.

ETC BLABLA
  [Countries have remaining NA values ranging from 1 to 31 - which means the country has no valid milex.pcw2 information during the total observation period (31 years, 1993-2023). This is the case for 31 countries inc. Cuba, North Korea, Somalia and Syria. So for these 4 countries, no imputation is possible since there are no values to work with.]

[NODES DROPPED]: I argue that these are some of the most politically isolated countries (e.g. Cuba, North Korea) or microstates. They have many NA values probably because they either 1) do not have significant trade relations with the outside world for a prolonged period, or 2) they want to keep their military spending a secret. 

[In either case, we can assume that the spending of isolated states or microstates is so negligible relative to the rest of the world that we can impute a value close to 0. 
  This is not to say that North Korea is not pouring quite some resources into developing their own nuclear arsenal. However, relative to the world, their spending is likely negligible.]

[So for the countries without any milex infos, I will impute the value of 0.0001. (to avoid any non-valid, i.e. Inf values during rescaling operations later on).]

```{r}
iat.pcw %>% dplyr::filter(state1h %in% missing_states | state2h %in% missing_states) # 205 dyad observations involving one of the states to be dropped from the analysis
nrow(iat.pcw) # 205 out of ca. 11480 observations = 1.8%
205/11480
```

Drop countries
```{r}
milex.pcw2 <- milex.pcw %>%  dplyr::filter(!(state1h %in% missing_states))
gdp.pcw2 <- gdp.pcw %>%  dplyr::filter(!(state1h %in% missing_states))
population.pcw2 <- population.pcw %>%  dplyr::filter(!(state1h %in% missing_states))
vdem.pcw2 <- vdem.pcw %>%  dplyr::filter(!(state1h %in% missing_states))
conflict.pcw2 <- conflict_state_year %>%  dplyr::filter(!(state1h %in% missing_states))
```



### save
```{r}
# save(milex.pcw2, file = "milex.pcw2.RData")
load("milex.pcw2.RData")
# 
# save(gdp.pcw2, file = "gdp.pcw2.RData")
load("gdp.pcw2.RData")
# 
# save(population.pcw2, file = "population.pcw2.RData")
load("population.pcw2.RData")
# 
# save(vdem.pcw2, file = "vdem.pcw2.RData")
load("vdem.pcw2.RData")
# 
# save(conflict.pcw2, file = "conflict.pcw2.RData")
load("conflict.pcw2.RData")

load("un_mlist.RData")
```

```{r}
string1 <- unique(c(milex.pcw2$state1h, gdp.pcw2$state1h, 
                     population.pcw2$state1h, vdem.pcw2$state1h, 
                     conflict.pcw2$state1h))
string2 <- unique(un_mlist$state)
setdiff(string2, string1) #  in string2 but missing in string1
```





## V.2) NAs & imputation

**general imputation strategy**
  @nga: For the countries that only have missing values for certain country-year observations, I will use the na.fill() function from the zoo package to perform interpolation using linear approximation and extrapolation using the first and last available (non NA) values.


NAs overview
```{r}
# count the number of NA values in each column in original dataset
colSums(is.na(gdp.pcw)) # ca. 160 
colSums(is.na(population.pcw)) # ca. 180 initially
colSums(is.na(conflict.pcw2)) # 0
colSums(is.na(milex.pcw)) # 520
colSums(is.na(vdem.pcw2)) # coups ca. 495, sov_territory 17
```

```{r}
# count the number of NA values after excluding the 33 states
colSums(is.na(gdp.pcw2)) # 82
colSums(is.na(population.pcw2)) # 80
colSums(is.na(conflict.pcw2)) # 0
colSums(is.na(milex.pcw2)) # 394
colSums(is.na(vdem.pcw2)) # coups 489, sov_territory 17
```
There are still many NAs left. These will be imputed based on available data.



### milex data interpolation & extrapolation

```{r}
colSums(is.na(milex.pcw2)) # 394
milex.pcw2 %>%
  dplyr::filter(is.na(milex)) %>%
  group_by(state1h, iso1) %>% 
  dplyr::summarise(n_missings = n()) %>% 
  dplyr::arrange(desc(n_missings)) %>% 
  print()
```

```{r}
# linear interpolation with extension of first and last available data point in time series
library(zoo)
milex_imp <- milex.pcw2 %>%
  group_by(state1h, iso1) %>%
  dplyr::mutate(milex_i = na.fill(milex, "extend")) %>% 
  ungroup() 
```

check imputed data
```{r}
# options(scipen = 999)
milex_imp %>% 
  dplyr::filter(iso1 == "TKM") %>% View()

milex_imp %>% 
  dplyr::filter(iso1 == "UZB") %>% View()

milex_imp  %>% 
  dplyr::filter(state1h == "Eritrea") %>%  View()

milex_imp %>% 
  dplyr::filter(iso1 == "QAT") %>% View() 

milex_imp %>% 
  dplyr::filter(iso1 == "LAO") %>% View()

milex_imp %>% 
  dplyr::filter(state1h == "Sudan") %>% View()

milex_imp  %>% 
  dplyr::filter(iso1 == "VNM") %>%  View()

milex_imp  %>% 
  dplyr::filter(iso1 == "LBY") %>%  View()

milex_imp  %>% 
  dplyr::filter(iso1 == "UKR") %>% View()

milex_imp  %>% 
  dplyr::filter(iso1 == "RUS") %>% View()
```

```{r}
# count NAs
colSums(is.na(milex_imp)) # 0 NAs remaining in the imputed milex_i variable
```



### vdem data imputed

```{r}
colSums(is.na(vdem.pcw2)) # coups 489, sov ter 17

# coups: timor-leste and montenegro missing 11-12 country year observations. All the other countries miss 3 coutry-year observations each, which are the years 2021-2023.
vdem.pcw2 %>%
  dplyr::filter(is.na(coups)) %>%
  group_by(state1h, iso1) %>% 
  dplyr::summarise(n_missings = n()) %>% 
  dplyr::arrange(desc(n_missings)) %>% 
  print()

# sov territory: timor-leste & montenegro are missing 8-9 country-year observations
vdem.pcw2 %>%
  dplyr::filter(is.na(sov_territory)) %>%
  group_by(state1h, iso1) %>% 
  dplyr::summarise(n_missings = n()) %>% 
  dplyr::arrange(desc(n_missings)) %>% 
  print()
```
MNE has NAs for coups and sov_territory data in the years 1993-2005. From researches, we know that MNE was part of Yugoslavia until 2005, but did not try any coups. As part of YUG, its territorial sovereignty belonged to YUG, but we can argue that it still had regional control over its territory to some degree. So we'll input the value 33 (i.e. 35%) to the variable sov_territory. Since Montenegro was not in major  political conflict with Serbia, it will receive the value 0 to the variable coup.

As for TLS, it has NAs for coups in the years 1993-2001 and 2021-2023. NAs for sov_territory in 1993-2021. TLS only became independent from Indonesia in 2002, so we can impute the value 33 for its sov_territory for the time up until 2002. Since it was in resistence to Indonesia and internally not stable, it will receive the value 1 for coups between 1993-2001 to reflect instability of domestic politics.

As for the remaining countries that lack data for 2021-2023, the last available data point from 2020 will be extended.

```{r}
## imputation by hand
vdem_imp <- vdem.pcw2 %>% 
  dplyr::mutate(coups_ih = if_else(iso1 == "MNE" & year %in% 1998:2005, 0, coups),
         sov_ter_ih = if_else(iso1 == "MNE" & year %in% 1998:2005, 33, sov_territory)) %>%
  dplyr::mutate(coups_ih = if_else(iso1 == "TLS" & year %in% 1993:2001, 1, coups_ih),
         sov_ter_ih = if_else(iso1 == "TLS" & year %in% 1993:2001, 33, sov_ter_ih))
```

```{r}
# linear interpolation with extension of first and last available data point in time series
vdem_imp <- vdem_imp %>%
  group_by(state1h, iso1) %>%
  dplyr::mutate(coup_i = na.fill(coups_ih, "extend"),
         sov_ter_i = na.fill(sov_ter_ih, "extend")) %>% 
  ungroup() 
```


```{r}
## check imputed data

vdem_imp %>% 
  dplyr::filter(iso1 == "MNE") %>% View()

vdem_imp %>% 
  dplyr::filter(iso1 == "TLS") %>% View()

vdem_imp %>% 
  dplyr::filter(state1h == "Sudan") %>% View()

vdem_imp %>% 
  dplyr::filter(iso1 == "AFG") %>% View() 

vdem_imp %>% 
  dplyr::filter(iso1 == "ALB") %>% View()
```

```{r}
# count NAs
colSums(is.na(vdem_imp)) # 0 NAs remaining in the imputed sov_ter_i and coups_i variables

```


### gdp data imputed

```{r}
colSums(is.na(gdp.pcw2)) # 82
gdp.pcw2 %>%
  dplyr::filter(is.na(gdp)) %>%
  group_by(state1h, iso1) %>% 
  dplyr::summarise(n_missings = n()) %>% 
  dplyr::arrange(desc(n_missings)) %>% 
  print()
# Somalia with 18 missing country-year observations, South Sudan 19, Syria 13 etc..
```

```{r}
# linear interpolation with extension of first and last available data point in time series
gdp_imp <- gdp.pcw2 %>%
  group_by(state1h, iso1) %>%
  dplyr::mutate(gdp_i = na.fill(gdp, "extend")) %>% 
  ungroup() 
```

check imputed data
```{r}
# options(scipen = 999)
gdp_imp %>% 
  dplyr::filter(iso1 == "SSD") %>% View()

gdp_imp %>% 
  dplyr::filter(iso1 == "AFG") %>% View()

gdp_imp %>% 
  dplyr::filter(iso1 == "LBR") %>% View() 

gdp_imp %>% 
  dplyr::filter(iso1 == "MNE") %>% View()
```

```{r}
# count NAs
colSums(is.na(gdp_imp)) # 0 NAs remaining in the imputed gdp_i variable
```


### population.pcw2 data imputed

```{r}
colSums(is.na(population.pcw2)) # 80
## frequency of NAs by country
population.pcw2 %>%
  dplyr::filter(is.na(population)) %>%
  group_by(state1h) %>% 
  dplyr::summarise(n_missings = n()) %>% 
  dplyr::arrange(desc(n_missings)) %>% 
  print()

# South Sudan with 18 missing country-year observations, Afghanistan 10 etc..

```

```{r}
# linear interpolation with extension of first and last available data point in time series
population_imp <- population.pcw2 %>%
  group_by(state1h, iso1) %>%
  dplyr::mutate(population_i = na.fill(population, "extend")) %>% 
  ungroup() 
```

check imputed data
```{r}
# options(scipen = 999)
population_imp %>% 
  dplyr::filter(iso1 == "SSD") %>% View()

population_imp %>% 
  dplyr::filter(iso1 == "AFG") %>% View()
```

```{r}
# count NAs
colSums(is.na(population_imp)) # 0 NAs remaining in the imputed population_i variable
```




### conflict data (already imputed previously?)
- missing country-year observations are coded as 0 representing absent conflict incidence



### save
```{r}
# save(milex_imp, file = "milex_imp.RData")
# load("milex_imp.RData") 

# save(vdem_imp, file = "vdem_imp.RData")
# load("vdem_imp.RData") 

# save(gdp_imp, file = "gdp_imp.RData")
# load("gdp_imp.RData") 

# save(population_imp, file = "population_imp.RData")
# load("population_imp.RData") 
```


## V.3) Missing country-year observations

```{r}
milex_imp %>%
  group_by(state1h, iso1) %>%
  dplyr::summarise(n_years = n(),
            n_missing = 31 - n_years) %>% 
  dplyr::filter(n_missing > 0) %>% 
  dplyr::arrange(desc(n_missing))
```

```{r}
gdp_imp %>%
  group_by(state1h, iso1) %>%
  dplyr::summarise(n_years = n(),
            n_missing = 31 - n_years) %>% 
  dplyr::filter(n_missing > 0) %>% 
  dplyr::arrange(desc(n_missing))
```

```{r}
population_imp %>%
  group_by(state1h, iso1) %>%
  dplyr::summarise(n_years = n(),
            n_missing = 31 - n_years) %>% 
  dplyr::filter(n_missing > 0) %>%
  dplyr::arrange(desc(n_missing))
```

```{r}
vdem_imp %>%
  group_by(state1h, iso1) %>%
  dplyr::summarise(n_years = n(),
            n_missing = 31 - n_years) %>% 
  dplyr::filter(n_missing > 0) %>%
  dplyr::arrange(desc(n_missing))
# Missing 5 entries for Montenegro & 18 for South Sudan
```

```{r}
vdem_imp %>% dplyr::filter(iso1 == "MNE") %>% View() # missing entries prior to 2006
vdem_imp %>% dplyr::filter(iso1 == "SSD") %>% View() # missing entries prior to 2011
```
--> Montenegro separated from Serbia in 2006, so it did not exist as a sovereign entity before then. Same for South Sudan. So we'll drop these observations from the analysis. Additionally, while we're at it, Timor-Leste will also be dropped, as it only became independent in 2002.
We'll drop these countries later once the data is merged.

```{r}
conflict.pcw2 %>%
  group_by(state1h, iso1) %>%
  dplyr::summarise(n_years = n(),
                   n_missing = 31 - n_years) %>% 
  dplyr::filter(n_missing > 0) %>% 
  dplyr::arrange(desc(n_missing))
```
--> Many missing country-year observations because when conflicts are missing for a country in a given year, this info was not entered in the dataset. e.g. Argentina etc seem to be relatively peaceful, as it has only one country-year entry for being involved in a conflict.
We'll add these missing information about non-conflicts later once the data is merged.





## V.4) Merge cov dfs

### prep

```{r}
## check types
# typeof(milex_imp$iso1)
# typeof(gdp_imp$iso1)
# typeof(population_imp$iso1)
# typeof(vdem_imp$iso1)
# typeof(conflict.pcw2$iso1)
```

```{r}
## check class
# str(milex_imp$iso1)
# str(gdp_imp$iso1)
# str(population_imp$iso1)
# str(vdem_imp$iso1)
# str(conflict.pcw2$iso1)

# str(milex_imp$state1h)
# str(gdp_imp$state1h)
# str(population_imp$state1h)
# str(vdem_imp$state1h)
# str(conflict.pcw2$state1h)
```

```{r}
## type harmonizations (else merging will not work)
# vdem_imp$year <- as.integer(vdem_imp$year)
# milex_imp$year <- as.integer(milex_imp$year)
# gdp_imp$year <- as.integer(gdp_imp$year)
# population_imp$year <- as.integer(population_imp$year)
# conflict.pcw2$year <- as.integer(conflict.pcw2$year)
```

```{r}
# conflict.pcw2$year <- unclass(conflict.pcw2$year)
# vdem_imp$year <- unclass(vdem.pcw2$year)
# milex_imp$year <- unclass(milex.pcw2$year)
# gdp_imp$year <- unclass(gdp_imp$year)
# population_imp$year <- unclass(population_imp$year)
```

```{r}
## harmonize class i.e. unlabel
library(Hmisc)
library(dplyr)
library(purrr)

dfs <- list(vdem_imp, milex_imp, gdp_imp, population_imp, conflict.pcw2)

# Function to unclass all columns in a dataset
unclass_df <- function(df) {
  as.data.frame(lapply(df, unclass))
}

# Loop through each dataset in the list and unclass all columns
dfs_unclassed <- lapply(dfs, unclass_df)

# Retrieve unclassed datasets
vdem_imp <- dfs_unclassed[[1]]
milex_imp <- dfs_unclassed[[2]]
gdp_imp <- dfs_unclassed[[3]]
population_imp <- dfs_unclassed[[4]]
conflict_imp <- dfs_unclassed[[5]]

```



### merge
```{r}
# Use outer i.e. full join to merge data frames
library(purrr)
cov <- list(milex_imp, gdp_imp, population_imp, vdem_imp, conflict_imp) %>% 
  purrr::reduce(full_join, by=c("iso1", "state1h", "un1", "cowen1", "cown1", "cowc1", "year", "t")) %>%
  dplyr::select(state1h, iso1, un1, cown1, cowc1, cowen1, year, t, everything()) %>%
  dplyr::arrange(year, state1h)
```


```{r}
names(cov)
# delete old variables with NAs, before imputation
cov <- cov %>% 
  dplyr::select(-c(coups,coups_ih,sov_territory,sov_ter_ih, milex, gdp, population))
```


### drop young countries (final n = 157)

Since Montenegro and South Sudan have missing country-year entries since they are relatively young countries, they will be excluded from the analysis. Additionally, Timor-Leste also only became independent in 2002, so it will also be dropped from the analysis.

```{r}
# young countries to be dropped
too_young <- c("Montenegro", "South Sudan", "Timor-Leste")
cov <- cov[!cov$state1h %in% too_young, ]
```

```{r}
# library(sjmisc)
frq(cov$sov_independent) # now we only have entries from independent i.e. sovereign states
cov <- cov %>% dplyr::select(-sov_independent)
```


#### share of excluded iat transfer observations

@nga: after dropping the 36 nodes (microstates and younger states), we should determine how much of the iat data is lost. Due to the exclusion of these countries, we only have 
```{r}
# Define the excluded states by finding the difference between UN members and the union of state1h and state2h
un_members <- unique(un_members$state) # all existing 193 UN members
included <- unique(cov$state1h) # 157 UN members included in analysis
excluded <- setdiff(un_members, included) # 36 UN members excluded from analysis

iat_all <- union(iat.pcw$state1h, iat.pcw$state2h) # 179 UN members in iat network
iat_dropped <- setdiff(iat_all,included) # iat network members, but not in the list of  countries included in analysis --> i.e. will be dropped because these countries have insufficient covariate data or are too young
```

```{r}
# number of arms transfer observations to be excluded = 233
iat.pcw %>% 
  dplyr::filter(state1h %in% iat_dropped | state2h %in% iat_dropped) %>% 
  nrow()

# number of all arms transfer observations = 11481
iat.pcw %>% nrow()

233/11481 # share of dropped transfer observations ca. 0.02 = 2%
```


### add data about non-conflicts

NAs in conflict variables are coded as 0 to represent absent conflict incidence. Since we merged NA-free data sets, the NAs in the merged cov df can only be incurred because of missing country-year entries from the conflict data set. 

```{r}
cov <- cov %>%
  dplyr::mutate(across(where(is.numeric), ~ ifelse(is.na(.), 0, .))) %>%
  dplyr::mutate(across(where(is.character), ~ ifelse(is.na(.), "no conflict", .)))

colSums(is.na(cov))
```

### check duplicates
```{r}
# Check duplicates
nrow(duplicates <- cov[duplicated(cov) | duplicated(cov, fromLast = TRUE), ])
```



### label time spells
```{r}
# library(dplyr)
# library(haven)
cov <- cov %>%
  dplyr::mutate(
    t = haven::labelled(t, 
                        c("1993-1997" = "t1", 
                          "1998-2002" = "t2",
                          "2003-2007" = "t3",
                          "2008-2012" = "t4",
                          "2013-2017" = "t5",
                          "2018-2023" = "t6"),
                        label = "time spell"))
# check
# head(cov$t)
```


### descriptive stats
```{r}
# statistics for 2023 by country
cov %>% 
  dplyr::filter(year == 2023) # 178 countries are in the dataset for 2023

# How much did Ukraine and Russia spent on their military in 2023?
cov %>% 
  dplyr::filter(year == 2023) %>% 
  dplyr::filter(state1h == "Ukraine" | state1h == "Russia")
# milex.pcw2 Ukraine ca. 44000; milex.pcw2 Russia ca. 72000 --> Ukraine spent about 61% of what Russia spent

cov %>%
  dplyr::filter(state1h == "Iraq") #%>% View()
```

### save
```{r}
# save(cov, file = "cov.RData") # as R data file
# load("cov.RData") 
```


## V.5) Aggregate by t (157 * 6 = 942 obs)

I will aggregate the covariates from the country-year level to the 6 country-time spells level. This is necessary, as we will later assign the covariate information to the networks at 6 time spells. Dyadic data needs not be aggregated to t-level, since igraph/statnet has function arguments to delete multiple edges and aggregate edge attribute information automatically.
--> aggregate cov information for each t time spell for each country (i.e. each country can have max 6 entries, one per time spell)

```{r}
unique(cov$state1h) # n = 157 countries
unique(cov$t) # t = 6 time spells
names(cov) # variables
names(conflict.pcw2)
```

### summarise
```{r}
## cov aggregated by t
library(dplyr)
cov_agg <- cov %>%
  group_by(state1h, iso1, un1, cown1, cowc1, cowen1, t) %>%
  dplyr::summarise(
    milex = mean(milex_i, na.rm = T),  # yearly av. military spending during t
    gdp= mean(gdp_i, na.rm = T),       # yearly av. gdp_imp 
    population = mean(population_i, na.rm = T), # yearly av. population_imp during t
    democracy = mean(democracy, na.rm = T),     # yearly av. democracy score during t
    sov_dom = mean(sov_domestic, na.rm = T),    # yearly av. sov score (dom) during t
    sov_for = mean(sov_foreign, na.rm = T),     # yearly av. sov score (for) during t
    sov_score = mean(sov_score, na.rm = T),     # sov domestic & sov foreign during t together
    sov_ter = mean(sov_ter_i, na.rm = T),         # yearly av. sov score (ter)
    coups = sum(coup_i, na.rm = T),         # number of coups in t

    ### ucdp
    conf_conf_ids = paste(unique(conf_conflict_ids), collapse = ", "),
    conf_dyad_ids = paste(unique(conf_dyad_ids), collapse = ", "),
    enem_inter = sum(enem_inter, na.rm = T),  # number of conflicts in t
    enem_intra = sum(enem_intra, na.rm = T),  # number of conflicts in t
    enem_interintra = sum(enem_interintra, na.rm = T),  # number of conflicts in t
    enem_ter = sum(enem_issue_ter, na.rm = T),  # number of confl due to ter in t
    enem_pol = sum(enem_issue_pol, na.rm = T),  # number of confl due to pol in t
    enem_minor = sum(enem_minor, na.rm = T),  # number of minor conflicts in t
    enem_war = sum(enem_war, na.rm = T)) %>%   # number of wars in t
  dplyr::select(state1h,iso1,un1,t,everything()) %>%
  dplyr::ungroup()
```

```{r}
nrow(cov_agg) # 942 entries for 157 countries X 6 time spells
```


### strings
```{r}
# names(cov_agg)
# function to remove duplicate elements in a comma-separated vbl value
# remove_duplicates <- function(input_string) {
#   unique_values <- unique(unlist(strsplit(input_string, ", ")))
#   return(paste(unique_values, collapse = ", "))
# }

# remove duplicate values in strings
cov_agg$conf_conf_ids <- sapply(cov_agg$conf_conf_ids, remove_duplicates)
cov_agg$conf_dyad_ids <- sapply(cov_agg$conf_dyad_ids, remove_duplicates)
```

```{r}
### number of conflicts in t
# count all comma-separated elements 
cov_agg$all_nr <- sapply(strsplit(as.character(cov_agg$conf_conf_ids), ","), length)
# count "no conflict" elements 
cov_agg$nc_nr <- sapply(strsplit(as.character(cov_agg$conf_conf_ids), ","), function(x) sum(trimws(x) == "no conflict"))
# count number of conflicts
cov_agg$conf_n <- cov_agg$all_nr - cov_agg$nc_nr 
```

```{r}
### number of adversaries i.e. enemies in t
# count all comma-separated elements 
cov_agg$all_nr <- sapply(strsplit(as.character(cov_agg$conf_dyad_ids), ","), length)
# count "no conflict" elements 
cov_agg$nc_nr <- sapply(strsplit(as.character(cov_agg$conf_dyad_ids), ","), function(x) sum(trimws(x) == "no conflict"))
# count number of conflicts
cov_agg$enem_n <- cov_agg$all_nr - cov_agg$nc_nr 

cov_agg <- cov_agg %>% dplyr::select(-c(all_nr,nc_nr))
```

```{r}
a <- cov %>%
  dplyr::filter(state1h == "Iraq") #%>% View()
b <- cov_agg %>%
  dplyr::filter(state1h == "Iraq") #%>% View()
View(a)
View(b)
```





## V.6) Recode/Add variables


### a) descriptive stats

Due to the aggregation process, there might be issues with the variables' scaling depending on their distributions. I'll especially consider metric variables that might better be coded as categorical after examining their values. 
```{r}
summary(cov_agg) 
names(cov_agg)
```

#### milex, gdp, pop

```{r}
# library(sjmisc)
# library(e1071)

# Calculate the skewness of milex_i in cov_agg
skewness(cov_agg$milex) # 11.8
hist(cov_agg$milex, 100) # strong right skew --> log-transform
hist(log(cov_agg$milex),100) # better

skewness(cov_agg$gdp) # 9.5
hist(cov_agg$gdp, 100) # strong right skew --> log-transform
hist(log(cov_agg$gdp),100) # better

skewness(cov_agg$population) # 7.7
hist(cov_agg$population, 100) # strong right skew --> log-transform
hist(log(cov_agg$population),100) # better

```

#### vdem variables
```{r}
# library(e1071)

hist(cov_agg$democracy, 100) # evenly distributed
frq(cov_agg$coups) # in 93 % of observations we see no coup --> almost no variance. binary dummy for 1= experienced coup, 0 = no coup.

hist(cov_agg$sov_ter, 100) 
skewness(cov_agg$sov_ter) # left skew -1.75
summary(cov_agg$sov_ter) # median split at value 95.0

hist(cov_agg$sov_score, 100) # left skew, but bulk looks okayish
skewness(cov_agg$sov_score) # left skew -1.55
hist(exp(cov_agg$sov_score),100) 
summary(cov_agg$sov_score) # median split at value 1.56

hist(cov_agg$sov_dom, 100) # slight left skew
skewness(cov_agg$sov_dom) # left skew -1.75
hist(exp(cov_agg$sov_dom),100)   # left skew -1.55
summary(cov_agg$sov_dom) # median split at value 1.55

hist(cov_agg$sov_for) # slight left skew
skewness(cov_agg$sov_for) # left skew -1.4
hist(exp(cov_agg$sov_for),100) 
summary(cov_agg$sov_for) # median split at value 1.53
```


#### conflict variables
```{r}
names(cov_agg)
library(sjmisc)

names(cov_agg)

frq(cov_agg$conf_n) # 30 % = 0, i.e. not part of any conflicts during a given t; the remaining country-t observations range from 1-14 (i.e. number of conflicts the country participated in in a given time spell)
cov_agg %>% group_by(state1h) %>% summarise(n = n(conf_n)) %>% frq(n)


frq(cov_agg$enem_n) # 30 % = 0, i.e. having no adversaries during a given t; the remaining country-t observations range from 1-20 (i.e. number of adversaries a country fought during a given time spell) 

frq(cov_agg$enem_intra) # 78% = 0, no intrastate conflict during a given t
frq(cov_agg$enem_inter) # 96% = 0, no interstate conflict during a given t
frq(cov_agg$enem_interintra) # 55% = 0, no internationalized intrastate conflict during a given t
frq(cov_agg$enem_ter) # 69% = 0, no conflicts due to territory issues during a given t
frq(cov_agg$enem_pol) # 50% = 0, no conflicts due to political issues during a given t
frq(cov_agg$enem_minor) # 47% = 0, i.e. not involved in any minor conflicts during a given t
frq(cov_agg$enem_war) # 62% = 0, i.e. not involved in any wars during a given t
```
Note that for the period 1993-2023, there were no extra-systemic conflicts. In 96% of the cases, violent conflicts were not carried out between nation states. Almost all of the militarized conflicts during this period were intrastate ones, the only difference being whether foreign parties' were involved in the conflict or not.



### b) rescale/recode & compute


#### dummies occurrence/non-occurrence
```{r}
cov_agg <- cov_agg %>% 
  # during a given t...
  dplyr::mutate(d_coups = ifelse(coups == 0,0,1), # min one coup 
              d_intra = ifelse(enem_intra >0,1,0), # min one intrastate conf
              d_inter = ifelse(enem_inter >0,1,0), # min one interstate conf
              d_interintra = ifelse(enem_interintra >0,1,0), # min one intern. intras conf
              d_ter = ifelse(enem_ter >0,1,0), # ter conf with min one adversary
              d_pol = ifelse(enem_pol >0,1,0), # pol conf with min one adversary
              d_minor = ifelse(enem_minor >0,1,0), # min one minor conf (<1000 deaths)
              d_war = ifelse(enem_war >0,1,0), # min one war (>=1000 deaths)
              d_conf = ifelse(conf_n >0,1,0)) # min. one conflict
```


#### dummies median split
```{r}
cov_agg <- cov_agg %>% 
  dplyr::mutate(d_sov_ter = case_when(sov_ter >=95 ~ 1,
                                      sov_ter < 95 ~ 0,
                                      .default = NA)) %>% # 1= control over min 95% territory
  dplyr::mutate(d_sov_score = case_when(sov_score >= 1.56 ~ 1,
                                        sov_score < 1.56 ~ 0,
                                        .default = NA)) # 1= high sov score (min 1.5)

```



@nga:
  From @Wang.2023: 6f.; @Pamp.2021: 8
-   mil_burden: military burden defined as ratio of military expenditure to gdp
-   ln_milex: logarithm of military expediture as proxy for arms production capacity or demand
-   ln_gdp: logarithm of gdp as proxy for economic clout
-   ln_population: logarithm of population as proxy for market size

```{r}
hist(milex_imp$milex,100) # right skew
hist(log(milex_imp$milex),100) # better
```




#### log
log operations might yield infinite values if the input value was 0, so we have to replace zeros with something similar, e.g. 0.0001
```{r}
cov_agg <- cov_agg %>% 
  dplyr::mutate(milex = ifelse(milex == 0, 0.0001, milex),
                gdp = ifelse(gdp == 0, 0.0001, gdp),
                population = ifelse(population == 0, 0.0001, population))

cov_agg <- cov_agg %>% 
  dplyr::mutate(mil_burden = milex/gdp, # military burden = mil. expenditure as share of gdp
                ln_milex = log(milex), 
                ln_mil_burden = log(mil_burden),    
                ln_gdp = log(gdp),    
                ln_population = log(population))   

```

Check
```{r}
result <- lapply(cov_agg, function(x) any(is.infinite(x) | is.nan(x)))
print(result) # looks good
```


#### quantile
```{r}
names(cov_agg)
```

```{r}
## categorize countries into groups according to their gdp and military spending
cov_agg <- cov_agg %>%
  dplyr::group_by(t) %>%
  dplyr::mutate(
    # 1 lowest 25%, 2 = middle 50%, 3 = upper 25%
    gdp_cat = as.integer(cut(gdp, breaks = quantile(gdp, probs = c(0, 0.25, 0.75, 1), na.rm = TRUE), include.lowest = TRUE, labels = FALSE)),
    pop_cat = as.integer(cut(population, breaks = quantile(population, probs = c(0, 0.25, 0.75, 1), na.rm = TRUE), include.lowest = TRUE, labels = FALSE)),
    democracy_cat = as.integer(cut(democracy, breaks = quantile(democracy, probs = c(0, 0.25, 0.75, 1), na.rm = TRUE), include.lowest = TRUE, labels = FALSE)),
    sov_score_cat = as.integer(cut(sov_score, breaks = quantile(sov_score, probs = c(0, 0.25, 0.75, 1), na.rm = TRUE), include.lowest = TRUE, labels = FALSE)),
    mil_burden_cat = as.integer(cut(mil_burden, breaks = quantile(mil_burden, probs = c(0, 0.25, 0.75, 1), na.rm = TRUE), include.lowest = TRUE, labels = FALSE)),
    milex_cat = as.integer(cut(milex, breaks = quantile(milex, probs = c(0, 0.25, 0.75, 1), na.rm = TRUE), include.lowest = TRUE, labels = FALSE))) %>%
  ungroup()
```


#### post-hoc rescaling (revisit later)

##### conflict variables
```{r}
names(cov_agg)
## ALREADY RUN; DO NOT REPEAT
# cov_agg <- cov_agg %>%
#   # fuse intra and intern. intra conflicts = all are intra conflicts whether foreign support is involved or not
#   dplyr::rename(d_intra_old = d_intra)
# 
# cov_agg <- cov_agg %>%
#   dplyr::mutate(d_intra = ifelse(d_interintra == 1,1, d_intra_old))
```

```{r}
frq(cov_agg$d_intra_old)
frq(cov_agg$d_intra) # increased number of intra conf
```

```{r}
cov_agg %>% dplyr::filter(d_intra_old == 0 & d_interintra == 1)
```


##### log base 2 & log base 10

Model: log(p/(1−p))= a + β*log(X)

```{r}
log(x,10)
log(x,2)
```

```{r}
names(cov_agg)
cov_agg <- cov_agg %>% 
  # for easier interpretation after modelling
  dplyr::mutate(log2_milex = log(milex,2),
                log10_milex = log(milex,10),
                log2_milbur = log(mil_burden,2),
                log10_milbur = log(mil_burden,10),
                log2_gdp = log(gdp,2),
                log10_gdp = log(gdp,10),
                log2_population = log(population,2),
                log10_population = log(population,10))
```

```{r}
# check
library(dplyr)
cov_agg %>% dplyr::select(milex,ln_milex,log2_milex,log10_milex)
```




#### check new variables

```{r}
hist(cov_agg$ln_milex, 100) 
hist(cov_agg$log2_milex, 100)  
hist(cov_agg$ln_gdp, 100)
hist(cov_agg$log2_gdp, 100) 
hist(cov_agg$ln_population, 100)
```

```{r}
# library(sjmisc)
frq(cov_agg$d_sov_ter) # med split: 1 = >=95
frq(cov_agg$d_sov_score) # med split: 1 = >=1.56
frq(cov_agg$d_coups) # 93% = 0

frq(cov_agg$d_conf) # 31% = 0
frq(cov_agg$d_inter) # 96% = 0
frq(cov_agg$d_intra) # 78% = 0
frq(cov_agg$d_interintra) # 55% = 0
frq(cov_agg$d_ter) # 70% = 0
frq(cov_agg$d_pol) # 50% = 0
frq(cov_agg$d_minor) # 47% = 0
frq(cov_agg$d_war) # 62% = 0
```

```{r}
# check for duplicates
which(duplicated(cov_agg) | duplicated(cov_agg, fromLast = TRUE))
```





#### save unlabelled version
```{r}
# save(cov_agg, file = "cov_agg.RData") # as R data file
# load("cov_agg.RData") 
```




### labels

```{r}
# cov_agg_lab <-  cov_agg # copy
```


```{r}
# library(Hmisc)
label(cov_agg_lab$iso1) <- "iso alpha 3 code"
label(cov_agg_lab$un1) <- "un m49 country code"
label(cov_agg_lab$cown1) <- "cow numeric code"
label(cov_agg_lab$cowen1) <- "cow name"
label(cov_agg_lab$cowc1) <- "cow character code"
label(cov_agg_lab$state1h) <- "harmonized name based on un m49"
label(cov_agg_lab$t) <- "time period"
```

```{r}
# library(Hmisc)
Hmisc::label(cov_agg_lab$gdp) <- "gdp (nominal, in USD billions)"
Hmisc::label(cov_agg_lab$ln_gdp) <- "log gdp (nominal, in USD billions)"
Hmisc::label(cov_agg_lab$milex) <- "milex (in constant USD million)"
Hmisc::label(cov_agg_lab$ln_milex) <- "log milex (in constant USD million)"
Hmisc::label(cov_agg_lab$mil_burden) <- "mil burden (%, i.e. milex as share of gdp)"
Hmisc::label(cov_agg_lab$ln_mil_burden) <- "log of mil burden"
Hmisc::label(cov_agg_lab$population) <- "inhabitants (in millions)"
Hmisc::label(cov_agg_lab$ln_population) <- "log inhabitants (in millions)"
```

```{r}
Hmisc::label(cov_agg_lab$gdp_cat) <- "gdp quantile (bottom 25% = 1, middle 25-75% = 2, highest >75% = 3)"
Hmisc::label(cov_agg_lab$milex_cat) <- "milex quantile (bottom 25% = 1, middle 25-75% = 2, highest >75% = 3)"
Hmisc::label(cov_agg_lab$mil_burden_cat) <- "mil burden quantile (bottom 25% = 1, middle 25-75% = 2, highest >75% = 3)"
Hmisc::label(cov_agg_lab$pop_cat) <- "population quantile (bottom 25% = 1, middle 25-75% = 2, highest >75% = 3)"
Hmisc::label(cov_agg_lab$democracy_cat) <- "democracy quantile (bottom 25% = 1, middle 25-75% = 2, highest >75% = 3)"
Hmisc::label(cov_agg_lab$sov_score_cat) <- "sov_score quantile (bottom 25% = 1, middle 25-75% = 2, highest >75% = 3)"
```

```{r}
Hmisc::label(cov_agg_lab$coups) <- "number coup attempts during t"
Hmisc::label(cov_agg_lab$democracy) <- "vdem elective democracy score (0 low, 1 high)"
Hmisc::label(cov_agg_lab$sov_dom) <- "score independent domestic policy decisions, low to high"
Hmisc::label(cov_agg_lab$sov_for) <- "score independent foreign policy decisions, low to high"
Hmisc::label(cov_agg_lab$sov_score) <- "score independent policy decisions, low to high"
Hmisc::label(cov_agg_lab$sov_ter) <- "percent of territory under effective control"

```

```{r}
Hmisc::label(cov_agg_lab$d_sov_ter) <- "yes-no, min. 95 percent of territory under effective control?"
Hmisc::label(cov_agg_lab$d_sov_score) <- "yes-no, independence from foreign state - ranked in upper 50%?"
Hmisc::label(cov_agg_lab$d_coups) <- "yes-no, coup during t?"

Hmisc::label(cov_agg_lab$d_conf) <- "yes-no, involved in conflict(s) during t?"
Hmisc::label(cov_agg_lab$d_inter) <- "yes-no, fought in inter conflict(s) during t?"
Hmisc::label(cov_agg_lab$d_intra) <- "yes-no, fought in intra (with or without foreign interv) conflict(s) during t?"
Hmisc::label(cov_agg_lab$d_intra_old) <- "yes-no, fought in pure intra (i.e. without foreign intervention) conflict(s) during t?"
Hmisc::label(cov_agg_lab$d_interintra) <- "yes-no, fought in intern intra conflict(s) during t?"

Hmisc::label(cov_agg_lab$d_minor) <- "yes-no, fought in minor conflict(s) during t?"
Hmisc::label(cov_agg_lab$d_war) <- "yes-no, fought in war during t?"
Hmisc::label(cov_agg_lab$d_ter) <- "yes-no, fought due to territory issue during t?"
Hmisc::label(cov_agg_lab$d_pol) <- "yes-no, fought due to political issue during t?"
```

```{r}
Hmisc::label(cov_agg_lab$conf_n) <- "number of conflicts during t"
Hmisc::label(cov_agg_lab$enem_inter) <- "involved in inters conf with how many adversaries during t?"
Hmisc::label(cov_agg_lab$enem_intra) <- "involved in intras conf with how many adversaries during t?"
# Hmisc::label(cov_agg_lab$enem_intra_old) <- "involved in pure intra (i.e. without foreign intervention) conf with how many adversaries during t?"
Hmisc::label(cov_agg_lab$enem_interintra) <- "involved in interna. intra conf with how many adversaries during t?"

Hmisc::label(cov_agg_lab$enem_n) <- "number of adversaries during t"
Hmisc::label(cov_agg_lab$enem_minor) <- "number of adversaries fought in minor conflict(s) (25-999 deaths/year) during t"
Hmisc::label(cov_agg_lab$enem_war) <- "number of adversaries fought in war (min. 1000 deaths/year) during t"
Hmisc::label(cov_agg_lab$enem_ter) <- "number of adversaries fought due to territory issue during t"
Hmisc::label(cov_agg_lab$enem_pol) <- "number of adversaries fought due to political issue during t"

```

```{r}
# Hmisc::label(cov_agg_lab$types) <- "0=none,1=extra,2=inter,3=intra,4=intra(ink foreign intervention"
Hmisc::label(cov_agg_lab$conf_dyad_ids) <- "ID(s) of conflict dyad during t, i.e. which adversaries country was in conflict with during t?"
Hmisc::label(cov_agg_lab$conf_conf_ids) <- "ID(s) of conflicts fought during t, i.e. which conflicts country was involved in during t"
```


### save
```{r}
# save(cov_agg_lab, file = "cov_agg_lab.RData") # as R data file
# load("cov_agg_lab.RData")
```





## V.7) Split cov dfs by time spell & store in a list

```{r}
# unclass_cols <- function(df) {
#   df[] <- lapply(df, unclass)
#   return(df)
# }
# cov_agg <- unclass_cols(cov_agg)

```

```{r}
cov_list <- split(cov_agg, cov_agg$t) # split by tspell
cov_list$t1
```

```{r}
# save(cov_list, file = "cov_list.RData") # as R data file
# load("cov_list.RData") 
```



## V.8) descriptive overview/visualisation


VDEM SOVEREIGNTY
```{r}
# hist(cov_agg$sov_dom, 200)
# range(cov_agg$sov_dom) # -1.57 to 2.3
# hist(cov_agg$sov_for, 200)
# range(cov_agg$sov_for) # -1.66 to 2.4

# hist(cov_agg$sov_score, 200)
# range(cov_agg$sov_score) # -1.6 to 2.35

# library(ggplot2)
ggplot(cov_agg, aes(x = sov_score)) +
  # Histogram where the y-axis shows the proportion
  geom_histogram(aes(y = after_stat(count/sum(count))),
                 binwidth = 0.25, # binwidth
                 fill = "salmon",
                 color = "black",
                 alpha = 0.6) +
  # Density line scaled to match the histogram proportions
  geom_density(aes(y = after_stat(..density.. * 0.25)), # *binwidth
               color = "blue",
               size = 0.6) +
  labs(title = "",
       x = "\nSovereignty Score",   # Inserts a line break at the start to push the label down slightly
       y = "Percent of Countries\n") +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  scale_x_continuous(breaks = seq(-2, 2.5, by = 0.5)) +  # ticks every 0.5 unit
  theme(
    plot.margin = unit(c(0.7, 0.9, 0.7, 0.7), "cm"),
    plot.background = element_rect(fill = "seashell", color = NA),
    panel.grid.major.x = element_line(size = 0.6, color = "grey80"),
    panel.grid.minor.x = element_line(size = 0.4, color = "grey80"),
    panel.grid.major.y = element_line(size = 0.6, color = "grey80"),
    panel.grid.minor.y = element_line(size = 0.4, color = "grey80"),
    # Increase the space below the x-axis title, if needed
    axis.title.x = element_text(margin = margin(t = 10))
  )

```




VDEM REGIME SCORE
```{r}
# hist(cov_agg$democracy, 200)
# range(cov_agg$democracy)

# library(scales)
# library(ggplot2)

ggplot(cov_agg, aes(x = democracy)) +
  # Histogram where the y-axis shows the proportion
  geom_histogram(aes(y = after_stat(count / sum(count))),
                 binwidth = 0.01,  # binwidth
                 fill = "salmon",
                 color = "black",
                 alpha = 0.6) +
  # Density line scaled to match the histogram proportions
  geom_density(aes(y = after_stat(..density.. * 0.01)),  # multiply density by binwidth
               color = "blue",
               size = 0.6) +
  labs(title = "",
       x = "\nRegime Score",      
       y = "Percent of Countries\n") +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  scale_x_continuous(breaks = seq(0, 1.2, by = 0.1)) +  # ticks every 0.1 unit
  theme(
    plot.margin = unit(c(0.7, 0.9, 0.7, 0.7), "cm"),
    plot.background = element_rect(fill = "seashell", color = NA),
    panel.grid.major.x = element_line(size = 0.6, color = "grey80"),
    panel.grid.minor.x = element_line(size = 0.4, color = "grey80"),
    panel.grid.major.y = element_line(size = 0.6, color = "grey80"),
    panel.grid.minor.y = element_line(size = 0.4, color = "grey80"),
    axis.title.x = element_text(margin = margin(t = 10))
  )

```



# VI) HARMONIZATION OF NODE AND DYAD DATA


## a) Drop nodes from matrices i.e. networks

```{r}
# load("iat_adj_imp.RData")
# load("alliance_adj_imp.RData")
# load("conflict_adj_imp.RData")
# load("capdist_mat.RData")
# load("capdist_mat10.RData")
# load("capdist_mat100.RData")
# load("capdist_mat1000.RData")
# load("mismatch.RData") # not included UN members
```

Our final problem is that the number of countries present in the dyadic data and in the cleaned covariate data differ. There is a mismatch between node & edge covariates data.
```{r}
# nodes in the dyadic data are all 193 UN members
dim(iat_adj_imp[[i]])
dim(alliance_adj_imp[[i]]) 
dim(conflict_adj_imp[[i]]) 
dim(capdist_mat) 

# but we only retained complete cov data for 157 countries
cov_agg %>%
  group_by(t) %>%
  dplyr::summarise(t_count = n())
```

```{r}
# These are nodes that were excluded from analysis due to high number of missing or incorrect cov data. We'll now drop them from the adjacency matrices.
excluded_states <- c(missing_states, "Timor-Leste", "Montenegro", "South Sudan") %>% sort()

# And these are the nodes that are mismatched between dyad and node data
in_matrices <- rownames(iat_adj_imp[[1]])
in_cov <- unique(cov_agg$state1h)

identical(excluded_states,mismatch) # the 36 UN countries that were dropped from cov data correspond to those that are mismatched between the dyadic data and cov data. 
```



We'll now drop the 36 countries from the matrices.

1. iat matrices
```{r}
iat_adj <- list()
## drop from iat adj matrices
for (i in 1:length(iat_adj_imp)) {
  iat_adj[[i]] <- iat_adj_imp[[i]][
    !rownames(iat_adj_imp[[i]]) %in% mismatch, 
    !colnames(iat_adj_imp[[i]]) %in% mismatch]
}
```

2. alliance matrices
```{r}
alliance_adj <- list()
## drop from alliance adj matrices
for (i in 1:length(alliance_adj_imp)) {
  alliance_adj[[i]] <- alliance_adj_imp[[i]][
    !rownames(alliance_adj_imp[[i]]) %in% mismatch, 
    !colnames(alliance_adj_imp[[i]]) %in% mismatch]
}

```

3. conflict matrices
```{r}
conflict_adj <- list()
## drop from conflict adj matrices
for (i in 1:length(conflict_adj_imp)) {
  conflict_adj[[i]] <- conflict_adj_imp[[i]][
    !rownames(conflict_adj_imp[[i]]) %in% mismatch, 
    !colnames(conflict_adj_imp[[i]]) %in% mismatch]
}

```

4. capdist matrix
```{r}
## drop from capdist adj matrix
capdist_adj <- capdist_mat[
  !(rownames(capdist_mat) %in% mismatch), 
  !(colnames(capdist_mat) %in% mismatch)]
```

```{r}
## drop from capdist adj matrix
capdist10_adj <- capdist_mat10[
  !(rownames(capdist_mat10) %in% mismatch), 
  !(colnames(capdist_mat10) %in% mismatch)]
```

```{r}
## drop from capdist adj matrix
capdist100_adj <- capdist_mat100[
  !(rownames(capdist_mat100) %in% mismatch), 
  !(colnames(capdist_mat100) %in% mismatch)]
```

```{r}
## drop from capdist adj matrix
capdist1000_adj <- capdist_mat1000[
  !(rownames(capdist_mat1000) %in% mismatch), 
  !(colnames(capdist_mat1000) %in% mismatch)]
```

## b) Check dimensions of all matrices (arms, alliance, conflict, capdist)
```{r}
# e.g.no longer present in matrices
mismatch %in% rownames(iat_adj[[i]])
mismatch %in% rownames(alliance_adj[[i]])
mismatch %in% rownames(conflict_adj[[i]])
mismatch %in% rownames(capdist_adj)
```

```{r}
# extract country names from matrices and cov data
arms <- rownames(iat_adj[[1]]) 
ally <- rownames(alliance_adj[[1]])
conf <- rownames(conflict_adj[[1]])
capd <- rownames(capdist_adj)
cov.n <- unique(cov_agg$state1h)

# compare accross all dyadic and cov data
identical(sort(arms), sort(ally))
identical(sort(ally), sort(conf))
identical(sort(conf), sort(capd)) 
identical(sort(capd), sort(cov)) 
# the same states are present accross all matrices and the country covariate dataframe
```
@nga --> looks good, i.e. the same 157 across all data

### save
```{r}
# save(iat_adj, file = "iat_adj.RData")
# load("iat_adj.RData")

# save(alliance_adj, file = "alliance_adj.RData")
# load("alliance_adj.RData")

# save(conflict_adj, file = "conflict_adj.RData")
# load("conflict_adj.RData")

# save(capdist_adj, file = "capdist_adj.RData")
# load("capdist_adj.RData")
# save(capdist10_adj, file = "capdist10_adj.RData")
# load("capdist10_adj.RData")
# save(capdist100_adj, file = "capdist_adj100.RData")
# load("capdist100_adj.RData")
# save(capdist1000_adj, file = "capdist_adj1000.RData")
# load("capdist1000_adj.RData")
```



## c) Harmonize matrix dimensions names/order

Lastly, we'll address the issue of differing order within the 3 adjacency matrices. Currently, they do not align between matrices.
```{r}
print(arms) # iat matrix starts with "Argentina", ending with "Uzbekistan"
print(ally) # alliance matrix starts with "Afghanistan", ending with "Uganda"
print(conf) # conflict matrix starts with "Angola", ending with "Zimbabwe"
print(capd) # capdist matrix starts with "Afghanistan", ending with "Zimbabwe"
print(cov.n) # cov data starts with "Afghanistan", ending with "Zimbabwe"
```


### reorder dimensions

Reorder the dimensions of all matrices to match the order in covariate dataframe
```{r}
# iat.mat, conf.mat, ally.mat are lists of matrices and 'order' is the character vector of country names in the desired order, extracted from the cov_agg df
order <- cov.n

# Combine iat_adj, conflict_adj, alliance_adj into a meta-list of 4 lists, each with 6 matrices
lists <- list(iat_adj, alliance_adj, conflict_adj)

# Loop over each of the 3 lists
for(i in seq_along(lists)) {
  # Loop over each of the 6 matrices in the current list
  for(j in seq_along(lists[[i]])) {
    # Reorder the rows and columns of the current matrix
    lists[[i]][[j]] <- lists[[i]][[j]][order, order]
  }
}

# reorder capdist_adj dimensions
capdist_adj2 <- capdist_adj[order, order]
capdist10_adj2 <- capdist10_adj[order, order]
capdist100_adj2 <- capdist100_adj[order, order]
capdist1000_adj2 <- capdist1000_adj[order, order]
```

### check order of dimensions
```{r}
# extract the 3 lists with the new matrices
iat_adj2 <- lists[[1]]
alliance_adj2 <- lists[[2]]
conflict_adj2 <- lists[[3]]

# save new order of the rownames
arms <- rownames(iat_adj2[[1]])
ally <- rownames(alliance_adj2[[1]])
conf <- rownames(conflict_adj2[[1]])
capd <- rownames(capdist_adj2)

# all start with Afghanistan and end with Zimbabwe =)
print(arms)
print(ally)
print(conf) 
print(capd)
```

```{r}
# compare rownames order
identical(ally, conf) # even without sorting, identical dimension order in alliance & conflict matrices
identical(ally, arms) # same: identical dimension order
identical(ally, capd) # same: identical dimension order
```


### check assignment of values 

Check assignment of cell values. Were values correctly shifted along with the changed order of dimension names?
  
  CONFLICT CELLS
```{r}
# Conflict matrices
View(conflict_adj[[1]]) # we see in the original matrix at t1 that e.g. Croatia vs Bosnia-Herzegovina aswell as Azerbaijan vs Armenia have conflict ties with value 2
View(conflict_adj2[[1]]) # order harmonized

# Compare cell values: 
conflict_adj[[1]]["Azerbaijan", "Armenia"] # value of the "Azerbaijan"x"Armenia" cell in the initial conflict adj matrix at t1
conflict_adj2[[1]]["Azerbaijan", "Armenia"] # value of the "Azerbaijan"x"Armenia" cell in the conflict adj matrix at t1 with changed dimension order

# --> the conflict tie value is 2 for Azerb x Armenia in both the old (before ordering dimensions) and the new matrix (after ordering dimensions)!
```

```{r}
## LET'S CHECK AGAIN FOR OTHER DYADS

# same!
conflict_adj[[1]]["Croatia", "Bosnia & Herzegovina"]
conflict_adj2[[1]]["Croatia", "Bosnia & Herzegovina"]

# same!
conflict_adj[[1]]["Congo - Kinshasa", "Angola"]
conflict_adj2[[1]]["Congo - Kinshasa", "Angola"] 
```

ALLIANCE CELLS
```{r}
# alliance matrices
View(alliance_adj[[1]]) # we see in the original matrix at t1 that e.g. Bahrain & Algeria have 2 active alliance agreements
View(alliance_adj2[[1]]) # order harmonized

# Compare cell values: 
alliance_adj[[1]]["Bahrain", "Algeria"] # value of the "Bahrain" & "Algeria" cell in the initial alliance adj matrix at t1
alliance_adj2[[1]]["Bahrain", "Algeria"] # value of the "Bahrain" & "Algeria" cell in the alliance adj matrix at t1 with changed dimension order
# --> they are the same! Here we see "Bahrain" & "Algeria" have the tie value 3 in both the old (before ordering dimensions) and the new matrix (after ordering dimensions)!
```

IAT CELLS
```{r}
View(iat_adj[[1]]) 
View(iat_adj2[[1]]) # order harmonized

# same 
iat_adj[[1]]["Bahrain", "Algeria"] 
iat_adj2[[1]]["Bahrain", "Algeria"] 
```


CAPDIST CELLS
```{r}
View(capdist_adj) 
View(capdist_adj2) # order harmonized

# same 
capdist_adj["Bahrain", "Algeria"] 
capdist_adj2["Bahrain", "Algeria"] 
```


### save
```{r}
# save(iat_adj2, file = "iat_adj2.RData")
# load("iat_adj2.RData")

# save(conflict_adj2, file = "conflict_adj2.RData")
# load("conflict_adj2.RData")

# save(alliance_adj2 , file = "alliance_adj2.RData")
# load("alliance_adj2.RData")

# save(capdist_adj2 , file = "capdist_adj2.RData")
# load("capdist_adj2.RData")
# save(capdist10_adj2, file = "capdist10_adj2.RData")
# load("capdist10_adj2.RData")
# save(capdist100_adj2, file = "capdist_adj2100.RData")
# load("capdist100_adj2.RData")
# save(capdist1000_adj2, file = "capdist_adj21000.RData")
# load("capdist1000_adj2.RData")
```


WITH THIS, WE HAVE COMPLETED ALL CLEANING OPERATIONS AND CREATED THE INPUT OBJECTS THAT IS NEEDED FOR THE CREATION OF WEIGHTED NETWORK OBJECTS LATER. NOW AS THE LAST STEP, WE'LL CREATE BINARY VERSIONS OF THE ADJACENCY MATRICES.


# VII) BINARY VERSIONS OF ADJ MATRICES

## arms
```{r}
# Initialize an empty list to store the binarized matrices
iat_adj2.bin <- list()

# Loop over each matrix in iat_adj2
for(i in 1:length(iat_adj2)) {
  # Binarize the matrix by setting all non-zero weights to 1
  iat_adj2.bin[[i]] <- as.matrix((iat_adj2[[i]] > 0) * 1)
}

```

Check: Compare the tiv values in iat_adj2 (weighted matrices) and iat_adj2.bin (binary matrices)
```{r}
# t6
View(iat_adj2[[6]])
View(iat_adj2.bin[[6]])
# looks good! weights in iat_adj2 have been binarized in iat_adj2.bin
```

```{r}
# t1
View(iat_adj2[[1]])
View(iat_adj2.bin[[1]])
```



## alliances
```{r}
# Initialize an empty list to store the binarized matrices
alliance_adj2.bin <- list()

# Loop over each matrix in iat_adj2
for(i in 1:length(alliance_adj2)) {
  # Binarize the matrix by setting all non-zero weights to 1
  alliance_adj2.bin[[i]] <- as.matrix((alliance_adj2[[i]] > 0) * 1)
}

```

Compare the values in alliance_adj2 (weighted matrices) and alliance_adj2.bin (binary matrices)
```{r}
# t6
View(alliance_adj2[[6]])
View(alliance_adj2.bin[[6]])
# looks good!
```


## conflicts
```{r}
# Initialize an empty list to store the binarized matrices
conflict_adj2.bin <- list()

# Loop over each matrix in iat_adj2
for(i in 1:length(conflict_adj2)) {
  # Binarize the matrix by setting all non-zero weights to 1
  conflict_adj2.bin[[i]] <- as.matrix((conflict_adj2[[i]] > 0) * 1)
}

```

Compare the values in conflict_adj2 (weighted matrices) and conflict_adj2.bin (binary matrices). Since conflicts are rare, we have a zero inflation problem here.
Most of the matrix cells will be zero. Therefore we have to look specifically at values of those dyads where we know that they had conflicts, so we're looking at the conflict data frame, e.g. for time period t3 = 2002-2006.

```{r}
# load("conflict_t_agg.RData")

# t2 = 1998-2002
conflict_t_agg %>% 
  dplyr::filter(t== "t2") 
# e.g. Angola vs Rwanda conflict lasted for all 4 years during t2, i.e. between 1998-2002

# t6 = 2018-23
conflict_t_agg %>% 
  dplyr::filter(t== "t6")  
# e.g. Bahrain vs Yemen, conflict lasted for 6 year between 2018-23
```

```{r}
# t2 = 1998-2002
conflict_adj2[[2]]["Angola", "Rwanda"] # weight = 4
conflict_adj2.bin[[2]]["Angola", "Rwanda"] # binarized = 1

# t6 = 2018-23
conflict_adj2[[6]]["Bahrain", "Yemen"] # weight = 6
conflict_adj2.bin[[6]]["Bahrain", "Yemen"] # binarized = 1
```


## save

```{r}
# save(iat_adj2.bin, file = "iat_adj2.bin.RData")
# load("iat_adj2.bin.RData")

# save(alliance_adj2.bin, file = "alliance_adj2.bin.RData")
# load("alliance_adj2.bin.RData")

# save(conflict_adj2.bin, file = "conflict_adj2.bin.RData")
# load("conflict_adj2.bin.RData")
```


# MATERIALS NOT USED

1) Other dyadic covariates (not in use)
  
military interstate dispute (MID) OR THREAT
  -   For more infos: https://correlatesofwar.org/data-sets/mids/
  
proxy war (UCDP-ESD) 
  -   Uppsala Conflict Data Program (UCDP) External Support Dataset (ESD):
  https://ucdp.uu.se/downloads/index.html#externalsupport
-   Cite: Meier, Vanessa, Niklas Karlén, Therése Pettersson & Mihai Croicu (2023). External Support in Armed Conflicts. Introducing the UCDP External Support Dataset (ESD), 1975-2017. Journal of Peace Research. Online First.

defensive cooperation agreement (Kinne 2016)

gravity model variables
- culture
- historical colonial ties
- language
- border
- currency

indirect alliances
- set up via bipartite network or community detection


# TODO

- Problem is other packages/datasets
  - in maps pck, world cities: juba, suva, podgorica are capital cities. Also, Cyprus and Costa Rica have double entries, each with different geographic information =/
  - in cepii capdist information, belgium and luxembourg were jumbled together, just as Serbia & Montenegro. Also, some iso3c information were wrong?
  - in capdist data, 12 UN countries were missing capdist information (possibly the data too old?)
  
- New learning
  - spatial analysis, inc. ggmap, map, naturalearth?

# Problems
- spl_wider() does not work properly anymore, and piv_longer by extension. Check
  

# OUTPUTS

While running the script, the following files were saved to document the steps taken during the data cleaning process
```{r}
## USEFUL INFOS
# load("iat_active.RData")
# load("alliance_active.RData")
# load("conflict_active.RData")
# load("all_active.RData")

## DYADIC DATA COUNTRY-YEAR LEVEL
# load("iat.RData") # dyad-transfer level
# load("iat.pcw.RData") # dyad-transfer level subset 1993-2023
# load("iat_year_agg.RData")  # aggregated from dyad-transfer to dyad-year level

# load("atop.RData") # already on dyad-year level, so no aggregation needed
# load("ally.pcw.RData")
# load("capdist.RData") # only dyad level, no year information

# load("conflict_dyad.RData") # already on dyad-year level, so no aggregation needed
# load("conflict_dyad.pcw2.RData")


## DYADIC DATA AGGREGATED TO T
# load("iat_t_agg.RData") # aggregated from dyad-year to dyad-time.spell level
# load("alliance_t_agg.RData")
# load("conflict_t_agg.RData")

## EDGE LISTS AGGREGATED t1-t6
# load("capdist_el.RData")
# load("iat_el.RData")
# load("alliance_el.RData")
# load("conflict_el.RData") 

## LIST WITH EGDE LISTS, separated by t1-t6
# load("conflict_list.RData") 
# load("alliance_list.RData") 
# load("iat_list.RData") 

## ADJACENCY MATRICES
# load("iat_adj_binary.RData")
# load("alliance_adj_binary.RData")
# load("conflict_adj_binary.RData")

# load("iat_adj_weight.RData")
# load("alliance_adj_weight.RData")
# load("conflict_adj_weight.RData")
# load("capdist_adj_weight.RData")

## MATRIX IMPUTATION ROUND 1: ACROSS TIME SPELLS
# load("conflict_adj_imp.RData")
# load("conflict_adj_imp_df.RData")
# load("alliance_adj_imp.RData")
# load("alliance_adj_imp_df.RData")
# load("iat_adj_imp.RData")
# load("iat_adj_imp_df.RData")

## MATRIX IMPUTATION ROUND 2: ACROSS NETWORKS
# load("conflict_adj_imp.RData")
# load("conflict_adj_imp_df.RData")
# load("alliance_adj_imp.RData")
# load("alliance_adj_imp_df.RData")
# load("iat_adj_imp.RData")
# load("iat_adj_imp_df.RData")

## FINAL MATRICES (dropped nodes with missing cov data)
# load("iat_adj.RData")
# load("alliance_adj.RData")
# load("conflict_adj.RData")
# load("capdist_adj.RData")

## MATRICES AFTER ORDERING DIMENSIONS (WEIGHTED)
# load("iat_adj2.RData")
# load("alliance_adj2.RData")
# load("conflict_adj2.RData")
# load("capdist_adj2.RData")

## MATRICES AFTER ORDERING DIMENSIONS (BINARY)
# load("iat_adj2.bin.RData")
# load("alliance_adj2.bin.RData")
# load("conflict_adj2.bin.RData")

## NODAL DATA
# load("milex.RData") 
# load("gdp.RData") 
# load("population.RData") 
# load("vdem.RData") 
# load("ucdp_1state.wide.RData") 
# load("ucdp_1state.long.RData") 
# load("conflict_incidence.RData")
# load("conflict_state.RData")
# load("conflict_state2.RData") 

## NODAL DATA MERGED & AGGREGATED TO T
# load("vdem_imp.RData") 
# load("milex_imp.RData") 
# load("gdp_imp.RData")
# load("population_imp.RData") 

# load("cov.RData")   
# load("cov_agg.RData") 
# load("cov_list.RData") 
```



